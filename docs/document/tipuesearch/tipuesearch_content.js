var tipuesearch = {"pages":[{"title":" TNSG ","text":"TNSG This is the documentation page of Tensor Network State Git(TNSG), a highly efficient tensor network package written in Fortran 2003. For more information about the package, please visit our homepage or the github page . The following are the libraries TNSG provides and the modules they contain ltnsp ( rely on none) tensor_type: a class to operate on tensors tools: some useful tensor functions ltnsp_ext ( rely on ltnsp lrandom lkernel) tnsp_ext: some extra tensor functions ltenwork ( rely on ltnsp ldic lkernel) tensor_network: a class to operate on tensor networks tn_tensor_type: a class to deal with tensor contraction tensor_network_nesting: a class to operate on nested tensor networks ltimer ( rely on lkernel) timer: a class to benchmark the program lparalist ( rely on lkernel ldic) parameter_list: a class to manage the parameters lcumu ( rely on ltnsp ltnsp_ext lkernel) mod_cumu: a class to cumulate a value lrandom ( rely on lkernel) mod_rand: a class to generate random numbers ldic ( rely on lkernel ltnsp) mod_dictionary: a class to define python-type dictionary lkernel ( rely on ltnsp) string and all other modules: some kernel modules All the libraries are documented here except ltnsp , which deserves its own documentation page. Developer Info Wang Chao & Dong Shaojun","tags":"home","loc":"index.html"},{"title":"timer.f90 – TNSG","text":"This file depends on sourcefile~~timer.f90~~EfferentGraph sourcefile~timer.f90 timer.f90 sourcefile~error.f90 error.f90 sourcefile~timer.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~timer.f90->sourcefile~string.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~timer.f90->sourcefile~unidic.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~stack.f90 stack.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~stack.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules timer Source Code timer.f90 Source Code module timer use type_unidic use string use error implicit none private type ( unidic ) :: name_order integer , parameter :: max_elem = 100 real ( 8 ) :: start_time ( max_elem ) = 0 d0 real ( 8 ) :: cumu_time ( max_elem ) = 0 d0 character ( len = max_char_length ) :: names ( max_elem ) = '' integer :: state ( max_elem ) = 0 ! 1 for started, 2 for ended,  0 for not exist real ( 8 ) :: get_time external :: get_time interface timer_refresh module procedure timer_refresh_all module procedure timer_refresh_name end interface public timer_start , timer_end , timer_print , timer_refresh , timer_get contains subroutine timer_start ( name ) character ( len =* ), intent ( in ) :: name integer :: val real ( 8 ) :: time val = name_order % val ( trim ( name )) if ( val == 0 ) then call name_order % add ( trim ( name ), val ) names ( val ) = name end if if ( state ( val ) == 1 ) then call wc_error_stop ( 'timer.start' , 'timer for ' // trim ( name ) // ' has already been started' ) end if state ( val ) = 1 time = get_time () start_time ( val ) = time end subroutine subroutine timer_end ( name ) character ( len =* ), intent ( in ) :: name integer :: val real ( 8 ) :: time val = name_order % val ( trim ( name )) if ( val == 0 ) then call wc_error_stop ( 'timer.end' , 'timer for ' // trim ( name ) // ' has not been started' ) end if if ( state ( val ) == 0 ) then call wc_error_stop ( 'timer.end' , 'timer for ' // trim ( name ) // ' has been ended' ) end if time = get_time () cumu_time ( val ) = cumu_time ( val ) + ( time - start_time ( val )) start_time ( val ) = 0 d0 state ( val ) = 2 end subroutine function timer_get ( name ) result ( time ) character ( len =* ), intent ( in ) :: name integer :: val real ( 8 ) :: time , time2 val = name_order % val ( trim ( name )) if ( val == 0 ) then call wc_error_stop ( 'timer.get' , 'timer for ' // trim ( name ) // ' has not been started' ) end if if ( state ( val ) /= 0 ) then time2 = get_time () time = cumu_time ( val ) + ( time2 - start_time ( val )) else time = cumu_time ( val ) end if end function subroutine timer_print () integer :: i character ( len = 15 ) :: item_name call writemess ( '' ) call writemess ( '================================' ) item_name = 'Timer' call writemess ( item_name // 'Total time(s)' ) do i = 1 , max_elem if ( state ( i ) > 0 ) then item_name = names ( i ) call writemess ( item_name // str ( cumu_time ( i ))) end if end do call writemess ( '================================' ) call writemess ( '' ) end subroutine subroutine timer_refresh_name ( name ) character ( len =* ), intent ( in ) :: name integer :: val val = name_order % val ( trim ( name )) if ( val == 0 ) then call wc_error_stop ( 'timer.restart' , 'timer for ' // trim ( name ) // ' has not been started' ) end if cumu_time ( val ) = 0 d0 start_time ( val ) = 0 d0 state ( val ) = 0 end subroutine subroutine timer_refresh_all () start_time = 0 d0 cumu_time = 0 d0 state = 0 end subroutine end module","tags":"","loc":"sourcefile/timer.f90.html"},{"title":"statistics.f90 – TNSG","text":"This file depends on sourcefile~~statistics.f90~~EfferentGraph sourcefile~statistics.f90 statistics.f90 sourcefile~error.f90 error.f90 sourcefile~statistics.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~statistics.f90->sourcefile~string.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules statistics Source Code statistics.f90 Source Code module statistics use string use error use tools implicit none private type statis private integer :: key_num = 0 , max_key_num = 100 , key_len = 1 integer , allocatable :: key (:,:), repeats (:) real ( 8 ), allocatable :: val (:) logical :: empty = . true . contains private procedure :: initiate procedure :: add_sig procedure :: add_ary generic , public :: add => add_sig , add_ary procedure :: get_perc_sig procedure :: get_perc_ary generic , public :: get_perc => get_perc_sig , get_perc_ary procedure :: get_ave_val_sig procedure :: get_ave_val_ary generic , public :: get_ave_val => get_ave_val_sig , get_ave_val_ary procedure , public :: clean procedure , public :: show procedure , public :: show2 procedure , public :: sort_key procedure , public :: sort_val end type public statis contains subroutine initiate ( ST , len ) class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: len ST % key_len = len allocate ( ST % key ( ST % key_len , ST % max_key_num )) allocate ( ST % repeats ( ST % max_key_num )) allocate ( ST % val ( ST % max_key_num )) ST % repeats = 0 ST % val = 0 ST % key = 0 ST % empty = . false . end subroutine subroutine add_sig ( ST , new_key , val ) class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: new_key real ( 8 ), optional , intent ( in ) :: val call ST % add_ary ([ new_key ], val ) end subroutine subroutine add_ary ( ST , new_key , val_ ) class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: new_key (:) real ( 8 ), optional , intent ( in ) :: val_ real ( 8 ) :: val integer :: i logical ( 1 ) :: found if ( present ( val_ )) then val = val_ else val = 1 d0 end if if ( ST % empty ) then call ST % initiate ( size ( new_key )) end if if ( ST % key_len /= size ( new_key )) then call wc_error_stop ( 'statis.add' , 'key length not match!' ) end if found = . false . do i = 1 , ST % key_num if ( all ( ST % key (:, i ) == new_key )) then found = . true . ST % repeats ( i ) = ST % repeats ( i ) + 1 ST % val ( i ) = ST % val ( i ) + val exit end if end do if (. not . found ) then if ( ST % key_num == ST % max_key_num ) then !exceeds boundary call expand ( ST ) end if ST % key_num = ST % key_num + 1 ST % key (:, ST % key_num ) = new_key end if end subroutine real ( 8 ) function get_perc_sig ( ST , new_key ) implicit none class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: new_key get_perc_sig = ST % get_perc_ary ([ new_key ]) end function real ( 8 ) function get_perc_ary ( ST , new_key ) implicit none class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: new_key (:) integer :: i logical ( 1 ) :: found if ( ST % empty ) then get_perc_ary = 0 return end if if ( ST % key_len /= size ( new_key )) then call wc_error_stop ( 'statis.get' , 'key length not match!' ) end if found = . false . do i = 1 , ST % key_num if ( all ( ST % key (:, i ) == new_key )) then found = . true . exit end if end do if ( found ) then get_perc_ary = real ( ST % repeats ( i )) / sum ( ST % repeats (: ST % key_num )) else get_perc_ary = 0 end if end function real ( 8 ) function get_ave_val_sig ( ST , new_key ) implicit none class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: new_key get_ave_val_sig = ST % get_ave_val_ary ([ new_key ]) end function real ( 8 ) function get_ave_val_ary ( ST , new_key ) implicit none class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: new_key (:) integer :: i logical ( 1 ) :: found if ( ST % empty ) then get_ave_val_ary = 0 return end if if ( ST % key_len /= size ( new_key )) then call wc_error_stop ( 'statis.get' , 'key length not match!' ) end if found = . false . do i = 1 , ST % key_num if ( all ( ST % key (:, i ) == new_key )) then found = . true . exit end if end do if ( found ) then get_ave_val_ary = ST % val ( i ) / sum ( ST % val (: ST % key_num )) else get_ave_val_ary = 0 end if end function subroutine expand ( ST ) class ( statis ), intent ( inout ) :: ST integer , allocatable :: expand_temp (:), expand_temp1 (:,:) real ( 8 ), allocatable :: expand_temp2 (:) allocate ( expand_temp ( ST % key_num )) allocate ( expand_temp1 ( ST % key_len , ST % key_num )) allocate ( expand_temp2 ( ST % key_num )) expand_temp1 = ST % key deallocate ( ST % key ) allocate ( ST % key ( ST % key_len , 2 * ST % max_key_num )) ST % key = 0 ST % key (:, 1 : ST % max_key_num ) = expand_temp1 expand_temp = ST % repeats deallocate ( ST % repeats ) allocate ( ST % repeats ( 2 * ST % max_key_num )) ST % repeats = 0 ST % repeats ( 1 : ST % max_key_num ) = expand_temp expand_temp2 = ST % val deallocate ( ST % val ) allocate ( ST % val ( 2 * ST % max_key_num )) ST % val = 0 ST % val ( 1 : ST % max_key_num ) = expand_temp2 deallocate ( expand_temp ) deallocate ( expand_temp1 ) deallocate ( expand_temp2 ) ST % max_key_num = 2 * ST % max_key_num end subroutine subroutine sort_key ( ST ) class ( statis ), intent ( inout ) :: ST integer :: i , j , min_loc , temp2 integer , allocatable :: minkey (:), temp (:) real ( 8 ) :: temp3 if ( ST % empty ) then return end if allocate ( minkey ( ST % key_len )) allocate ( temp ( ST % key_len )) do i = 1 , ST % key_num - 1 minkey = ST % key (:, i ) min_loc = i do j = i + 1 , ST % key_num if ( lessthan ( ST % key (:, j ), minkey )) then minkey = ST % key (:, j ) min_loc = j end if end do if ( min_loc > i ) call swap ( ST , i , min_loc ) end do end subroutine subroutine sort_val ( ST ) class ( statis ), intent ( inout ) :: ST integer :: i , j , min_loc , temp2 integer , allocatable :: temp (:) real ( 8 ) :: minval , temp3 if ( ST % empty ) then return end if allocate ( temp ( ST % key_len )) do i = 1 , ST % key_num - 1 minval = ST % val ( i ) min_loc = i do j = i + 1 , ST % key_num if ( ST % val ( j ) < minval ) then minval = ST % val ( j ) min_loc = j end if end do if ( min_loc > i ) call swap ( ST , i , min_loc ) end do end subroutine subroutine swap ( ST , i , j ) class ( statis ), intent ( inout ) :: ST integer , intent ( in ) :: i , j integer :: temp2 real ( 8 ) :: temp3 integer , allocatable :: temp (:) temp = ST % key (:, i ) ST % key (:, i ) = ST % key (:, j ) ST % key (:, j ) = temp temp2 = ST % repeats ( i ) ST % repeats ( i ) = ST % repeats ( j ) ST % repeats ( j ) = temp2 temp3 = ST % val ( i ) ST % val ( i ) = ST % val ( j ) ST % val ( j ) = temp3 end subroutine logical function lessthan ( a , b ) integer , intent ( in ) :: a (:), b (:) integer :: i if ( size ( a ) /= size ( b )) then call wc_error_stop ( 'statistics.lessthan' , 'input arrays have different length' ) end if do i = 1 , size ( a ) if ( a ( i ) < b ( i )) then lessthan = . true . return else if ( a ( i ) > b ( i )) then lessthan = . false . return end if end do lessthan = . false . return end function subroutine show ( ST , sta_name ) class ( statis ), intent ( inout ) :: ST integer :: i , tot_rep real ( 8 ) :: tot_val character ( len =* ) :: sta_name if ( ST % empty ) then call writemess ( 'Statistics on ' // trim ( sta_name ) // ' : empty' ) end if tot_rep = sum ( ST % repeats ( 1 : ST % key_num )) tot_val = sum ( ST % val ( 1 : ST % key_num )) call writemess ( 'Statistics on ' // trim ( sta_name ) // ' :' ) do i = 1 , ST % key_num call writemess ( '   ' // trim ( sta_name ) // ' = ' // trim ( str ( ST % key (:, i )))& // ' : ' // trim ( str ( ST % val ( i ))) // ' ' // trim ( str ( ST % val ( i ) / tot_val ))) end do end subroutine subroutine show2 ( ST , sta_name ) class ( statis ), intent ( inout ) :: ST integer :: i , tot_rep character ( len =* ) :: sta_name real , allocatable :: ave_key (:) if ( ST % empty ) then call writemess ( 'Statistics on ' // trim ( sta_name ) // ' : empty' ) end if tot_rep = sum ( ST % repeats ( 1 : ST % key_num )) allocate ( ave_key ( ST % key_len )) do i = 1 , ST % key_len ave_key ( i ) = sum ( ST % key ( i ,: ST % key_num ) * ST % repeats (: ST % key_num )) / real ( tot_rep ) end do call writemess ( 'Statistics on ' // trim ( sta_name ) // ' :' ) do i = 1 , ST % key_num call writemess ( '   ' // trim ( sta_name ) // ' = ' // trim ( str ( ST % key (:, i ))) // ' :' // trim ( str ( real ( ST % repeats ( i )) / real ( tot_rep )))) end do call writemess ( 'Average ' // trim ( sta_name ) // ' is: ' // trim ( str ( ave_key ))) end subroutine subroutine clean ( ST ) class ( statis ), intent ( inout ) :: ST ST % key_num = 1 ST % empty = . true . if ( allocated ( ST % key )) deallocate ( ST % key ) if ( allocated ( ST % repeats )) deallocate ( ST % repeats ) if ( allocated ( ST % val )) deallocate ( ST % val ) end subroutine end module statistics ! vi:ai:noet:sw=4 ts=4 tw=77","tags":"","loc":"sourcefile/statistics.f90.html"},{"title":"random.f90 – TNSG","text":"This file depends on sourcefile~~random.f90~~EfferentGraph sourcefile~random.f90 random.f90 sourcefile~error.f90 error.f90 sourcefile~random.f90->sourcefile~error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~random.f90~~AfferentGraph sourcefile~random.f90 random.f90 sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~tensor_tools.f90->sourcefile~random.f90 sourcefile~cumulator.f90 cumulator.f90 sourcefile~cumulator.f90->sourcefile~tensor_tools.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_rand Source Code random.f90 Source Code module mod_rand use error implicit none private integer , parameter :: ia = 16807 integer , parameter :: im = 2147483647 integer , parameter :: iq = 127773 integer , parameter :: ir = 2836 integer , parameter :: ntab = 32 integer , parameter :: ndiv = 1 + ( im - 1 ) / ntab real ( 8 ), parameter :: am = 1. / im real ( 8 ), parameter :: rnmx = 1.0 - 1.2e-7 type randomer private integer :: seed integer :: this_seed integer :: state integer :: rand integer :: shuffle ( ntab ) = 0 logical :: first_tag = . true . contains private procedure , public :: check_uninited procedure , public :: clean procedure :: initialize1 procedure :: initialize2 generic , public :: initialize => initialize1 , initialize2 procedure , public :: randreal procedure , public :: randInteger procedure , public :: get_seed procedure , public :: get_subseed end type public randomer contains logical function check_uninited ( myrand ) class ( randomer ), intent ( inout ) :: myrand check_uninited = myrand % first_tag end function subroutine clean ( myrand ) class ( randomer ), intent ( inout ) :: myrand myrand % first_tag = . true . end subroutine subroutine initialize1 ( myrand , myseed , my_rank ) ! all procs has different random number class ( randomer ), intent ( inout ) :: myrand integer , intent ( in ) :: my_rank integer , intent ( in ) :: myseed integer :: counter integer :: seed , subseed , i type ( randomer ) :: seeder if (. not . myrand % first_tag ) then call wc_error_stop ( 'random.initialize' , 'random number generator has already been initialized' ) return end if if ( myseed == 0 ) then call system_clock ( counter ) seed = modulo ( counter , 1000000 ) + 1 else if ( myseed < 0 . or . myseed > 1000000 ) then call wc_error_stop ( 'random.initialize' , 'seed out of range' ) return end if seed = myseed end if call initialize2 ( seeder , seed ) do i = 0 , my_rank subseed = seeder % randInteger ( 1 , 1000000 ) end do myrand % seed = seed myrand % this_seed = subseed call prepare ( myrand ) myrand % first_tag = . false . end subroutine subroutine initialize2 ( myrand , myseed ) ! all procs has same random number class ( randomer ), intent ( inout ) :: myrand integer , intent ( in ) :: myseed integer ( 8 ) :: counter integer :: seed if (. not . myrand % first_tag ) then call wc_error_stop ( 'random.initialize' , 'random number generator has already been initialized' ) return end if if ( myseed == 0 ) then call system_clock ( counter ) seed = modulo ( counter , 1000000 ) + 1 else if ( myseed < 0 . or . myseed > 1000000 ) then call wc_error_stop ( 'random.initialize' , 'seed out of range' ) return end if seed = myseed end if myrand % seed = seed myrand % this_seed = seed call prepare ( myrand ) myrand % first_tag = . false . end subroutine subroutine prepare ( myrand ) ! generate shuffle class ( randomer ), intent ( inout ) :: myrand integer :: j myrand % state = myrand % this_seed do j = ntab + 8 , 1 , - 1 ! ignore first 8 rands call next_state ( myrand % state ) if ( j <= ntab ) myrand % shuffle ( j ) = myrand % state enddo myrand % rand = myrand % shuffle ( 1 ) end subroutine subroutine next_state ( state ) integer , intent ( inout ) :: state state = ia * mod ( state , iq ) - ir * ( state / iq ) if ( state < 0 ) state = state + im ! state = q * x + y ! new state = a * y - r * x end subroutine real ( 8 ) function randreal ( myrand ) class ( randomer ), intent ( inout ) :: myrand integer :: pos if ( myrand % first_tag ) then call wc_error_stop ( 'random.randreal' , 'random number generator has been used before initialized' ) randreal = 0 d0 return end if call next_state ( myrand % state ) pos = 1 + myrand % rand / ndiv myrand % rand = myrand % shuffle ( pos ) myrand % shuffle ( pos ) = myrand % state randreal = min ( am * myrand % rand , rnmx ) ! pos = last rand in 1 - div ! rand is shuffle(pos) ! shuffle(pos) is state end function integer function randInteger ( myrand , iMin , iMax ) class ( randomer ), intent ( inout ) :: myrand integer , intent ( in ) :: iMin , iMax if ( iMin > iMax ) then call wc_error_stop ( 'random.randInteger' , 'iMin should be smaller than iMax!' ) randInteger = 0 return end if randInteger = floor ( iMin + myrand % randreal () * ( iMax - iMin + 1 )) end function integer function get_seed ( myrand ) class ( randomer ), intent ( inout ) :: myrand get_seed = myrand % seed end function integer function get_subseed ( myrand ) class ( randomer ), intent ( inout ) :: myrand get_subseed = myrand % this_seed end function end module","tags":"","loc":"sourcefile/random.f90.html"},{"title":"paralist.f90 – TNSG","text":"This file depends on sourcefile~~paralist.f90~~EfferentGraph sourcefile~paralist.f90 paralist.f90 sourcefile~error.f90 error.f90 sourcefile~paralist.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~paralist.f90->sourcefile~string.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~paralist.f90->sourcefile~dictionary.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~string.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules parameter_list Source Code paralist.f90 Source Code module parameter_list use string use error use mod_dictionary implicit none private type , extends ( dictionary ) :: para_list private type ( dictionary ) :: dic_class contains private procedure , public :: read procedure , public :: print procedure :: print_class procedure , public :: subpara_name procedure , public :: subpara_class procedure , public :: clean procedure , public :: rename procedure , public :: setclass procedure :: pinsert_int , pinsert_real , pinsert_com , pinsert_char , pinsert_logi ,& pinsert_int_ary , pinsert_real_ary , pinsert_char_ary , pinsert_logi_ary generic , public :: pinsert => pinsert_int , pinsert_real , pinsert_com , pinsert_char , pinsert_logi ,& pinsert_int_ary , pinsert_real_ary , pinsert_char_ary , pinsert_logi_ary procedure , public :: delete procedure , public :: append_para end type public para_list contains subroutine clean ( D ) class ( para_list ), intent ( inout ) :: D call D % dictionary % clean () call D % dic_class % clean () end subroutine subroutine pinsert_int ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class integer , intent ( in ) :: value call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_int_ary ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class integer , intent ( in ) :: value (:) call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_real ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class real ( 8 ), intent ( in ) :: value call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_real_ary ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class real ( 8 ), intent ( in ) :: value (:) call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_com ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class complex ( 8 ), intent ( in ) :: value call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_char ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class character ( len =* ), intent ( in ) :: value call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_char_ary ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class character ( len =* ), intent ( in ) :: value (:) call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_logi ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class logical , intent ( in ) :: value call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine pinsert_logi_ary ( D , name , value , class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: class logical , intent ( in ) :: value (:) call D % dictionary % insert ( name , value ) if ( present ( class )) then call D % dic_class % insert ( name , class ) else call D % dic_class % insert ( name , 'none' ) end if end subroutine subroutine delete ( D , name ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name call D % dictionary % delete ( name ) call D % dic_class % delete ( name ) end subroutine subroutine rename ( D , name , new_name ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( inout ) :: new_name call D % dictionary % rename ( name , new_name ) call D % dic_class % rename ( name , new_name ) end subroutine subroutine setclass ( D , name , new_class ) class ( para_list ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( inout ) :: new_class call D % dic_class % setvalue ( name , new_class ) end subroutine function subpara_name ( D , names ) result ( out_list ) class ( para_list ), intent ( in ) :: D character ( len =* ), intent ( in ) :: names (:) type ( para_list ) :: out_list out_list % dictionary = D % dictionary % sub_name ( names ) out_list % dic_class = D % dic_class % sub_name ( names ) end function function subpara_class ( D , class ) result ( out_list ) class ( para_list ), intent ( in ) :: D character ( len =* ), intent ( in ) :: class type ( para_list ) :: out_list out_list % dic_class = D % dic_class % sub_val ( class ) out_list % dictionary = D % dictionary % sub_name ( out_list % dic_class % get_names ()) end function subroutine print ( D , unit , end_tag_ ) class ( para_list ), intent ( in ) :: D integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: end_tag_ logical :: end_tag character ( len = max_char_length ), allocatable :: finish_class (:) character ( len = max_char_length ), allocatable :: item_name (:) character ( len = max_char_length ) :: class_name integer :: i , j , finish_class_num logical :: none_tag end_tag = . true . if ( present ( end_tag_ )) end_tag = end_tag_ none_tag = . false . item_name = D % dic_class % get_names () allocate ( finish_class ( size ( item_name ))) finish_class = '' finish_class_num = 0 do i = 1 , size ( item_name ) class_name = D % dic_class % ai ( item_name ( i ) ) if (. not .( class_name == 'none' )) then if (. not . any ( finish_class (: finish_class_num ) == class_name )) then finish_class_num = finish_class_num + 1 finish_class ( finish_class_num ) = class_name call D % print_class ( class_name , unit ) end if else none_tag = . true . end if end do if ( none_tag ) call D % print_class ( 'none' , unit ) if ( present ( unit ) . and . end_tag ) write ( unit , * ) '/' end subroutine subroutine print_class ( D , class_name , unit ) class ( para_list ), intent ( in ) :: D type ( para_list ) :: sub_para character ( len =* ) :: class_name integer , intent ( in ), optional :: unit if ( present ( unit )) then write ( unit , * ) '# Class ' // trim ( class_name ) else call writemess ( '# Class ' // class_name ) end if sub_para = D % subpara_class ( class_name ) call sub_para % dictionary % print ( unit ,. false .) if ( present ( unit )) then write ( unit , * ) '#' write ( unit , * ) else call writemess ( '#' ) call writemess ( '' ) end if end subroutine subroutine read ( G , unit ) class ( para_list ), intent ( inout ) :: G integer , intent ( in ) :: unit character ( len = max_char_length ) :: cur_class character ( len = 10 * max_char_length ) :: line integer :: io_stat , len , pos , i logical :: class_on character ( len = max_char_length ) :: no_use , cur_name character ( len = 2 ) :: type integer :: ival real ( 8 ) :: dval complex ( 8 ) :: zval character ( len = max_char_length ) :: aval logical :: lval integer , allocatable :: mival (:) real ( 8 ), allocatable :: mdval (:) character ( len = max_char_length ), allocatable :: maval (:) logical , allocatable :: mlval (:) call G % clean () cur_class = 'none' class_on = . false . read ( unit , '(A)' , IOSTAT = io_stat ) line do while (. true .) if ( io_stat /= 0 ) then call wc_error_stop ( 'para_list.read' , 'EOF before identifier \"/\"' ) end if line = adjustl ( line ) type = '' if ( len_trim ( line ) > 0 ) then pos = scan ( line , ' ' // achar ( 9 )) ! achar(9) for tab type = line ( 1 : pos - 1 ) end if select case ( type ) case ( '#' ) if (. not . class_on ) then read ( line ( pos :), * ) no_use , cur_class class_on = . true . else cur_class = 'none' class_on = . false . end if case ( 'i' ) read ( line ( pos :), * ) cur_name , ival call G % pinsert ( cur_name , ival , cur_class ) case ( 'd' ) read ( line ( pos :), * ) cur_name , dval call G % pinsert ( cur_name , dval , cur_class ) case ( 'z' ) read ( line ( pos :), * ) cur_name , zval call G % pinsert ( cur_name , zval , cur_class ) case ( 'a' ) read ( line ( pos :), * ) cur_name , aval call G % pinsert ( cur_name , aval , cur_class ) case ( 'l' ) read ( line ( pos :), * ) cur_name , lval call G % pinsert ( cur_name , lval , cur_class ) case ( 'mi' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( mival )) deallocate ( mival ) allocate ( mival ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) mival ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'para_list.read' , 'array reading stopped' ) end do call G % pinsert ( cur_name , mival , cur_class ) case ( 'md' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( mdval )) deallocate ( mdval ) allocate ( mdval ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) mdval ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'para_list.read' , 'array reading stopped' ) end do call G % pinsert ( cur_name , mdval , cur_class ) case ( 'ma' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( maval )) deallocate ( maval ) allocate ( maval ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) maval ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'para_list.read' , 'array reading stopped' ) end do call G % pinsert ( cur_name , maval , cur_class ) case ( 'ml' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( mlval )) deallocate ( mlval ) allocate ( mlval ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) mlval ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'para_list.read' , 'array reading stopped' ) end do call G % pinsert ( cur_name , mlval , cur_class ) case ( '/' ) exit end select read ( unit , '(A)' , IOSTAT = io_stat ) line end do end subroutine subroutine append_para ( P1 , P2 ) class ( para_list ), intent ( inout ) :: P1 class ( para_list ), intent ( in ) :: P2 call P1 % dictionary % append ( P2 % dictionary ) call P1 % dic_class % append ( P2 % dic_class ) end subroutine end module","tags":"","loc":"sourcefile/paralist.f90.html"},{"title":"error.f90 – TNSG","text":"This file depends on sourcefile~~error.f90~~EfferentGraph sourcefile~error.f90 error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~error.f90~~AfferentGraph sourcefile~error.f90 error.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~percentage.f90 percentage.f90 sourcefile~percentage.f90->sourcefile~error.f90 sourcefile~random.f90 random.f90 sourcefile~random.f90->sourcefile~error.f90 sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~tensor_tools.f90->sourcefile~error.f90 sourcefile~tensor_tools.f90->sourcefile~random.f90 sourcefile~tensor_tools.f90->sourcefile~string.f90 sourcefile~timer.f90 timer.f90 sourcefile~timer.f90->sourcefile~error.f90 sourcefile~timer.f90->sourcefile~string.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~timer.f90->sourcefile~unidic.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~tn_tensor.f90->sourcefile~error.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~error.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~string.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~stack.f90 stack.f90 sourcefile~stack.f90->sourcefile~error.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~statistics.f90 statistics.f90 sourcefile~statistics.f90->sourcefile~error.f90 sourcefile~statistics.f90->sourcefile~string.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~paralist.f90 paralist.f90 sourcefile~paralist.f90->sourcefile~error.f90 sourcefile~paralist.f90->sourcefile~dictionary.f90 sourcefile~paralist.f90->sourcefile~string.f90 sourcefile~cumulator.f90 cumulator.f90 sourcefile~cumulator.f90->sourcefile~error.f90 sourcefile~cumulator.f90->sourcefile~tensor_tools.f90 sourcefile~lattice.f90->sourcefile~error.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~lattice.f90->sourcefile~string.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~date_time.f90 date_time.f90 sourcefile~date_time.f90->sourcefile~string.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules error Source Code error.f90 Source Code module error use tools ! writemess use mod_mpi_info implicit none logical :: test_tag = . false . interface wc_error_stop module procedure wc_error_stop_mess2 module procedure wc_error_stop_mess1 module procedure wc_error_stop_nomess end interface contains subroutine error_test_tag ( tag ) logical , intent ( in ) :: tag test_tag = tag end subroutine subroutine wc_error_stop_mess2 ( error_pos , error_mess ) character ( len =* ), intent ( in ) :: error_pos , error_mess integer :: ierr call writemess ( 'In ' // trim ( error_pos ) // ':' ) call writemess ( error_mess ) call wc_outpicture () if (. not . test_tag ) then if ( nproc > 1 ) call MPI_Finalize ( ierr ) stop end if end subroutine subroutine wc_error_stop_mess1 ( error_mess ) character ( len =* ), intent ( in ) :: error_mess integer :: ierr call writemess ( error_mess ) call wc_outpicture () if (. not . test_tag ) then if ( nproc > 1 ) call MPI_Finalize ( ierr ) stop end if end subroutine subroutine wc_error_stop_nomess () integer :: ierr call wc_outpicture () if (. not . test_tag ) then if ( nproc > 1 ) call MPI_Finalize ( ierr ) stop end if end subroutine subroutine wc_outpicture () integer :: pic call system_clock ( pic ) ! millisecond select case ( modulo ( pic , 7 ) + 1 ) case ( 1 ) call writemess ( '                                                 ' ) call writemess ( '      __                                         ' ) call writemess ( '     #####                    ###                ' ) call writemess ( '    #########___---------____#####               ' ) call writemess ( '    ########                 #####               ' ) call writemess ( '     ######                   ###                ' ) call writemess ( '      ####                     ##                ' ) call writemess ( '       ##                       \\     ________________________________   ' ) call writemess ( '       /        ##       ##      |   |you have bugs!!                 |  ' ) call writemess ( '       |       #0#       #0#      |  |Report ONLY bugs of the package |  ' ) call writemess ( '       |      ###         ###     |  /to wang1329@mail.ustc.edu.cn !  |  ' ) call writemess ( '       |      #            ##     | /_________________________________|  ' ) call writemess ( '       |             ####         |              ' ) call writemess ( '      /\\         \\    ##   /     /               ' ) call writemess ( '     /  \\         \\_______/     /                ' ) call writemess ( '    ###  \\              \\\\     ##                ' ) call writemess ( '   ######################\\\\########              ' ) call writemess ( ' #########################\\\\########             ' ) call writemess ( '                           \\\\                    ' ) call writemess ( '                                                 ' ) case ( 2 ) call writemess ( '                                                ' ) call writemess ( '                      ________                  ' ) call writemess ( '                    _/__|__|__\\_                ' ) call writemess ( '                   /     _      \\               ' ) call writemess ( '                  /_   _(_)_   __\\              ' ) call writemess ( '                 ||_| |____o| |_|_|             ' ) call writemess ( '             ____|================|___          ' ) call writemess ( '            |    |   __________   |   \\         ' ) call writemess ( '            |    |  | WARNING! |  |    \\        ' ) call writemess ( '            |   ||  | you      |  |\\    \\       ' ) call writemess ( '            |   ||  |  have    |  | \\    \\      ' ) call writemess ( '            |   ||  |    bugs  |  |  \\    \\     ' ) call writemess ( '            |   ||  |__________|  |   \\    \\    ' ) call writemess ( '            |   ||                |    \\____\\   ' ) call writemess ( '            |   ||________________|      | \\    ' ) call writemess ( '            |___|      \\     /           |  \\   ' ) call writemess ( '             / \\        \\___/            |___\\  ' ) call writemess ( '            /   \\       /   \\                   ' ) call writemess ( '           /_____\\     /_____\\                  ' ) call writemess ( '_____________________________________________________________ ' ) call writemess ( '|Report ONLY bugs of the package to wang1329@mail.ustc.edu.cn|' ) call writemess ( '`~----------------------------------------------------------~`' ) case ( 3 ) call writemess ( '                                  ' ) call writemess ( '                    |_|           ' ) call writemess ( '                  _P   P_         ' ) call writemess ( '           \\___  /  \\|/  \\  ___/  ' ) call writemess ( '               \\/    |    \\/      ' ) call writemess ( '                |  0 |   0|       ' ) call writemess ( '             __/| 000|  00|\\__    ' ) call writemess ( '            /   \\  00|    /   \\   ' ) call writemess ( '              __/\\___|___/\\__     ' ) call writemess ( '             /               \\    ' ) call writemess ( ' _______________                  ' ) call writemess ( '|you have bugs! |____________________________________________ ' ) call writemess ( '|Report ONLY bugs of the package to wang1329@mail.ustc.edu.cn|' ) call writemess ( '`~----------------------------------------------------------~`' ) case ( 4 ) call writemess ( '                                          ' ) call writemess ( '                ______                    ' ) call writemess ( '               /__    \\                   ' ) call writemess ( '              /\\_/     \\                  ' ) call writemess ( '            _/__       |                  ' ) call writemess ( '           / \\_/       |                  ' ) call writemess ( '      _____|_____      |               ________________________________ ' ) call writemess ( '     |   |   |   |     |              |you have bugs!!                 |' ) call writemess ( '     |   |   |   |     |              |Report ONLY bugs of the package |' ) call writemess ( '     |   |   |   |     /              |to wang1329@mail.ustc.edu.cn !  |' ) call writemess ( '     |___|___|___|_   /              /`-------------------------------- ' ) call writemess ( '    /  _  _   _    \\_/             ()     ' ) call writemess ( '    | | || |.| | | |            --/|_/    ' ) call writemess ( '    | |_||_|.|_| | |            --\\/      ' ) call writemess ( '    \\______________/            --/-\\     ' ) call writemess ( '     |   |   |   |               /  /     ' ) call writemess ( '     |   |   |   |                        ' ) call writemess ( '     |   |   |   |                        ' ) call writemess ( '     |   |   |   |                        ' ) call writemess ( '     |   |   |   |                        ' ) call writemess ( '     |___|___|___|                        ' ) call writemess ( '                                          ' ) case ( 5 ) call writemess ( '                                       ' ) call writemess ( '      _______ _______________          ' ) call writemess ( '     |       |_     _|       |         ' ) call writemess ( '     |        _| _ |_        |         ' ) call writemess ( '     |__   __|__| |__|__   __|         ' ) call writemess ( '     |  |_| _|       |_ |_|  |        _      ' ) call writemess ( '     |   _ |_         _| _   |     __| |__   ' ) call writemess ( '     |__| |__|__   __|__| |__|   _|      _|  ' ) call writemess ( '     |      _|  |_| _|       |  |_      |_   ' ) call writemess ( '     |     |_      |_        |    |_______|  ' ) call writemess ( '     |_______|       |_______|               ' ) call writemess ( '                                       ' ) call writemess ( ' _______________                       ' ) call writemess ( '|you have bugs! |____________________________________________ ' ) call writemess ( '|Report ONLY bugs of the package to wang1329@mail.ustc.edu.cn|' ) call writemess ( '`~----------------------------------------------------------~`' ) case ( 6 ) call writemess ( '                                                             ' ) call writemess ( '       ___    ___    ___    ___    ___    ___                ' ) call writemess ( '      |___|--|___|--|___|--|___|--|___|--|___|               ' ) call writemess ( '        |      |      |      |      |      |                 ' ) call writemess ( '       _|_    _|_    _|_           _|_    _|_    _|_         ' ) call writemess ( '      |___|--|___|--|___|---------|___|--|___|--|___|        ' ) call writemess ( '                                                             ' ) call writemess ( ' _______________                                              ' ) call writemess ( '|you have bugs! |____________________________________________ ' ) call writemess ( '|Report ONLY bugs of the package to wang1329@mail.ustc.edu.cn|' ) call writemess ( '`~----------------------------------------------------------~`' ) case ( 7 ) call writemess ( '                                               ' ) call writemess ( '          ____             ____                ' ) call writemess ( '         /  \\ \\           / /  \\               ' ) call writemess ( '        |###\\| \\         / |/###|              ' ) call writemess ( '        |###//  \\_______/  \\\\###|              ' ) call writemess ( '         \\__/               \\__/               ' ) call writemess ( '         |                     |        ________________________________   ' ) call writemess ( '         \\_____________________/       |you have bugs !!                |  ' ) call writemess ( '        / \\                   / \\      |Report ONLY bugs of the package |  ' ) call writemess ( '       /   \\                 /   \\     /to wang1329@mail.ustc.edu.cn !  |  ' ) call writemess ( '      /     \\               /     \\   /_________________________________|  ' ) call writemess ( '                                                 ' ) end select end subroutine end module error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"stack.f90 – TNSG","text":"This file depends on sourcefile~~stack.f90~~EfferentGraph sourcefile~stack.f90 stack.f90 sourcefile~error.f90 error.f90 sourcefile~stack.f90->sourcefile~error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~stack.f90~~AfferentGraph sourcefile~stack.f90 stack.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~timer.f90 timer.f90 sourcefile~timer.f90->sourcefile~unidic.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_stack Source Code stack.f90 Source Code module mod_stack use error implicit none private type node type ( node ), pointer :: previous integer :: val end type type stack private integer :: stack_num = 0 type ( node ), pointer :: last => null () contains procedure , public :: push procedure , public :: pop procedure , public :: top procedure , public :: num procedure , public :: clean procedure , public :: read procedure , public :: write procedure :: real_length procedure , public :: consistent procedure , public :: items ! public only for test, don't use procedure :: copy generic , public :: assignment ( = ) => copy procedure :: compare generic , public :: operator ( == ) => compare end type public stack contains subroutine push ( S , val ) class ( stack ) :: S integer , intent ( in ) :: val type ( node ), pointer :: new S % stack_num = S % stack_num + 1 allocate ( new ) new % val = val new % previous => S % last S % last => new end subroutine function pop ( S ) result ( res ) class ( stack ) :: S integer :: res type ( node ), pointer :: old if ( S % stack_num == 0 ) then res =- 1 call wc_error_stop ( 'stack.pop' , 'stack is empty' ) else S % stack_num = S % stack_num - 1 res = S % last % val old => S % last S % last => old % previous deallocate ( old ) end if end function function top ( S ) result ( res ) class ( stack ) :: S integer :: res if ( S % stack_num == 0 ) then res =- 1 call wc_error_stop ( 'stack.pop' , 'stack is empty' ) else res = S % last % val end if end function function num ( S ) result ( res ) class ( stack ) :: S integer :: res res = S % stack_num end function subroutine clean ( S ) class ( stack ) :: S type ( node ), pointer :: old do while ( S % stack_num > 0 ) S % stack_num = S % stack_num - 1 old => S % last S % last => old % previous deallocate ( old ) end do end subroutine subroutine write ( S , unit ) class ( stack ) :: S integer , intent ( in ) :: unit write ( unit , * ) S % stack_num if ( S % stack_num > 0 ) write ( unit , * ) S % items () end subroutine subroutine read ( S , unit ) class ( stack ) :: S integer , intent ( in ) :: unit integer :: i , num integer , allocatable :: vals (:) call S % clean read ( unit , * ) num if ( num > 0 ) then allocate ( vals ( num )) read ( unit , * ) vals do i = 1 , num call S % push ( vals ( i )) end do end if end subroutine subroutine copy ( Sout , Sin ) class ( stack ), intent ( inout ) :: Sout class ( stack ), intent ( in ) :: Sin integer :: i , num integer , allocatable :: inverse (:) type ( node ), pointer :: pnode num = Sin % stack_num allocate ( inverse ( num )) pnode => Sin % last do i = 1 , num inverse ( i ) = pnode % val pnode => pnode % previous end do call Sout % clean do i = num , 1 , - 1 call Sout % push ( inverse ( i )) end do end subroutine function compare ( S1 , S2 ) result ( res ) class ( stack ), intent ( in ) :: S1 , S2 logical :: res res = S1 % consistent () . and . S2 % consistent () . and . ( S1 % stack_num == S2 % stack_num ) if ( res ) res = res . and . all ( S1 % items () == S2 % items ()) end function function real_length ( S ) result ( res ) class ( stack ), intent ( in ) :: S integer :: res type ( node ), pointer :: pnode res = 0 pnode => S % last do while ( associated ( pnode )) res = res + 1 pnode => pnode % previous end do end function function consistent ( S ) result ( res ) class ( stack ), intent ( in ) :: S logical :: res res = ( S % stack_num == S % real_length ()) end function function items ( S ) result ( res ) class ( stack ), intent ( in ) :: S integer , allocatable :: res (:) integer :: i , num type ( node ), pointer :: pnode num = S % real_length () allocate ( res ( num )) pnode => S % last do i = num , 1 , - 1 res ( i ) = pnode % val pnode => pnode % previous end do end function end module","tags":"","loc":"sourcefile/stack.f90.html"},{"title":"string.f90 – TNSG","text":"This file depends on sourcefile~~string.f90~~EfferentGraph sourcefile~string.f90 string.f90 sourcefile~error.f90 error.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~string.f90~~AfferentGraph sourcefile~string.f90 string.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~date_time.f90 date_time.f90 sourcefile~date_time.f90->sourcefile~string.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~lattice.f90->sourcefile~string.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~tensor_tools.f90->sourcefile~string.f90 sourcefile~timer.f90 timer.f90 sourcefile~timer.f90->sourcefile~string.f90 sourcefile~timer.f90->sourcefile~unidic.f90 sourcefile~statistics.f90 statistics.f90 sourcefile~statistics.f90->sourcefile~string.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~paralist.f90 paralist.f90 sourcefile~paralist.f90->sourcefile~string.f90 sourcefile~paralist.f90->sourcefile~dictionary.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~string.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~cumulator.f90 cumulator.f90 sourcefile~cumulator.f90->sourcefile~tensor_tools.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules string Source Code string.f90 Source Code module string use error implicit none private integer , parameter :: max_char_length = 500 interface str module procedure int2str module procedure int_ary2str module procedure flt2str module procedure flt_ary2str module procedure dbl2str module procedure dbl_ary2str module procedure com2str module procedure com_ary2str module procedure dcom2str module procedure dcom_ary2str module procedure logi2str module procedure logi_ary2str module procedure str_ary2str end interface interface operator ( // ) module procedure concat end interface public max_char_length , str , operator ( // ), after_dot , before_dot , str_before , str_after contains function concat ( st1 , st2 ) result ( str ) character (:), allocatable :: str class ( * ), intent ( in ) :: st1 , st2 str = str_var ( st1 ) // str_var ( st2 ) end function function str_var ( num ) result ( res ) character (:), allocatable :: res class ( * ), intent ( in ) :: num select type ( num ) type is ( integer ) res = str ( num ) type is ( real ( 4 )) res = str ( num ) type is ( real ( 8 )) res = str ( num ) type is ( complex ( 4 )) res = str ( num ) type is ( complex ( 8 )) res = str ( num ) type is ( character ( len =* )) res = num type is ( logical ) res = str ( num ) class default call wc_error_stop ( 'string.str_var' , 'input type not supported' ) end select end function function after_dot ( str ) result ( res ) character (:), allocatable :: res character ( len =* ), intent ( in ) :: str integer :: pos pos = scan ( str , '.' ) res = str ( pos + 1 : len ( str )) end function function before_dot ( str ) result ( res ) character (:), allocatable :: res character ( len =* ), intent ( in ) :: str integer :: pos pos = scan ( str , '.' ) res = str ( 1 : pos - 1 ) end function function str_before ( str , ch ) result ( res ) character (:), allocatable :: res character ( len =* ), intent ( in ) :: str character ( len = 1 ), intent ( in ) :: ch integer :: pos pos = scan ( str , ch ) res = str ( 1 : pos - 1 ) end function function str_after ( str , ch ) result ( res ) character (:), allocatable :: res character ( len =* ), intent ( in ) :: str character ( len = 1 ), intent ( in ) :: ch integer :: pos pos = scan ( str , ch ) res = str ( pos + 1 : len ( str )) end function ! 1 elem function flt2str ( num , digit ) result ( str ) character (:), allocatable :: str real ( 4 ), intent ( in ) :: num integer , intent ( in ), optional :: digit str = dbl2str ( dble ( num ), digit ) end function function dbl2str ( num , digit_ ) result ( str2 ) character (:), allocatable :: str2 character ( len = 25 ) :: str real ( 8 ), intent ( in ) :: num integer , intent ( in ), optional :: digit_ real ( 8 ) :: abs_num , num_int integer :: appro , tenexp , tenexp2 , lenint , zero_num , digit integer ( 1 ) :: temp ( 20 ), i , j , dotpos , st , len_not0 real ( 8 ) :: compare ( 8 ) = [ 1 d - 2 , 1 d - 1 , 1 d0 , 1 d1 , 1 d2 , 1 d3 , 1 d4 , 1 d5 ] temp = 0 if ( present ( digit_ )) then digit = digit_ if ( digit < 1 . or . digit > 13 ) call wc_error_stop ( 'string.dbl2str' , 'digit=' // int2str ( digit ) // ', not in [1,13].' ) else digit = 7 end if if ( num > 0 d0 ) then abs_num = num str = '' st = 0 else if ( num < 0 d0 ) then abs_num =- num str = '-' st = 1 else str2 = '0' if ( digit > 1 ) then str2 ( 2 : 2 ) = '.' do i = 1 , digit - 1 str2 ( i + 2 : i + 2 ) = '0' end do end if return end if if ( abs_num > compare ( size ( compare )) * ( 1 - 5.1d-7 ) . or . abs_num < compare ( 1 ) * ( 1 - 5.1d-7 )) then tenexp = 0 if ( abs_num > 1 - 5.1d-7 ) then do while ( abs_num >= 10 - 5.1d-6 ) tenexp = tenexp + 1 abs_num = abs_num / 10 end do else if ( abs_num < 1 - 5.1d-7 ) then do while ( abs_num < 1 - 5.1d-7 ) tenexp = tenexp - 1 abs_num = abs_num * 10 end do end if !now 1 - 5.1d-7<=abs_num<10 - 5.1d-6 num_int = abs_num do i = 1 , digit - 1 num_int = num_int * 10 end do appro = nint ( num_int ) do i = 1 , digit temp ( i ) = mod ( appro , 10 ) appro = appro / 10 end do str ( st + 1 : st + 1 ) = char ( temp ( digit ) + 48 ) st = st + 1 str ( st + 1 : st + 1 ) = '.' do j = 2 , digit str ( st + j : st + j ) = char ( temp ( digit + 1 - j ) + 48 ) end do st = st + digit str ( st + 1 : st + 1 ) = 'E' str ( st + 2 :) = int2str ( tenexp ) else dotpos = count ( abs_num > ( compare * ( 1 - 5.1d-7 ))) abs_num = abs_num / compare ( dotpos ) num_int = abs_num do i = 1 , digit - 1 num_int = num_int * 10 end do appro = nint ( num_int ) dotpos = dotpos - count ( 0.9 > compare ) !now 1<=abs_num<10 !dotpos is how many digits before dot, = 0 if 0.1-1 do i = 1 , digit temp ( i ) = mod ( appro , 10 ) appro = appro / 10 end do if ( dotpos <= 0 ) then str ( st + 1 : st + 2 ) = '0.' if ( dotpos < 0 ) str ( st + 3 : st + 2 - dotpos ) = repeat ( '0' , - dotpos ) st = st + 2 - dotpos do j = 1 , digit str ( st + j : st + j ) = char ( temp ( digit + 1 - j ) + 48 ) end do else do j = 1 , dotpos str ( st + j : st + j ) = char ( temp ( digit + 1 - j ) + 48 ) end do if ( digit > dotpos ) then do j = 1 , dotpos str ( st + j : st + j ) = char ( temp ( digit + 1 - j ) + 48 ) end do str ( st + dotpos + 1 : st + dotpos + 1 ) = '.' do j = dotpos + 1 , digit str ( st + j + 1 : st + j + 1 ) = char ( temp ( digit + 1 - j ) + 48 ) end do else do j = 1 , digit str ( st + j : st + j ) = char ( temp ( digit + 1 - j ) + 48 ) end do str ( st + digit + 1 : st + dotpos ) = repeat ( '0' , dotpos - digit ) end if end if end if str2 = str (: len_trim ( str )) end function function int2str ( inte ) result ( str ) character (:), allocatable :: str integer , intent ( in ) :: inte integer :: temp2 , length integer ( 1 ) :: temp ( 20 ), i if ( inte == 0 ) then str = '0' return else if ( inte > 0 ) then temp2 = inte length = 0 do while ( temp2 > 0 ) length = length + 1 temp ( length ) = mod ( temp2 , 10 ) temp2 = temp2 / 10 end do allocate ( character ( length ) :: str ) do i = 1 , length str ( i : i ) = char ( temp ( length + 1 - i ) + 48 ) end do else temp2 =- inte length = 0 do while ( temp2 > 0 ) length = length + 1 temp ( length ) = mod ( temp2 , 10 ) temp2 = temp2 / 10 end do allocate ( character ( length + 1 ) :: str ) str ( 1 : 1 ) = '-' do i = 1 , length str ( i + 1 : i + 1 ) = char ( temp ( length + 1 - i ) + 48 ) end do end if end function function com2str ( num , digit ) result ( str ) complex , intent ( in ) :: num character (:), allocatable :: str integer , intent ( in ), optional :: digit str = dcom2str ( dcmplx ( num ), digit ) end function function dcom2str ( num , digit ) result ( str ) character (:), allocatable :: str complex ( 8 ), intent ( in ) :: num integer , intent ( in ), optional :: digit if ( aimag ( num ) >= 0 ) then str = dbl2str ( real ( num ), digit ) // '+' // dbl2str ( aimag ( num ), digit ) // 'i' else if ( aimag ( num ) <= 0 ) then str = dbl2str ( real ( num ), digit ) // '-' // dbl2str ( - aimag ( num ), digit ) // 'i' else str = dbl2str ( real ( num ), digit ) end if end function function logi2str ( num ) result ( str ) character (:), allocatable :: str logical , intent ( in ) :: num if ( num ) then str = 'T' else str = 'F' end if end function !array function int_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str character ( len = 1 ), intent ( in ), optional :: split integer , intent ( in ) :: nums (:) integer :: i , st , length if ( size ( nums ) == 0 ) then str2 = '' return end if str = int2str ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // int2str ( nums ( i )) else str = trim ( str ) // ', ' // int2str ( nums ( i )) end if end do str2 = trim ( str ) end function function flt_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str character ( len = 1 ), intent ( in ), optional :: split real ( 4 ), intent ( in ) :: nums (:) integer :: i , st if ( size ( nums ) == 0 ) then str2 = '' return end if str = flt2str ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // flt2str ( nums ( i )) else str = trim ( str ) // ', ' // flt2str ( nums ( i )) end if end do str2 = trim ( str ) end function function dbl_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str character ( len = 1 ), intent ( in ), optional :: split real ( 8 ), intent ( in ) :: nums (:) integer :: i , st if ( size ( nums ) == 0 ) then str2 = '' return end if str = dbl2str ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // dbl2str ( nums ( i )) else str = trim ( str ) // ', ' // dbl2str ( nums ( i )) end if end do str2 = trim ( str ) end function function com_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str complex ( 4 ), intent ( in ) :: nums (:) character ( len =* ), intent ( in ), optional :: split integer :: i if ( size ( nums ) == 0 ) then str2 = '' return end if str = com2str ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // com2str ( nums ( i )) else str = trim ( str ) // ', ' // com2str ( nums ( i )) end if end do str2 = trim ( str ) end function function dcom_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str complex ( 8 ), intent ( in ) :: nums (:) character ( len =* ), intent ( in ), optional :: split integer :: i if ( size ( nums ) == 0 ) then str2 = '' return end if str = dcom2str ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // dcom2str ( nums ( i )) else str = trim ( str ) // ', ' // dcom2str ( nums ( i )) end if end do str2 = trim ( str ) end function function logi_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str logical , intent ( in ) :: nums (:) character ( len =* ), intent ( in ), optional :: split integer :: i , st if ( size ( nums ) == 0 ) then str2 = '' return end if str = logi2str ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // logi2str ( nums ( i )) else str = trim ( str ) // ', ' // logi2str ( nums ( i )) end if end do str2 = trim ( str ) end function function str_ary2str ( nums , split ) result ( str2 ) character (:), allocatable :: str2 character ( len = max_char_length ) :: str character ( len =* ), intent ( in ) :: nums (:) character ( len = 1 ), intent ( in ), optional :: split integer :: i if ( size ( nums ) == 0 ) then str2 = '' return end if str = trim ( nums ( 1 )) do i = 2 , size ( nums ) if ( present ( split )) then str = trim ( str ) // split // trim ( nums ( i )) else str = trim ( str ) // ', ' // trim ( nums ( i )) end if end do str2 = trim ( str ) end function end module string","tags":"","loc":"sourcefile/string.f90.html"},{"title":"tensor_tools.f90 – TNSG","text":"This file depends on sourcefile~~tensor_tools.f90~~EfferentGraph sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~random.f90 random.f90 sourcefile~tensor_tools.f90->sourcefile~random.f90 sourcefile~error.f90 error.f90 sourcefile~tensor_tools.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~tensor_tools.f90->sourcefile~string.f90 sourcefile~random.f90->sourcefile~error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~tensor_tools.f90~~AfferentGraph sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~cumulator.f90 cumulator.f90 sourcefile~cumulator.f90->sourcefile~tensor_tools.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tnsp_ext Source Code tensor_tools.f90 Source Code module tnsp_ext use tensor_type use tools use string use error use mpi use mod_rand implicit none type tnary type ( Tensor ) :: tn type ( Tensor ), allocatable :: tns (:,:) end type contains subroutine kill_D1_ind ( T ) type ( tensor ), intent ( inout ) :: T integer :: rank , i rank = T % getrank () do i = rank , 1 , - 1 if ( T % dim ( i ) == 1 ) then call T % backward ( i ) T = T % subtensor ([ - 2 , 1 ]) end if end do end subroutine subroutine permute_as ( T , P ) type ( tensor ), intent ( in ) :: P type ( tensor ), intent ( inout ) :: T type ( tensor ) :: name name = P % getname () call T % permute ( name % ai ()) end subroutine subroutine print_data ( T , unit , fmt ) type ( tensor ), intent ( inout ) :: T integer , intent ( in ) :: unit logical , intent ( in ) :: fmt real ( 8 ), pointer :: ddata (:) complex ( 8 ), pointer :: zdata (:) select case ( T % gettype ()) case ( 3 ) call T % pointer ( ddata ) if ( fmt ) then write ( unit , * ) ddata else write ( unit ) ddata end if case ( 5 ) call T % pointer ( zdata ) if ( fmt ) then write ( unit , * ) zdata else write ( unit ) zdata end if end select end subroutine subroutine HOSVD ( T , uni , env , cen , names , Dc ) character ( len =* ), intent ( in ) :: names (:) type ( tensor ), intent ( inout ) :: T , cen , uni (:), env (:) integer , intent ( in ), optional :: Dc type ( tensor ) :: useless , invten , invenv , env_temp , test character ( len = max_char_length ), allocatable :: name_bac (:) integer :: i , j , rank , dim_env rank = T % getrank () allocate ( name_bac ( rank )) name_bac = '' do i = 1 , size ( names ) do j = 1 , rank if ( T % outTensorName ( j ) /= names ( i )) then name_bac ( j ) = T % outName ( j ) call T % setname ( j , 'temp&#94;_&#94;.' + j ) end if end do call T % SVDroutine ( uni ( i ), env_temp , useless , names ( i ), 'temp&#94;_&#94;' , Dc ) env ( i ) = eye ( env_temp ) call uni ( i )% setname ( uni ( i )% getrank (), names ( i ) + '.hosvd' ) call env ( i )% setname ( 1 , 'env.in' ) call env ( i )% setname ( 2 , 'env.out' ) do j = 1 , rank if ( len_trim ( name_bac ( j )) /= 0 ) then call T % setname ( 'temp&#94;_&#94;.' + j , name_bac ( j )) name_bac ( j ) = '' end if end do end do cen = T do i = 1 , size ( names ) invten = . con . uni ( i ) invenv = env ( i ) dim_env = invenv . dim . 1 do j = 1 , dim_env call invenv % setvalue ([ j , j ], 1 / invenv % di ([ j , j ])) end do invten = contract ( invten , names ( i ) + '.hosvd' , invenv , 'env.in' ) call invten % setname ( 'env.out' , 'center.hosvd' + i ) cen = contract ( cen , invten ) env ( i ) = env ( i ) end do end subroutine function dbl ( T ) result ( res ) class ( tensor ), intent ( in ) :: T real ( 8 ) :: res res = T end function subroutine cre_ann_number ( A , A_dg , N , N2 , D ) ! generate (bosonic) creation & annhilation & number operators ! N2=N*(N-1), leg: 1 in 2 out, partical number range is 0~D-1 type ( Tensor ), intent ( out ) :: A , A_dg , N , N2 integer , intent ( in ) :: D integer :: i call A % allocate ([ D , D ], 'real*8' ) call A % setvalue ( 0 d0 ) call A_dg % allocate ([ D , D ], 'real*8' ) call A_dg % setvalue ( 0 d0 ) call N % allocate ([ D , D ], 'real*8' ) call N % setvalue ( 0 d0 ) call N2 % allocate ([ D , D ], 'real*8' ) call N2 % setvalue ( 0 d0 ) do i = 1 , D - 1 call A % setvalue ([ i , i + 1 ], sqrt ( real ( i ))) end do do i = 1 , D call N % setvalue ([ i , i ], i - 1 ) call N2 % setvalue ([ i , i ],( i - 1 ) * ( i - 2 )) end do A_dg = transpose ( A ) end subroutine cre_ann_number subroutine spin_matrix ( sx , sy , sz , s ) ! generate standard matrices (as in book by H. Georgi) of s_i ! of a spin-s representation. s is an int or a half-int. ! row/column = 1 ... 2s+1 means m = -s ... s type ( Tensor ), intent ( inout ) :: sx , sy , sz real ( 8 ), intent ( in ) :: s real ( 8 ), allocatable :: sp (:,:) !s+ = sx + isy ; s- = sx - isy; sx = (s+ + s-)/2; sy = (-s+ + s-)/2*i integer :: i , D D = floor ( 2 * s + 1.01 ) call sx % allocate ([ D , D ], 'real*8' ) call sx % setvalue ( 0 d0 ) call sy % allocate ([ D , D ], 'complex*16' ) call sy % setvalue ( 0 d0 ) call sz % allocate ([ D , D ], 'real*8' ) call sz % setvalue ( 0 d0 ) allocate ( sp ( D , D )) sp = 0 do i = 1 , D - 1 !m=-s+i-1 sp ( i + 1 , i ) = sqrt ( real ( i * ( 2 * s + 1 - i ))) !sp(m+1,m)=sqrt((s+m+1)*(s-m)) end do sx = ( sp + transpose ( sp )) / 2 sy = ( - sp + transpose ( sp )) / 2 * dcmplx ( 0 , 1 ) do i = 1 , D call sz % setvalue ([ i , i ], - s + i - 1 ) end do deallocate ( sp ) end subroutine spin_matrix subroutine spin_matrix2 ( sx , sy , sz , sp , sm , s ) ! generate standard matrices (as in book by H. Georgi) of s_i ! of a spin-s representation. s is an int or a half-int. ! row/column = 1 ... 2s+1 means m = -s ... s type ( Tensor ), intent ( inout ) :: sx , sy , sz , sp , sm real ( 8 ), intent ( in ) :: s real ( 8 ), allocatable :: spm (:,:) !s+ = sx + isy ; s- = sx - isy; sx = (s+ + s-)/2; sy = (-s+ + s-)/2*i integer :: i , D D = floor ( 2 * s + 1.01 ) call sx % allocate ([ D , D ], 'complex*16' ) call sx % setvalue ( 0 ) call sy % allocate ([ D , D ], 'complex*16' ) call sy % setvalue ( 0 ) call sz % allocate ([ D , D ], 'complex*16' ) call sz % setvalue ( 0 ) allocate ( spm ( D , D )) spm = 0 do i = 1 , D - 1 !m=-s+i-1 spm ( i + 1 , i ) = sqrt ( real ( i * ( 2 * s + 1 - i ))) !sp(m+1,m)=sqrt((s+m+1)*(s-m)) end do sx = ( spm + transpose ( spm )) / 2 sy = ( - spm + transpose ( spm )) / 2 * dcmplx ( 0 , 1 ) do i = 1 , D call sz % setvalue ([ i , i ], - s + i - 1 ) end do sp = spm sm = transpose ( spm ) deallocate ( spm ) end subroutine spin_matrix2 subroutine set_Dc ( myten , Dc , randomscal ) implicit none type ( tensor ), pointer , intent ( inout ) :: myten integer , intent ( in ) :: Dc real ( 8 ), intent ( in ) :: randomscal integer :: j , ind , dim , indnum type ( tensor ) :: allName allName = myten % outAllname ( 'left' ) indnum = allName % getTotalData () if ( indnum /= 0 ) then if ( indnum > 1 ) call wc_error_stop ( 'set_Dc' , 'More than one left' ) ind = myten % nameOrder ( allName % ai ( 1 )) dim = myten % dim ( ind ) if ( dim < Dc ) then call myten % enlarge ( ind , Dc , randomscal ) else if ( dim > Dc ) then myten = myten % subTensor ( ind ,[ 1 , Dc ]) end if end if allName = myten % outAllname ( 'right' ) indnum = allName % getTotalData () if ( indnum /= 0 ) then if ( indnum > 1 ) call wc_error_stop ( 'set_Dc' , 'More than one right' ) ind = myten % nameOrder ( allName % ai ( 1 )) dim = myten % dim ( ind ) if ( dim < Dc ) then call myten % enlarge ( ind , Dc , randomscal ) else if ( dim > Dc ) then myten = myten % subTensor ( ind ,[ 1 , Dc ]) end if end if end subroutine subroutine direct_sum ( ten1 , ten2 , ten3 , freeze ) type ( tensor ), intent ( inout ) :: ten1 , ten2 , ten3 character ( len =* ), intent ( in ) :: freeze (:) integer :: i , ind , dim , rank type ( tensor ) :: name logical , allocatable :: freeze_tag (:) integer , allocatable :: dim1 (:), dim2 (:), dim_shift (:), pos2 (:), pos_new (:) name = ten1 % getname () call ten2 % permute ( name % ai ()) rank = ten1 % getrank () allocate ( freeze_tag ( rank )) allocate ( dim1 ( rank )) dim1 = ten1 % dim () allocate ( dim2 ( rank )) dim2 = ten2 % dim () freeze_tag = . false . do i = 1 , size ( freeze ) ind = ten1 % nameOrder ( freeze ( i )) freeze_tag ( ind ) = . true . end do ten3 = ten1 allocate ( dim_shift ( rank )) do i = 1 , rank if ( freeze_tag ( i )) then dim_shift ( i ) = 0 else dim_shift ( i ) = dim1 ( i ) call ten3 % enlarge ( i , dim1 ( i ) + dim2 ( i ), 0 ) end if end do allocate ( pos2 ( rank )) allocate ( pos_new ( rank )) do i = 1 , ten2 % getTotalData () call ind2pos ( i , dim2 , pos2 ) pos_new = pos2 + dim_shift call ten3 % setvalue ( pos_new , ten2 % i ( pos2 )) end do end subroutine subroutine ind2pos ( ind , dims , pos ) integer , intent ( in ) :: ind , dims (:) integer , intent ( inout ) :: pos (:) integer :: temp , i temp = ind do i = 1 , size ( pos ) pos ( i ) = temp - dims ( i ) * ( temp / dims ( i )) + 1 temp = temp / dims ( i ) end do end subroutine function randten_sign ( ten , th1 , th2 , rand_grad , n1 , n2 , tot ) result ( rand_ten ) type ( tensor ), intent ( in ) :: ten type ( tensor ) :: rand_ten real ( 8 ), intent ( in ) :: th1 , th2 real ( 8 ), pointer :: dpointer (:) complex ( 8 ), pointer :: zpointer (:) type ( randomer ), intent ( inout ) :: rand_grad integer , intent ( inout ) :: n1 , n2 , tot real ( 8 ) :: grad_elem , grad_elem_re , grad_elem_im integer :: l rand_ten = ten tot = tot + rand_ten % getTotalData () select case ( rand_ten % gettype ()) case ( 3 ) call rand_ten % pointer ( dpointer ) do l = 1 , rand_ten % getTotalData () if ( abs ( dpointer ( l )) > th1 ) then grad_elem = sign ( rand_grad % randreal (), dpointer ( l )) n1 = n1 + 1 else if ( abs ( dpointer ( l )) > th2 ) then grad_elem = rand_grad % randreal () * dpointer ( l ) / th1 n2 = n2 + 1 else grad_elem = 0 end if dpointer ( l ) = grad_elem enddo case ( 5 ) call rand_ten % pointer ( zpointer ) do l = 1 , rand_ten % getTotalData () if ( abs ( zpointer ( l )) > th1 ) then grad_elem_re = sign ( rand_grad % randreal (), real ( zpointer ( l ))) grad_elem_im = sign ( rand_grad % randreal (), imag ( zpointer ( l ))) n1 = n1 + 1 else if ( abs ( zpointer ( l )) > th2 ) then grad_elem_re = rand_grad % randreal () * dble ( zpointer ( l )) / th1 grad_elem_im = rand_grad % randreal () * imag ( zpointer ( l )) / th1 n2 = n2 + 1 else grad_elem_re = 0 grad_elem_im = 0 end if zpointer ( l ) = dcmplx ( grad_elem_re , grad_elem_im ) enddo end select end function !!! mpi subroutine wc_allreduce_Tensor ( inTensor , outTensor , OP , MPIcommon , ierr ) type ( Tensor ), target , intent ( in ) :: inTensor type ( Tensor ), target , intent ( inout ) :: outTensor integer , intent ( inout ) :: ierr integer , intent ( in ) :: op integer , optional , intent ( in ) :: MPIcommon integer :: proID , proNum , length , mpi_comm type ( Tensor ), pointer :: p1 , p2 integer , pointer :: idata (:), idata2 (:) real * 4 , pointer :: sdata (:), sdata2 (:) real * 8 , pointer :: ddata (:), ddata2 (:) complex * 8 , pointer :: cdata (:), cdata2 (:) complex * 16 , pointer :: zdata (:), zdata2 (:) logical , pointer :: ldata (:), ldata2 (:) character ( len = characterlen ), pointer :: adata (:), adata2 (:) logical :: in_place if ( present ( MPIcommon )) then mpi_comm = MPIcommon else mpi_comm = mpi_comm_world end if call mpi_comm_rank ( mpi_comm , proID , ierr ) call mpi_comm_size ( mpi_comm , proNum , ierr ) if ( test_not_empty ( inTensor , mpi_comm ) == 0 ) then ! if the Tensor is empty call writemess ( 'ERROR in ALLREDUCE_Tensor,the is no date in one or some Tensors' ) call error_stop end if if ( test_same_type ( inTensor , mpi_comm ) == 0 ) then ! if the Tensor is the same data type call writemess ( 'ERROR in ALLREDUCE_Tensor,the Data type in the Tensors are not the sames' ) call error_stop end if if ( test_same_length ( inTensor , mpi_comm ) == 0 ) then ! if the length of the Tensor is the same call writemess ( 'ERROR in ALLREDUCE_Tensor,the length od the Tensor is not the same' ) call error_stop end if in_place = test_same_tensor ( inTensor , outTensor ) if (. not . in_place ) then call outTensor % empty () call outTensor % allocate ( inTensor ) end if length = inTensor % getTotalData () select case ( inTensor % getType ()) case ( 1 ) call inTensor % pointer ( idata ) call outTensor % pointer ( idata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , idata2 , length , MPI_INTEGER , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( idata , idata2 , length , MPI_INTEGER , OP , mpi_comm , ierr ) end if case ( 2 ) call inTensor % pointer ( sdata ) call outTensor % pointer ( sdata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , sdata2 , length , MPI_real , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( sdata , sdata2 , length , MPI_real , OP , mpi_comm , ierr ) end if case ( 3 ) call inTensor % pointer ( ddata ) call outTensor % pointer ( ddata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , ddata2 , length , MPI_double_precision , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( ddata , ddata2 , length , MPI_double_precision , OP , mpi_comm , ierr ) end if case ( 4 ) call inTensor % pointer ( cdata ) call outTensor % pointer ( cdata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , cdata2 , length , MPI_complex , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( cdata , cdata2 , length , MPI_complex , OP , mpi_comm , ierr ) end if case ( 5 ) call inTensor % pointer ( zdata ) call outTensor % pointer ( zdata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , zdata2 , length , MPI_double_complex , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( zdata , zdata2 , length , MPI_double_complex , OP , mpi_comm , ierr ) end if case ( 6 ) call inTensor % pointer ( ldata ) call outTensor % pointer ( ldata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , ldata2 , length , MPI_logical , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( ldata , ldata2 , length , MPI_logical , OP , mpi_comm , ierr ) end if case ( 7 ) call inTensor % pointer ( adata ) call outTensor % pointer ( adata2 ) if ( in_place ) then call MPI_ALLREDUCE ( MPI_IN_PLACE , adata2 , length , MPI_character , OP , mpi_comm , ierr ) else call MPI_ALLREDUCE ( adata , adata2 , length , MPI_character , OP , mpi_comm , ierr ) end if end  select end subroutine subroutine wc_reduce_Tensor ( inTensor , outTensor , OP , root , MPIcommon , ierr ) type ( Tensor ), target , intent ( in ) :: inTensor type ( Tensor ), target , intent ( inout ) :: outTensor integer , intent ( inout ) :: ierr integer , intent ( in ) :: op integer , optional , intent ( in ) :: MPIcommon , root integer :: proID , proNum , length , mpi_comm , mpi_root type ( Tensor ), pointer :: p1 , p2 integer , pointer :: idata (:), idata2 (:) real * 4 , pointer :: sdata (:), sdata2 (:) real * 8 , pointer :: ddata (:), ddata2 (:) complex * 8 , pointer :: cdata (:), cdata2 (:) complex * 16 , pointer :: zdata (:), zdata2 (:) logical , pointer :: ldata (:), ldata2 (:) character ( len = characterlen ), pointer :: adata (:), adata2 (:) logical :: in_place if ( present ( MPIcommon )) then mpi_comm = MPIcommon else mpi_comm = mpi_comm_world end if if ( present ( root )) then mpi_root = root else mpi_root = 0 end if call mpi_comm_rank ( mpi_comm , proID , ierr ) call mpi_comm_size ( mpi_comm , proNum , ierr ) if ( root >= proNum . or . root < 0 ) then call writemess ( 'ERROR in REDUCE_Tensor,input root is illegal' ) call error_stop end if if ( test_not_empty ( inTensor , mpi_comm ) == 0 ) then ! if the Tensor is empty call writemess ( 'ERROR in REDUCE_Tensor,the is no date in one or some Tensors' ) call error_stop end if if ( test_same_type ( inTensor , mpi_comm ) == 0 ) then ! if the Tensor is the same data type call writemess ( 'ERROR in REDUCE_Tensor,the Data type in the Tensors are not the sames' ) call error_stop end if if ( test_same_length ( inTensor , mpi_comm ) == 0 ) then ! if the length of the Tensor is the same call writemess ( 'ERROR in REDUCE_Tensor,the length od the Tensor is not the same' ) call error_stop end if in_place = test_same_tensor ( inTensor , outTensor ) if (. not . in_place ) then call outTensor % empty () call outTensor % allocate ( inTensor ) end if length = inTensor % getTotalData () select case ( inTensor % getType ()) case ( 1 ) call inTensor % pointer ( idata ) call outTensor % pointer ( idata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , idata2 , length , MPI_INTEGER , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( idata , idata2 , length , MPI_INTEGER , OP , mpi_root , mpi_comm , ierr ) end if case ( 2 ) call inTensor % pointer ( sdata ) call outTensor % pointer ( sdata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , sdata2 , length , MPI_real , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( sdata , sdata2 , length , MPI_real , OP , mpi_root , mpi_comm , ierr ) end if case ( 3 ) call inTensor % pointer ( ddata ) call outTensor % pointer ( ddata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , ddata2 , length , MPI_double_precision , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( ddata , ddata2 , length , MPI_double_precision , OP , mpi_root , mpi_comm , ierr ) end if case ( 4 ) call inTensor % pointer ( cdata ) call outTensor % pointer ( cdata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , cdata2 , length , MPI_complex , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( cdata , cdata2 , length , MPI_complex , OP , mpi_root , mpi_comm , ierr ) end if case ( 5 ) call inTensor % pointer ( zdata ) call outTensor % pointer ( zdata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , zdata2 , length , MPI_double_complex , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( zdata , zdata2 , length , MPI_double_complex , OP , mpi_root , mpi_comm , ierr ) end if case ( 6 ) call inTensor % pointer ( ldata ) call outTensor % pointer ( ldata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , ldata2 , length , MPI_logical , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( ldata , ldata2 , length , MPI_logical , OP , mpi_root , mpi_comm , ierr ) end if case ( 7 ) call inTensor % pointer ( adata ) call outTensor % pointer ( adata2 ) if ( in_place ) then call MPI_REDUCE ( MPI_IN_PLACE , adata2 , length , MPI_character , OP , mpi_root , mpi_comm , ierr ) else call MPI_REDUCE ( adata , adata2 , length , MPI_character , OP , mpi_root , mpi_comm , ierr ) end if end  select end subroutine function test_same_tensor ( T1 , T2 ) result ( res ) logical :: res type ( tensor ), intent ( in ), target :: T1 , T2 type ( tensor ), pointer :: p1 , p2 p1 => T1 p2 => T2 res = associated ( p1 , p2 ) p1 => null () p2 => null () end function function test_not_empty ( T , mpi_comm ) result ( res ) integer :: res , goonFlag type ( tensor ), intent ( in ) :: T integer , intent ( in ) :: mpi_comm integer :: ierr if ( T % getFlag ()) goonFlag = 0 call MPI_ALLREDUCE ( goonFlag , res , 1 , MPI_INTEGER , MPI_SUM , mpi_comm , ierr ) if ( res == 0 ) then res = 1 else res = 0 end if end function function test_same_type ( T , mpi_comm ) result ( res ) integer :: res , goonFlag type ( tensor ), intent ( in ) :: T integer , intent ( in ) :: mpi_comm integer :: ierr , classtype classtype = T % getType () call MPI_BCAST ( classtype , 1 , MPI_integer , 0 , mpi_comm , ierr ) if ( T % getType () == classtype ) goonFlag = 0 call MPI_ALLREDUCE ( goonFlag , res , 1 , MPI_INTEGER , MPI_SUM , mpi_comm , ierr ) if ( res == 0 ) then res = 1 else res = 0 end if end function function test_same_length ( T , mpi_comm ) result ( res ) integer :: res , goonFlag type ( tensor ), intent ( in ) :: T integer , intent ( in ) :: mpi_comm integer :: ierr , length length = T % getTotalData () call MPI_BCAST ( length , 1 , MPI_integer , 0 , mpi_comm , ierr ) if ( T % getTotalData () == length ) goonFlag = 0 call MPI_ALLREDUCE ( goonFlag , res , 1 , MPI_INTEGER , MPI_SUM , mpi_comm , ierr ) if ( res == 0 ) then res = 1 else res = 0 end if end function end module","tags":"","loc":"sourcefile/tensor_tools.f90.html"},{"title":"mpi_info.f90 – TNSG","text":"Files dependent on this one sourcefile~~mpi_info.f90~~AfferentGraph sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90 error.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~lattice.f90->sourcefile~mpi_info.f90 sourcefile~lattice.f90->sourcefile~error.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~string.f90 string.f90 sourcefile~lattice.f90->sourcefile~string.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~percentage.f90 percentage.f90 sourcefile~percentage.f90->sourcefile~mpi_info.f90 sourcefile~percentage.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~random.f90 random.f90 sourcefile~random.f90->sourcefile~error.f90 sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~tensor_tools.f90->sourcefile~error.f90 sourcefile~tensor_tools.f90->sourcefile~random.f90 sourcefile~tensor_tools.f90->sourcefile~string.f90 sourcefile~timer.f90 timer.f90 sourcefile~timer.f90->sourcefile~error.f90 sourcefile~timer.f90->sourcefile~string.f90 sourcefile~timer.f90->sourcefile~unidic.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~tn_tensor.f90->sourcefile~error.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 sourcefile~stack.f90 stack.f90 sourcefile~stack.f90->sourcefile~error.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~statistics.f90 statistics.f90 sourcefile~statistics.f90->sourcefile~error.f90 sourcefile~statistics.f90->sourcefile~string.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~paralist.f90 paralist.f90 sourcefile~paralist.f90->sourcefile~error.f90 sourcefile~paralist.f90->sourcefile~dictionary.f90 sourcefile~paralist.f90->sourcefile~string.f90 sourcefile~cumulator.f90 cumulator.f90 sourcefile~cumulator.f90->sourcefile~error.f90 sourcefile~cumulator.f90->sourcefile~tensor_tools.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~error.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~string.f90 sourcefile~date_time.f90 date_time.f90 sourcefile~date_time.f90->sourcefile~string.f90 var pansourcefilempi_infof90AfferentGraph = svgPanZoom('#sourcefilempi_infof90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_mpi_info Source Code mpi_info.f90 Source Code module mod_mpi_info implicit none integer :: nproc = 1 integer :: my_rank = 0 end module","tags":"","loc":"sourcefile/mpi_info.f90.html"},{"title":"ecp_handler.f90 – TNSG","text":"Contents Modules ecp_handler Source Code ecp_handler.f90 Source Code module ecp_handler !possible err: mpi implicit none private integer , parameter :: handle_char_length = 100 integer :: ecp_num = 0 , max_ecp_num = 100 , ecp_level = 0 , max_ecp_level = 20 character ( len = handle_char_length ), allocatable :: ecp_items (:), expand_temp (:) integer , allocatable :: ecp_counter (:,:), expand_temp2 (:,:) logical ( kind = 1 ), allocatable :: catched (:), expand_temp3 (:) logical ( kind = 1 ) :: ecp_handler_enabled = . false . interface catch module procedure catch_arg module procedure catch_noarg end interface public :: enable_ecp_handler , try , catch , throw , end_try contains subroutine enable_ecp_handler () implicit none allocate ( ecp_items ( max_ecp_num )) allocate ( ecp_counter ( max_ecp_num , max_ecp_level )) allocate ( catched ( max_ecp_level )) ecp_handler_enabled = . true . end subroutine logical function start_with ( full , head ) result ( res ) implicit none character ( len =* ), intent ( in ) :: full , head integer :: len_head res = . false . if ( len ( full ) > len ( head )) then if ( full ( 1 : len ( head ) + 1 ) == ( head // '.' )) res = . true . else if ( len ( full ) == len ( head )) then if ( head == full ) res = . true . end if end function subroutine try () implicit none if ( ecp_handler_enabled ) then ecp_level = ecp_level + 1 if ( ecp_level > max_ecp_level ) then !exceeds boundary allocate ( expand_temp2 ( max_ecp_num , max_ecp_level )) expand_temp2 = ecp_counter deallocate ( ecp_counter ) allocate ( ecp_counter ( max_ecp_num , 2 * max_ecp_level )) ecp_counter = 0 ecp_counter (:, 1 : max_ecp_level ) = expand_temp2 deallocate ( expand_temp2 ) allocate ( expand_temp3 ( max_ecp_level )) expand_temp3 = catched deallocate ( catched ) allocate ( catched ( 2 * max_ecp_level )) catched ( 1 : max_ecp_level ) = expand_temp3 deallocate ( expand_temp3 ) max_ecp_level = 2 * max_ecp_level end if catched ( ecp_level ) = . false . end if end subroutine logical function catch_arg ( exception ) result ( exist ) implicit none character ( len =* ), intent ( in ) :: exception integer :: i if ( ecp_handler_enabled ) then catched ( ecp_level ) = . true . exist = . false . do i = 1 , ecp_num if ( ecp_counter ( i , ecp_level ) > 0 ) then if ( start_with ( trim ( ecp_items ( i )), trim ( exception ))) then exist = . true . ecp_counter ( i , ecp_level ) = 0 end if end if end do else exist = . false . end if end function logical function catch_noarg () result ( exist ) implicit none if ( ecp_handler_enabled ) then catched ( ecp_level ) = . true . exist = any ( ecp_counter ( 1 : ecp_num , ecp_level ) > 0 ) ecp_counter (:, ecp_level ) = 0 else exist = . false . end if end function subroutine end_try () implicit none integer :: i , throw_level if ( ecp_handler_enabled ) then throw_level = 0 do i = ecp_level - 1 , 1 , - 1 if (. not . catched ( i )) then throw_level = i exit end if end do if ( throw_level > 0 ) then ecp_counter (:, throw_level ) = ecp_counter (:, throw_level ) + ecp_counter (:, ecp_level ) end if ecp_level = ecp_level - 1 if ( throw_level < 0 ) then write ( * , * ) 'End_try not paired with try.' stop end if end if end subroutine subroutine throw ( exception ) implicit none character ( len =* ), intent ( in ) :: exception integer :: i , throw_level logical :: exist if ( ecp_handler_enabled ) then do i = ecp_level , 1 , - 1 throw_level = i if (. not . catched ( throw_level )) exit end do if ( throw_level > 0 ) then exist = . false . do i = 1 , ecp_num if ( trim ( ecp_items ( i )) == trim ( exception )) then exist = . true . ecp_counter ( i , throw_level ) = ecp_counter ( i , throw_level ) + 1 exit end if end do if (. not . exist ) then if ( ecp_num == max_ecp_num ) then !exceeds boundary allocate ( expand_temp ( max_ecp_num )) expand_temp = ecp_items deallocate ( ecp_items ) allocate ( ecp_items ( 2 * max_ecp_num )) ecp_items ( 1 : max_ecp_num ) = expand_temp deallocate ( expand_temp ) allocate ( expand_temp2 ( max_ecp_num , max_ecp_level )) expand_temp2 = ecp_counter deallocate ( ecp_counter ) allocate ( ecp_counter ( 2 * max_ecp_num , max_ecp_level )) ecp_counter = 0 ecp_counter ( 1 : max_ecp_num ,:) = expand_temp2 deallocate ( expand_temp2 ) max_ecp_num = 2 * max_ecp_num end if ecp_num = ecp_num + 1 ecp_items ( ecp_num ) = exception ecp_counter ( ecp_num , throw_level ) = 1 end if end if end if end subroutine end module ecp_handler","tags":"","loc":"sourcefile/ecp_handler.f90.html"},{"title":"cumulator.f90 – TNSG","text":"This file depends on sourcefile~~cumulator.f90~~EfferentGraph sourcefile~cumulator.f90 cumulator.f90 sourcefile~tensor_tools.f90 tensor_tools.f90 sourcefile~cumulator.f90->sourcefile~tensor_tools.f90 sourcefile~error.f90 error.f90 sourcefile~cumulator.f90->sourcefile~error.f90 sourcefile~tensor_tools.f90->sourcefile~error.f90 sourcefile~random.f90 random.f90 sourcefile~tensor_tools.f90->sourcefile~random.f90 sourcefile~string.f90 string.f90 sourcefile~tensor_tools.f90->sourcefile~string.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~random.f90->sourcefile~error.f90 sourcefile~string.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_cumu Source Code cumulator.f90 Source Code module mod_cumu use tensor_type use tnsp_ext use error implicit none private type cumulator private real ( 8 ) :: dcumu complex ( 8 ) :: zcumu type ( tensor ) :: tcumu real ( 8 ) :: weight character ( len = 1 ) :: type = 'f' ! f means undefined contains private procedure , public :: init procedure :: iadd procedure :: dadd procedure :: zadd procedure :: tadd generic , public :: add => iadd , dadd , zadd , tadd procedure , public :: clean procedure , public :: dave procedure , public :: zave procedure , public :: tave procedure , public :: get_weight end type public cumulator contains subroutine init ( C , type , T ) class ( cumulator ), intent ( inout ) :: C character ( len = 1 ), intent ( in ) :: type class ( tensor ), intent ( in ), optional :: T select case ( type ) case ( 'd' ) C % type = 'd' case ( 'z' ) C % type = 'z' case ( 't' ) C % type = 't' if (. not . present ( T )) then call wc_error_stop ( 'cumu.init' , 'tensor prototype needed!' ) else call C % tcumu % allocate ( T ) call C % tcumu % static () end if case default call wc_error_stop ( 'cumu.init' , 'input type unidentified!' ) end select call C % clean () end subroutine subroutine iadd ( C , val , weight_ ) class ( cumulator ), intent ( inout ) :: C integer , intent ( in ) :: val real ( 8 ), intent ( in ), optional :: weight_ real ( 8 ) :: weight type ( tensor ) :: name if ( present ( weight_ )) then weight = weight_ else weight = 1 d0 end if select case ( C % type ) case ( 'd' ) C % dcumu = C % dcumu + val * weight case ( 'z' ) C % zcumu = C % zcumu + val * weight case ( 't' ) if (. not . abs ( val ) < 1 d - 10 ) then ! otherwise 0 is added call wc_error_stop ( 'cumu.add' , 'tensor input needed!' ) end if case ( 'f' ) call wc_error_stop ( 'cumu.add' , 'cumulator used before initiated!' ) end select C % weight = C % weight + weight end subroutine subroutine dadd ( C , val , weight_ ) class ( cumulator ), intent ( inout ) :: C real ( 8 ), intent ( in ) :: val real ( 8 ), intent ( in ), optional :: weight_ real ( 8 ) :: weight type ( tensor ) :: name if ( present ( weight_ )) then weight = weight_ else weight = 1 d0 end if select case ( C % type ) case ( 'd' ) C % dcumu = C % dcumu + val * weight case ( 'z' ) C % zcumu = C % zcumu + val * weight case ( 't' ) if (. not . abs ( val ) < 1 d - 10 ) then ! otherwise 0 is added call wc_error_stop ( 'cumu.add' , 'tensor input needed!' ) end if case ( 'f' ) call wc_error_stop ( 'cumu.add' , 'cumulator used before initiated!' ) end select C % weight = C % weight + weight end subroutine subroutine zadd ( C , val , weight_ ) class ( cumulator ), intent ( inout ) :: C complex ( 8 ), intent ( in ) :: val real ( 8 ), intent ( in ), optional :: weight_ real ( 8 ) :: weight type ( tensor ) :: name if ( present ( weight_ )) then weight = weight_ else weight = 1 d0 end if select case ( C % type ) case ( 'd' ) C % dcumu = C % dcumu + val * weight case ( 'z' ) C % zcumu = C % zcumu + val * weight case ( 't' ) call wc_error_stop ( 'cumu.add' , 'tensor input needed!' ) case ( 'f' ) call wc_error_stop ( 'cumu.add' , 'cumulator used before initiated!' ) end select C % weight = C % weight + weight end subroutine subroutine tadd ( C , val , weight_ ) class ( cumulator ), intent ( inout ) :: C class ( tensor ), intent ( inout ) :: val real ( 8 ), intent ( in ), optional :: weight_ real ( 8 ) :: weight type ( tensor ) :: name if ( present ( weight_ )) then weight = weight_ else weight = 1 d0 end if select case ( C % type ) case ( 'd' , 'z' ) call wc_error_stop ( 'cumu.add' , 'real or complex input needed!' ) case ( 't' ) name = C % tcumu % getname () call val % permute ( name % ai ()) C % tcumu = C % tcumu + val * weight case ( 'f' ) call wc_error_stop ( 'cumu.add' , 'cumulator used before initiated!' ) end select C % weight = C % weight + weight end subroutine subroutine clean ( C ) class ( cumulator ), intent ( inout ) :: C select case ( C % type ) case ( 'd' ) C % dcumu = 0 d0 case ( 'z' ) C % zcumu = dcmplx ( 0 d0 , 0 d0 ) case ( 't' ) call C % tcumu % zero () case ( 'f' ) call wc_error_stop ( 'cumu.clean' , 'cumulator used before initiated!' ) end select C % weight = 0 d0 end subroutine function dave ( C , comm , root ) result ( res ) class ( cumulator ), intent ( inout ) :: C integer , intent ( in ), optional :: comm , root integer :: my_rank , nproc , ierr real ( 8 ) :: res , totcumu , totweight select case ( C % type ) case ( 'd' ) if ( present ( comm )) then if ( present ( root )) then call MPI_Comm_size ( comm , nproc , ierr ) call MPI_Comm_rank ( MPI_COMM_WORLD , my_rank , ierr ) if ( root >= nproc ) call wc_error_stop ( 'cumu.dave' , 'root id >= number of processors!' ) call MPI_reduce ( C % dcumu , totcumu , 1 , MPI_REAL8 , MPI_SUM , root , comm , ierr ) call MPI_reduce ( C % weight , totweight , 1 , MPI_REAL8 , MPI_SUM , root , comm , ierr ) if ( my_rank == root ) then if ( totweight == 0 d0 ) call wc_error_stop ( 'cumu.dave' , 'total weight is 0!' ) res = totcumu / totweight end if else call MPI_allreduce ( C % dcumu , totcumu , 1 , MPI_REAL8 , MPI_SUM , comm , ierr ) call MPI_allreduce ( C % weight , totweight , 1 , MPI_REAL8 , MPI_SUM , comm , ierr ) if ( totweight == 0 d0 ) call wc_error_stop ( 'cumu.dave' , 'total weight is 0!' ) res = totcumu / totweight end if else if ( C % weight == 0 d0 ) call wc_error_stop ( 'cumu.dave' , 'total weight is 0!' ) res = C % dcumu / C % weight end if case ( 'z' ) call wc_error_stop ( 'cumu.dave' , 'please use zave for complex value!' ) case ( 't' ) call wc_error_stop ( 'cumu.dave' , 'please use tave for tensor value!' ) case ( 'f' ) call wc_error_stop ( 'cumu.dave' , 'cumulator used before initiated!' ) end select end function function zave ( C , comm , root ) result ( res ) class ( cumulator ), intent ( inout ) :: C integer , intent ( in ), optional :: comm , root integer :: my_rank , nproc , ierr complex ( 8 ) :: res , totcumu real ( 8 ) :: totweight select case ( C % type ) case ( 'd' ) call wc_error_stop ( 'cumu.zave' , 'please use dave for real value!' ) case ( 'z' ) if ( present ( comm )) then if ( present ( root )) then call MPI_Comm_size ( comm , nproc , ierr ) call MPI_Comm_rank ( comm , my_rank , ierr ) if ( root >= nproc ) call wc_error_stop ( 'cumu.zave' , 'root id >= number of processors!' ) call MPI_reduce ( C % zcumu , totcumu , 1 , MPI_DOUBLE_COMPLEX , MPI_SUM , root , comm , ierr ) call MPI_reduce ( C % weight , totweight , 1 , MPI_REAL8 , MPI_SUM , root , comm , ierr ) if ( my_rank == root ) then if ( totweight == 0 d0 ) call wc_error_stop ( 'cumu.zave' , 'total weight is 0!' ) res = totcumu / totweight end if else call MPI_allreduce ( C % zcumu , totcumu , 1 , MPI_DOUBLE_COMPLEX , MPI_SUM , comm , ierr ) call MPI_allreduce ( C % weight , totweight , 1 , MPI_REAL8 , MPI_SUM , comm , ierr ) if ( totweight == 0 d0 ) call wc_error_stop ( 'cumu.zave' , 'total weight is 0!' ) res = totcumu / totweight end if else if ( C % weight == 0 d0 ) call wc_error_stop ( 'cumu.zave' , 'total weight is 0!' ) res = C % zcumu / C % weight end if case ( 't' ) call wc_error_stop ( 'cumu.zave' , 'please use tave for tensor value!' ) case ( 'f' ) call wc_error_stop ( 'cumu.zave' , 'cumulator used before initiated!' ) end select end function function tave ( C , comm , root ) result ( res ) class ( cumulator ), intent ( inout ) :: C integer , intent ( in ), optional :: comm , root integer :: my_rank , nproc , ierr real ( 8 ) :: totweight type ( tensor ) :: res , totcumu select case ( C % type ) case ( 'd' ) call wc_error_stop ( 'cumu.tave' , 'please use dave for real value!' ) case ( 'z' ) call wc_error_stop ( 'cumu.tave' , 'please use zave for complex value!' ) case ( 't' ) if ( present ( comm )) then if ( present ( root )) then call MPI_Comm_size ( comm , nproc , ierr ) call MPI_Comm_rank ( comm , my_rank , ierr ) if ( root >= nproc ) call wc_error_stop ( 'cumu.tave' , 'root id >= number of processors!' ) call wc_reduce_Tensor ( C % tcumu , totcumu , MPI_SUM , root , comm , ierr ) call MPI_reduce ( C % weight , totweight , 1 , MPI_REAL8 , MPI_SUM , root , comm , ierr ) if ( my_rank == root ) then if ( totweight == 0 d0 ) call wc_error_stop ( 'cumu.tave' , 'total weight is 0!' ) res = totcumu / totweight end if else call wc_allreduce_Tensor ( C % tcumu , totcumu , MPI_SUM , comm , ierr ) call MPI_allreduce ( C % weight , totweight , 1 , MPI_REAL8 , MPI_SUM , comm , ierr ) if ( totweight == 0 d0 ) call wc_error_stop ( 'cumu.tave' , 'total weight is 0!' ) res = totcumu / totweight end if else if ( C % weight == 0 d0 ) call wc_error_stop ( 'cumu.tave' , 'total weight is 0!' ) res = C % tcumu / C % weight end if case ( 'f' ) call wc_error_stop ( 'cumu.tave' , 'cumulator used before initiated!' ) end select end function function get_weight ( C , comm , root ) result ( res ) class ( cumulator ), intent ( inout ) :: C integer , intent ( in ), optional :: comm , root integer :: nproc , ierr real ( 8 ) :: res , totcumu , totweight res = 0 if ( C % type == 'f' ) call wc_error_stop ( 'cumu.get_weight' , 'cumulator used before initiated!' ) if ( present ( comm )) then if ( present ( root )) then call MPI_Comm_size ( comm , nproc , ierr ) if ( root >= nproc ) call wc_error_stop ( 'cumu.get_weight' , 'root id >= number of processors!' ) call MPI_reduce ( C % weight , res , 1 , MPI_REAL8 , MPI_SUM , root , comm , ierr ) else call MPI_allreduce ( C % weight , res , 1 , MPI_REAL8 , MPI_SUM , comm , ierr ) end if else res = C % weight end if end function end module","tags":"","loc":"sourcefile/cumulator.f90.html"},{"title":"date_time.f90 – TNSG","text":"This file depends on sourcefile~~date_time.f90~~EfferentGraph sourcefile~date_time.f90 date_time.f90 sourcefile~string.f90 string.f90 sourcefile~date_time.f90->sourcefile~string.f90 sourcefile~error.f90 error.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_date_time Source Code date_time.f90 Source Code module mod_date_time use string implicit none private public str_date_time , str_date_time_ contains function str_date_time () result ( res ) character (:), allocatable :: res integer :: date_time ( 8 ) call date_and_time ( VALUES = date_time ) res = str ( date_time ( 1 : 3 ), '/' ) // ',' // str ( date_time ( 5 : 7 ), ':' ) end function function str_date_time_ () result ( res ) character (:), allocatable :: res character ( len = 10 ) :: date integer :: date_time ( 8 ) call date_and_time ( DATE = date , VALUES = date_time ) res = trim ( date ) // '_' // str ( date_time ( 5 : 7 ), '_' ) end function end module","tags":"","loc":"sourcefile/date_time.f90.html"},{"title":"tn_tensor.f90 – TNSG","text":"This file depends on sourcefile~~tn_tensor.f90~~EfferentGraph sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~error.f90 error.f90 sourcefile~tn_tensor.f90->sourcefile~error.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~lattice.f90->sourcefile~error.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~lattice.f90->sourcefile~mpi_info.f90 sourcefile~string.f90 string.f90 sourcefile~lattice.f90->sourcefile~string.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~stack.f90 stack.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~stack.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~tn_tensor.f90~~AfferentGraph sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tn_tensor_type Source Code tn_tensor.f90 Source Code MODULE tn_tensor_type use error use tools use tensor_network use tensor_type implicit none private type , extends ( tensor ) :: tn_tensor private type ( group ) :: grp contains private procedure , public :: get_info procedure , public :: draw procedure , public :: empty procedure , public :: absorb procedure , public :: absorb_with_env procedure , public :: absorb_just_env procedure , public :: take procedure :: absorb_all0 procedure :: absorb_all1 generic , public :: absorb_all => absorb_all0 , absorb_all1 procedure , public :: belong procedure :: take_except_pos procedure :: take_except_name procedure :: take_except_path procedure :: take_except_group generic , public :: take_except => take_except_pos , take_except_name , take_except_path , take_except_group procedure :: absorb0_except_pos procedure :: absorb1_except_pos procedure :: absorb0_except_name generic , public :: absorb_except => absorb0_except_pos , absorb0_except_name , absorb1_except_pos procedure , public :: invert_bond procedure , public :: get_lattice_link end type interface assignment ( = ) module procedure assignmentDTN module procedure assignmentZTN module procedure assignmentTTN module procedure assignmentTNTN end interface interface operator ( * ) module procedure scale_tn end interface interface operator ( / ) module procedure divide_tn end interface interface operator (. con .) module procedure conjugate_tn end interface interface absorb_all_rt module procedure absorb_all0_rt module procedure absorb_all1_rt end interface interface TNcontract module procedure contract_TNTN end interface logical :: draw_mode = . false . public tn_tensor , assignment ( = ), operator ( * ), operator ( / ), operator (. con .), absorb_rt , absorb_all_rt , TNcontract ,& tn_draw_on , tn_draw_off contains subroutine tn_draw_on () draw_mode = . true . end subroutine subroutine tn_draw_off () draw_mode = . false . end subroutine type ( tn_tensor ) function scale_tn ( T , mul ) type ( tn_tensor ), intent ( in ) :: T class ( * ), intent ( in ) :: mul scale_tn % grp = T % grp select type ( mul ) type is ( real ( 4 )) scale_tn % tensor = T % tensor * mul type is ( real ( 8 )) scale_tn % tensor = T % tensor * mul type is ( complex ( 4 )) scale_tn % tensor = T % tensor * mul type is ( complex ( 8 )) scale_tn % tensor = T % tensor * mul end select end function type ( tn_tensor ) function divide_tn ( T , mul ) type ( tn_tensor ), intent ( in ) :: T class ( * ), intent ( in ) :: mul divide_tn % grp = T % grp select type ( mul ) type is ( real ( 4 )) divide_tn % tensor = T % tensor / mul type is ( real ( 8 )) divide_tn % tensor = T % tensor / mul type is ( complex ( 4 )) divide_tn % tensor = T % tensor / mul type is ( complex ( 8 )) divide_tn % tensor = T % tensor / mul end select end function type ( tn_tensor ) function conjugate_tn ( T ) type ( tn_tensor ), intent ( in ) :: T conjugate_tn % grp = T % grp conjugate_tn % tensor = . con . T % tensor end function subroutine assignmentTN ( T1 , T2 ) type ( tn_tensor ), intent ( in ) :: T2 class ( * ), intent ( inout ) :: T1 select type ( T1 ) type is ( real ( 4 )) if ( T2 % gettotaldata () == 1 ) then T1 = T2 % si ([ 1 , 1 ]) else call wc_error_stop ( 'assignmentTN' , 'Tensor should be 1D to assign to a real4 number' ) end if type is ( real ( 8 )) if ( T2 % gettotaldata () == 1 ) then T1 = T2 % di ([ 1 , 1 ]) else call wc_error_stop ( 'assignmentTN' , 'Tensor should be 1D to assign to a real8 number' ) end if type is ( complex ( 4 )) if ( T2 % gettotaldata () == 1 ) then T1 = T2 % ci ([ 1 , 1 ]) else call wc_error_stop ( 'assignmentTN' , 'Tensor should be 1D to assign to a com4 number' ) end if type is ( complex ( 8 )) if ( T2 % gettotaldata () == 1 ) then T1 = T2 % zi ([ 1 , 1 ]) else call wc_error_stop ( 'assignmentTN' , 'Tensor should be 1D to assign to a com8 number' ) end if type is ( tensor ) T1 = T2 % tensor type is ( tn_tensor ) T1 % grp = T2 % grp T1 % tensor = T2 % tensor end select end subroutine subroutine assignmentDTN ( T1 , T2 ) type ( tn_tensor ), intent ( in ) :: T2 real ( 8 ), intent ( inout ) :: T1 if ( T2 % gettotaldata () == 1 ) then T1 = T2 % di ([ 1 , 1 ]) else call wc_error_stop ( 'assignmentTN' , 'Tensor should be 1D to assign to a real8 number' ) end if end subroutine subroutine assignmentZTN ( T1 , T2 ) type ( tn_tensor ), intent ( in ) :: T2 complex ( 8 ), intent ( inout ) :: T1 if ( T2 % gettotaldata () == 1 ) then T1 = T2 % zi ([ 1 , 1 ]) else call wc_error_stop ( 'assignmentTN' , 'Tensor should be 1D to assign to a com8 number' ) end if end subroutine subroutine assignmentTTN ( T1 , T2 ) type ( tn_tensor ), intent ( in ) :: T2 type ( tensor ), intent ( inout ) :: T1 T1 = T2 % tensor end subroutine subroutine assignmentTNTN ( T1 , T2 ) type ( tn_tensor ), intent ( in ) :: T2 type ( tn_tensor ), intent ( inout ) :: T1 T1 % grp = T2 % grp T1 % tensor = T2 % tensor end subroutine subroutine belong ( T , L ) class ( tn_tensor ), intent ( inout ) :: T class ( lattice ), target , intent ( in ) :: L call T % grp % belong ( L ) end subroutine subroutine empty ( T ) class ( tn_tensor ), intent ( inout ) :: T call T % grp % empty call T % tensor % empty () end subroutine subroutine draw ( T , tnname , label_bond , fixed , check_tag ) class ( tn_tensor ), intent ( inout ) :: T character ( len =* ), intent ( in ) :: tnname logical , intent ( in ), optional :: label_bond , fixed , check_tag call T % grp % draw ( tnname , tnname , label_bond , fixed , check_tag ) end subroutine subroutine get_info ( T ) class ( tn_tensor ), intent ( inout ) :: T integer :: L1 , L2 call T % grp % get_info call writemess ( 'The dim of tensor is :' ) call T % diminfo () call writemess ( 'The program has been paused. Please press any key to continue' ) read ( * , * ) end subroutine subroutine take ( T , pos ) !if already includes or pos have no tn, don't do anything class ( tn_tensor ), intent ( inout ) :: T integer , intent ( in ) :: pos ( 2 ) call T % grp % take ( pos ) if ( draw_mode ) call T % draw ( 'tn_take' ) end subroutine subroutine absorb ( T , pos ) !if already includes or pos have no tn, don't do anything class ( tn_tensor ), intent ( inout ) :: T type ( tensor ) :: tt integer , intent ( in ) :: pos ( 2 ) call lat_absorb_tensor ( T % tensor , T % tensor , T % grp , pos ) if ( draw_mode ) call T % draw ( 'tn_absorb' ) end subroutine subroutine absorb_just_env ( T , pos ) !if already includes or pos have no tn, don't do anything class ( tn_tensor ), intent ( inout ) :: T type ( tensor ) :: tt integer , intent ( in ) :: pos ( 2 ) call lat_absorb_env ( T % tensor , T % tensor , T % grp , pos ) if ( draw_mode ) call T % draw ( 'tn_absorb' ) end subroutine subroutine absorb_with_env ( T , pos ) !if already includes or pos have no tn, don't do anything class ( tn_tensor ), intent ( inout ) :: T type ( tensor ) :: tt integer , intent ( in ) :: pos ( 2 ) call absorb_just_env ( T , pos ) call absorb ( T , pos ) end subroutine subroutine absorb_rt ( Tout , Tin , pos ) !if already includes or pos have no tn, don't do anything class ( tn_tensor ), intent ( inout ) :: Tout , Tin integer , intent ( in ) :: pos ( 2 ) Tout % grp = Tin % grp call lat_absorb_tensor ( Tout % tensor , Tin % tensor , Tout % grp , pos ) if ( draw_mode ) call Tout % draw ( 'tn_absorb' ) end subroutine type ( tn_tensor ) function contract_TNTN ( T1 , T2 ) result ( Res ) type ( tn_tensor ), intent ( inout ) :: T1 , T2 integer :: num Res % grp = T1 % grp call lat_contract_type ( Res % Tensor , T1 % Tensor , T2 % Tensor , Res % grp , T2 % grp ) if ( draw_mode ) call Res % draw ( 'tn_contract' ) end function subroutine absorb_all1 ( T1 , T2 , abp_ ) class ( tn_tensor ), intent ( inout ) :: T1 class ( tn_tensor ), intent ( inout ) :: T2 type ( lattice ), pointer :: plat type ( path ), optional , intent ( in ) :: abp_ type ( path ) :: abp integer :: i , path_pos ( 2 ) call T1 % grp % point_lat ( plat ) if ( present ( abp_ )) then abp = abp_ else call abp % belong ( plat ) call abp % generate ( 'lu' , T2 % grp ) end if if ( draw_mode ) call T1 % draw ( 'tn_absorb_all_T1_before' ) do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) call T1 % absorb ( path_pos ) end do if ( draw_mode ) call T1 % draw ( 'tn_absorb_all_T1_after' ) if ( draw_mode ) call T2 % draw ( 'tn_absorb_all_T2' ) call lat_contract_type ( T1 % Tensor , T1 % Tensor , T2 % Tensor , T1 % grp , T2 % grp ) if ( draw_mode ) call T1 % draw ( 'tn_absorb_result' ) end subroutine type ( tn_tensor ) function absorb_all1_rt ( T1 , T2 , abp ) result ( Res ) class ( tn_tensor ), intent ( inout ) :: T1 class ( tn_tensor ), intent ( inout ) :: T2 type ( path ), optional , intent ( in ) :: abp Res = T1 call Res % absorb_all1 ( T2 , abp ) end function subroutine absorb_all0 ( T , abp_ ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat type ( path ), optional , intent ( in ) :: abp_ type ( path ) :: abp integer :: i , path_pos ( 2 ) if ( draw_mode ) call T % draw ( 'tn_absorb_all_T' ) call T % grp % point_lat ( plat ) if ( present ( abp_ )) then abp = abp_ else call abp % belong ( plat ) call abp % generate ( 'lu' ) end if do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) call T % absorb ( path_pos ) end do if ( draw_mode ) call T % draw ( 'tn_absorb_all_result' ) end subroutine type ( tn_tensor ) function absorb_all0_rt ( T , abp ) result ( Res ) class ( tn_tensor ), intent ( inout ) :: T type ( path ), optional , intent ( in ) :: abp Res = T call Res % absorb_all0 ( abp ) end function subroutine absorb0_except_pos ( T , pos , abp_ ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat integer , intent ( in ) :: pos ( 2 ) type ( path ), optional , intent ( in ) :: abp_ integer :: i , path_pos ( 2 ) type ( path ) :: abp type ( group ) :: avoid_grp call T % grp % point_lat ( plat ) if ( T % grp % check_contain ( pos )) then call wc_error_stop ( 'tn_tensor.absorb_except' , 'site at pos already contained in the group1' ) end if if ( present ( abp_ )) then abp = abp_ else call abp % belong ( plat ) call abp % generate ( 'lu' ) end if !call abp%draw('absorb_except',check_tag=.false.) if ( draw_mode ) call T % draw ( 'tn_absorb_all_except_T' ) do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) !write(*,*)path_pos if (. not . all ( path_pos == pos )) call T % absorb ( path_pos ) !call T%draw('tn_absorb_except_test',check_tag=.false.) end do if ( draw_mode ) call T % draw ( 'tn_absorb_all_except_result' ) end subroutine subroutine take_except_pos ( T , pos ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat integer , intent ( in ) :: pos ( 2 ) integer :: i , path_pos ( 2 ) type ( path ) :: abp call T % grp % point_lat ( plat ) call abp % belong ( plat ) call abp % generate ( 'lu' ) do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) !write(*,*)path_pos if (. not . all ( path_pos == pos )) call T % take ( path_pos ) !call T%draw('tn_absorb_except_test',check_tag=.false.) end do end subroutine subroutine take_except_name ( T , name ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat character ( len =* ), intent ( in ) :: name integer :: pos ( 2 ) call T % grp % point_lat ( plat ) pos = plat % get_pos ( name ) call T % take_except_pos ( pos ) end subroutine subroutine take_except_path ( T , pat ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat type ( path ), intent ( in ) :: pat integer :: i , path_pos ( 2 ) type ( path ) :: abp call T % grp % point_lat ( plat ) call abp % belong ( plat ) call abp % generate ( 'lu' ) do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) !write(*,*)path_pos if (. not . pat % check_contain ( path_pos )) call T % take ( path_pos ) !call T%draw('tn_absorb_except_test',check_tag=.false.) end do end subroutine subroutine take_except_group ( T , grp ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat type ( group ), intent ( in ) :: grp integer :: i , path_pos ( 2 ) type ( path ) :: abp call T % grp % point_lat ( plat ) call abp % belong ( plat ) call abp % generate ( 'lu' ) do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) !write(*,*)path_pos if (. not . grp % check_contain ( path_pos )) call T % take ( path_pos ) !call T%draw('tn_absorb_except_test',check_tag=.false.) end do end subroutine subroutine absorb1_except_pos ( T , T2 , pos , abp_ ) class ( tn_tensor ), intent ( inout ) :: T , T2 type ( lattice ), pointer :: plat integer , intent ( in ) :: pos ( 2 ) type ( path ), optional , intent ( in ) :: abp_ integer :: i , path_pos ( 2 ) type ( path ) :: abp call T % grp % point_lat ( plat ) if ( T % grp % check_contain ( pos )) then call wc_error_stop ( 'tn_tensor.absorb_except' , 'site at pos already contained in the group' ) end if if ( T2 % grp % check_contain ( pos )) then call wc_error_stop ( 'tn_tensor.absorb_except' , 'site at pos already contained in the group2' ) end if if ( present ( abp_ )) then abp = abp_ else call abp % belong ( plat ) call abp % generate ( 'lu' ) end if !call abp%draw('absorb_except',check_tag=.false.) if ( draw_mode ) call T % draw ( 'tn_absorb_all_except_T' ) do i = 1 , abp % get_num () call abp % iterate ( path_pos ,( i == 1 )) !write(*,*)path_pos if (. not . ( all ( path_pos == pos ) . or . T2 % grp % check_contain ( path_pos ))) call T % absorb ( path_pos ) !call T%draw('tn_absorb_except_test',check_tag=.false.) end do if ( draw_mode ) call T % draw ( 'tn_absorb_all_except_T_after' ) if ( draw_mode ) call T2 % draw ( 'tn_absorb_all_except_T2' ) call lat_contract_type ( T % Tensor , T % Tensor , T2 % Tensor , T % grp , T2 % grp ) if ( draw_mode ) call T % draw ( 'tn_absorb_all_except_result' ) end subroutine subroutine absorb0_except_name ( T , name , abp ) class ( tn_tensor ), intent ( inout ) :: T type ( lattice ), pointer :: plat character ( len =* ), intent ( in ) :: name type ( path ), optional , intent ( in ) :: abp integer :: pos ( 2 ) call T % grp % point_lat ( plat ) if (. not . plat % check_exist ( name )) then call wc_error_stop ( 'tn_tensor.absorb_except' , 'site at pos does not exist' ) end if pos = plat % get_pos ( name ) call T % absorb_except ( pos , abp ) end subroutine subroutine invert_bond ( T ) class ( tn_tensor ), intent ( inout ) :: T call T % grp % invert_bond ( T % tensor ) end subroutine subroutine get_lattice_link ( T , L ) class ( tn_tensor ), target , intent ( in ) :: T type ( lattice ), pointer , intent ( inout ) :: L call T % grp % get_lattice_link ( L ) end subroutine end module tn_tensor_type","tags":"","loc":"sourcefile/tn_tensor.f90.html"},{"title":"tracer.f90 – TNSG","text":"Contents Modules tracer Source Code tracer.f90 Source Code module tracer !possible err: mpi implicit none private integer , parameter :: tracer_char_length = 100 integer :: trace_num = 0 , trace_level = 0 , max_trace_num = 100 character ( len = tracer_char_length ), allocatable :: trace_items (:), expand_temp (:) logical ( kind = 1 ) :: trace_realtime_tag = . false ., trace_enabled = . false ., trace_print_tag = . false . interface trace module procedure add_trace module procedure end_trace end interface public :: enable_tracer , print_tracer , print_tracer_end , trace_realtime , print_trace , trace , trace_test contains subroutine enable_tracer () allocate ( trace_items ( max_trace_num )) trace_enabled = . true . end subroutine subroutine print_tracer () trace_print_tag = . true . end subroutine subroutine print_tracer_end () trace_print_tag = . false . end subroutine subroutine trace_realtime ( filename ) character ( len =* ), intent ( in ) :: filename integer :: i if ( trace_enabled ) then open ( 777 , file = trim ( filename )) rewind ( 777 ) write ( 777 , * ) 'The trace of current position is:' do i = 1 , trace_num write ( 777 , * ) repeat ( '-' , 2 * i ) // trim ( trace_items ( i )) end do trace_realtime_tag = . true . end if end subroutine subroutine add_trace ( info ) character ( len =* ), intent ( in ) :: info integer :: point_pos if ( trace_enabled ) then if ( len ( trim ( info )) > tracer_char_length ) then write ( * , * ) 'Length of input string(' , len ( trim ( info )), ' should <= handle_char_length(' , tracer_char_length , ')' else if ( trace_num == 0 ) then trace_num = trace_num + 1 trace_items ( trace_num ) = info else if ( trim ( get_head ( trace_items ( trace_num ))) == trim ( get_head ( trim ( info )))) then trace_items ( trace_num ) = info if ( trace_realtime_tag ) backspace ( 777 ) else trace_level = trace_level + 1 if ( trace_num == max_trace_num ) then !exceeds boundary allocate ( expand_temp ( max_trace_num )) expand_temp = trace_items deallocate ( trace_items ) allocate ( trace_items ( 2 * max_trace_num )) trace_items ( 1 : max_trace_num ) = expand_temp deallocate ( expand_temp ) max_trace_num = 2 * max_trace_num end if trace_num = trace_num + 1 trace_items ( trace_num ) = info end if end if if ( trace_realtime_tag ) write ( 777 , * ) repeat ( '-' , 2 * trace_level ) // trim ( trace_items ( trace_num )) if ( trace_print_tag ) write ( * , * ) repeat ( '-' , 2 * trace_level ) // trim ( trace_items ( trace_num )) end if end if end subroutine subroutine end_trace () if ( trace_enabled ) then trace_level = trace_level - 1 trace_num = trace_num - 1 if ( trace_realtime_tag ) backspace ( 777 ) if ( trace_num < 0 ) then write ( * , * ) 'End_trace not paired with trace.' stop end if end if end subroutine subroutine print_trace () integer :: i if ( trace_enabled ) then write ( * , * ) '---------------------------------' write ( * , * ) 'The trace of current position is:' do i = 1 , trace_num write ( * , * ) repeat ( '-' , 2 * i ) // trim ( trace_items ( i )) end do write ( * , * ) '---------------------------------' end if end subroutine character ( len = tracer_char_length ) function get_head ( full ) result ( head ) character ( len =* ), intent ( in ) :: full integer :: point_pos if ( len ( full ) > tracer_char_length ) then write ( * , * ) 'Length of input string(' , len ( full ), ') should <= handle_char_length(' , tracer_char_length , ')' stop else point_pos = index ( full , '.' ) if ( point_pos > 0 ) then head = full ( 1 : point_pos ) else head = full end if end if end function subroutine trace_test () call enable_tracer () call print_tracer () call trace ( '1.a' ) call trace ( '1.b' ) call trace ( '11.a' ) call trace ( '11.b' ) call trace ( '111.a' ) call end_trace () call trace ( '11.c' ) call end_trace () call trace ( '12.a' ) call trace ( '12.b' ) call trace ( '121.a' ) call trace ( '121.b' ) call end_trace () call trace ( '12.c' ) call end_trace () call trace ( '1.c' ) call end_trace () end subroutine end module","tags":"","loc":"sourcefile/tracer.f90.html"},{"title":"lattice_clt.f90 – TNSG","text":"This file depends on sourcefile~~lattice_clt.f90~~EfferentGraph sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~error.f90 error.f90 sourcefile~lattice_clt.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~lattice_clt.f90->sourcefile~string.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~lattice.f90->sourcefile~error.f90 sourcefile~lattice.f90->sourcefile~string.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~lattice.f90->sourcefile~mpi_info.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~tn_tensor.f90->sourcefile~error.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~stack.f90 stack.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~stack.f90->sourcefile~error.f90 var pansourcefilelattice_cltf90EfferentGraph = svgPanZoom('#sourcefilelattice_cltf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tensor_network_nesting Source Code lattice_clt.f90 Source Code module tensor_network_nesting use tensor_network use tensor_type use error use tools use string use tn_tensor_type implicit none private type , extends ( lattice ) :: nest_lattice private class ( lattice ), pointer , public :: lat_pre ! old lattice type ( tensor ), allocatable :: ten_res (:,:) ! results of clusters type ( tensor ), allocatable :: ten_bak (:,:) ! back up of tensors type ( path ), allocatable :: cluster (:,:) ! paths of clusters integer , allocatable :: pos2clt (:,:,:) ! ori pos to clt pos logical , allocatable :: to_calc (:,:) ! to calc tag logical , allocatable :: backed_up (:,:) ! backed up tag contains private procedure , public :: initialize_nest procedure , public :: generate procedure , public :: set_cluster procedure , public :: set_tensor_nest procedure :: set_tensor_inner procedure , public :: get_outer_pos procedure , public :: calc_except procedure , public :: re_calc procedure , public :: restore_nest procedure , public :: check_exist_nest procedure , public :: in_clt procedure , public :: clt_pos procedure :: nest_name_inner procedure :: nest_name end type integer :: test_lattice_clt = 0 public nest_lattice , test_lattice_clt contains subroutine initialize_nest ( LC , L ) class ( nest_lattice ), intent ( inout ) :: LC class ( lattice ), target , intent ( inout ) :: L integer :: L1 , L2 , i , j LC % lat_pre => L call LC % lat_pre % get_size ( L1 , L2 ) allocate ( LC % ten_res ( L1 , L2 )) allocate ( LC % ten_bak ( L1 , L2 )) allocate ( LC % cluster ( L1 , L2 )) do i = 1 , L1 do j = 1 , L2 call LC % cluster ( i , j )% belong ( LC % lat_pre ) end do end do allocate ( LC % to_calc ( L1 , L2 )) LC % to_calc = . false . allocate ( LC % backed_up ( L1 , L2 )) LC % backed_up = . false . allocate ( LC % pos2clt ( L1 , L2 , 2 )) LC % pos2clt =- 1 end subroutine subroutine generate ( LC ) class ( nest_lattice ), intent ( inout ) :: LC integer :: L1 , L2 , i , j , m , n call LC % lat_pre % get_size ( L1 , L2 ) call LC % lattice % initialize ( LC % lat_pre % get_name () + '_nest' , L1 , L2 , LC % lat_pre % get_max_nb_num ()) do i = 1 , L1 do j = 1 , L2 if ( LC % cluster ( i , j )% get_num () > 0 ) then call calc_cluster ( LC ,[ i , j ]) call LC % lattice % add ([ i , j ], LC % lattice % get_name () + i + '_' + j , LC % ten_res ( i , j )) call LC % cluster ( i , j )% set_name ( LC % lattice % get_name () + i + '_' + j ) !call LC%cluster(i,j)%draw('cl'+i+j) end if end do end do do i = 1 , L1 do j = 1 , L2 if ( LC % lat_pre % check_exist ([ i , j ])) then if ( LC % pos2clt ( i , j , 1 ) < 0 ) then call LC % lattice % add ([ i , j ], LC % lat_pre ,[ i , j ]) call LC % lattice % set_contag ([ i , j ], LC % lat_pre % get_contag ([ i , j ])) end if end if end do end do !call LC%lattice%draw('lat') call LC % lattice % set_bond_as ( LC % lat_pre , LC % cluster ) !call LC%lattice%draw('lat') end subroutine subroutine set_cluster ( LC , pos_clt , pos_site ) class ( nest_lattice ), intent ( inout ) :: LC integer , intent ( in ) :: pos_clt ( 2 ), pos_site ( 2 ) call LC % cluster ( pos_clt ( 1 ), pos_clt ( 2 ))% add ( pos_site ) LC % pos2clt ( pos_site ( 1 ), pos_site ( 2 ),:) = pos_clt end subroutine subroutine calc_cluster ( LC , pos ) class ( nest_lattice ), intent ( inout ) :: LC integer , intent ( in ) :: pos ( 2 ) type ( tn_tensor ) :: result call result % belong ( LC % lat_pre ) call result % absorb_all ( LC % cluster ( pos ( 1 ), pos ( 2 ))) LC % ten_res ( pos ( 1 ), pos ( 2 )) = result end subroutine subroutine set_tensor_nest ( LC , tenname , tenp , to_calc ) class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: tenname type ( tensor ), intent ( inout ) :: tenp logical , intent ( in ) :: to_calc character ( len = max_char_length ) :: name_last , name_this if ( LC % lattice % check_exist ( tenname )) then call LC % lattice % set_tensor ( tenname , tenp ) !A->B->C, when B->D, A should also ->D else call LC % set_tensor_inner ( tenname , name_last , name_this , tenp , to_calc ) end if end subroutine subroutine set_tensor_inner ( LC , name , name_last , name_this , tenp , to_calc ) class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name type ( tensor ), intent ( inout ) :: tenp logical , intent ( in ) :: to_calc character ( len =* ), intent ( inout ) :: name_last , name_this ! name_last : cluster in lat_pre; name_this:  cluster in lattice integer :: i , j , pos ( 2 ) if ( LC % lat_pre % check_exist ( name )) then name_last = name call LC % lat_pre % set_tensor ( name_last , tenp ) else select type ( oldlat => LC % lat_pre ) type is ( lattice ) call wc_error_stop ( 'lattice_clt.nest_name_inner' , 'Site with name ' // trim ( name ) // ' not found in nesting search.' ) type is ( nest_lattice ) call oldlat % nest_name_inner ( name , name_last , name_this ) name_last = name_this end select end if if ( LC % in_clt ( name_last )) then pos = ( LC % clt_pos ( name_last )) name_this = LC % cluster ( pos ( 1 ), pos ( 2 ))% get_name () else name_this = name_last end if pos = LC % lat_pre % get_pos ( name_last ) i = LC % pos2clt ( pos ( 1 ), pos ( 2 ), 1 ) j = LC % pos2clt ( pos ( 1 ), pos ( 2 ), 2 ) LC % to_calc ( i , j ) = to_calc end subroutine subroutine re_calc ( LC , back_up ) class ( nest_lattice ), intent ( inout ) :: LC logical , intent ( in ) :: back_up integer :: L1 , L2 , i , j select type ( oldlat => LC % lat_pre ) type is ( nest_lattice ) call oldlat % re_calc ( back_up ) end select call LC % lat_pre % get_size ( L1 , L2 ) do i = 1 , L1 do j = 1 , L2 if ( LC % to_calc ( i , j )) then if ( back_up ) then LC % backed_up ( i , j ) = . true . LC % ten_bak ( i , j ) = LC % ten_res ( i , j ) end if call calc_cluster ( LC ,[ i , j ]) end if end do end do LC % to_calc = . false . end subroutine subroutine restore_nest ( LC ) class ( nest_lattice ), intent ( inout ) :: LC integer :: L1 , L2 , i , j select type ( oldlat => LC % lat_pre ) type is ( nest_lattice ) call oldlat % restore_nest () end select call LC % lat_pre % get_size ( L1 , L2 ) do i = 1 , L1 do j = 1 , L2 if ( LC % backed_up ( i , j )) LC % ten_res ( i , j ) = LC % ten_bak ( i , j ) end do end do LC % backed_up = . false . end subroutine function get_outer_pos ( LC , name ) result ( pos ) ! pos in the outest lat class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name character ( len = max_char_length ) :: name_last , name_this integer :: pos ( 2 ) integer :: L1 , L2 , i , j if ( LC % lattice % check_exist ( name )) then pos = LC % lattice % get_pos ( name ) else name_last = '' name_this = '' call LC % nest_name_inner ( name , name_last , name_this ) pos = LC % lattice % get_pos ( name_this ) end if end function subroutine calc_except ( LC , ten , name ) class ( nest_lattice ), intent ( inout ) :: LC type ( tn_tensor ), intent ( inout ) :: ten character ( len =* ), intent ( in ) :: name character ( len = max_char_length ) :: name2 integer :: i , j , pos ( 2 ) if (. not . LC % lattice % check_exist ( name )) then name2 = LC % nest_name ( name ) ! name2 in lat_pre contains name. if name not found in a nesting search report error pos = LC % clt_pos ( name2 ) call ten % belong ( LC % lat_pre ) call ten % take_except ( LC % cluster ( pos ( 1 ), pos ( 2 ))) call ten % absorb_except ( name2 , LC % cluster ( pos ( 1 ), pos ( 2 ))) if ( name /= name2 ) then select type ( oldlat => LC % lat_pre ) type is ( nest_lattice ) call oldlat % calc_except ( ten , name ) ! lat_pre is a nesting lat and doesn't contains name end select end if end if end subroutine recursive function check_exist_nest ( LC , name ) result ( res ) class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name logical :: res res = LC % lattice % check_exist ( name ) select type ( oldlat => LC % lat_pre ) type is ( lattice ) res = res . or . oldlat % check_exist ( name ) type is ( nest_lattice ) res = res . or . oldlat % check_exist_nest ( name ) end select end function function in_clt ( LC , name ) result ( res ) ! not nesting class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name integer :: pos ( 2 ) logical :: res if ( LC % lat_pre % check_exist ( name )) then pos = LC % lat_pre % get_pos ( name ) res = ( LC % pos2clt ( pos ( 1 ), pos ( 2 ), 1 ) > 0 ) else call wc_error_stop ( 'lattice_clt.in_clt' , 'Site with name ' // trim ( name ) // ' not found.' ) end if end function function clt_pos ( LC , name ) result ( res ) ! not nesting class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name integer :: res ( 2 ), pos ( 2 ) if ( LC % lat_pre % check_exist ( name )) then pos = LC % lat_pre % get_pos ( name ) res = LC % pos2clt ( pos ( 1 ), pos ( 2 ),:) else call wc_error_stop ( 'lattice_clt.clt_pos' , 'Site with name ' // trim ( name ) // ' not found.' ) end if end function function nest_name ( LC , name ) result ( res ) class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name character ( len = max_char_length ) :: res , name_this name_this = '' res = '' call LC % nest_name_inner ( name , res , name_this ) end function recursive subroutine nest_name_inner ( LC , name , name_last , name_this ) class ( nest_lattice ), intent ( inout ) :: LC character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( inout ) :: name_last , name_this ! name_last : cluster in lat_pre; name_this:  cluster in lattice integer :: pos ( 2 ) if ( LC % lat_pre % check_exist ( name )) then name_last = name else select type ( oldlat => LC % lat_pre ) type is ( lattice ) call wc_error_stop ( 'lattice_clt.nest_name_inner' , 'Site with name ' // trim ( name ) // ' not found in nesting search.' ) type is ( nest_lattice ) call oldlat % nest_name_inner ( name , name_last , name_this ) name_last = name_this end select end if if ( LC % in_clt ( name_last )) then pos = ( LC % clt_pos ( name_last )) name_this = LC % cluster ( pos ( 1 ), pos ( 2 ))% get_name () else name_this = name_last end if end subroutine end module","tags":"","loc":"sourcefile/lattice_clt.f90.html"},{"title":"dictionary.f90 – TNSG","text":"This file depends on sourcefile~~dictionary.f90~~EfferentGraph sourcefile~dictionary.f90 dictionary.f90 sourcefile~error.f90 error.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~dictionary.f90~~AfferentGraph sourcefile~dictionary.f90 dictionary.f90 sourcefile~paralist.f90 paralist.f90 sourcefile~paralist.f90->sourcefile~dictionary.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_dictionary Source Code dictionary.f90 Source Code module mod_dictionary use error use string use tensor_type implicit none private ! type: int=1 dbl=2 cmplx=3 char=4 logi=5 ten=6 int_ary=7 dbl_ary=8 char_ary=9 logi_ary=10 integer , parameter :: itemmaxn = 100 integer , parameter :: lenmax = 10 integer , parameter :: type_num = 10 character ( len = 10 ), parameter :: type_name ( type_num ) = [ 'integer   ' , 'double    ' , 'complex   ' ,& 'character ' , 'logical   ' , 'tensor    ' , 'int_ary   ' , 'dbl_ary   ' , 'char_ary  ' , 'logi_ary  ' ] character ( len = 2 ), parameter :: type_abbr ( type_num ) = [ 'i ' , 'd ' , 'z ' , 'a ' , 'l ' , 't ' , 'mi' , 'md' , 'ma' , 'ml' ] type dictionary private integer , allocatable :: int_val (:) integer , allocatable :: int_ary_val (:,:) integer , allocatable :: int_ary_len (:) real ( 8 ), allocatable :: double_val (:) real ( 8 ), allocatable :: dbl_ary_val (:,:) integer , allocatable :: dbl_ary_len (:) complex ( 8 ), allocatable :: com_val (:) character ( len = max_char_length ), allocatable :: char_val (:) character ( len = max_char_length ), allocatable :: char_ary_val (:,:) integer , allocatable :: char_ary_len (:) logical , allocatable :: logi_val (:) logical , allocatable :: logi_ary_val (:,:) integer , allocatable :: logi_ary_len (:) type ( tensor ), allocatable :: ten_val (:) character ( len = max_char_length ), allocatable :: names (:,:) integer , allocatable :: itemcurn (:) logical :: inited = . false . contains private procedure :: init procedure , public :: read procedure , public :: print procedure , public :: get_names procedure , public :: sub_name procedure , public :: sub_val procedure , public :: clean procedure , public :: rename procedure :: isetvalue , dsetvalue , zsetvalue , asetvalue , lsetvalue , tsetvalue ,& misetvalue , mdsetvalue , masetvalue , mlsetvalue generic , public :: setvalue => isetvalue , dsetvalue , zsetvalue , asetvalue , lsetvalue , tsetvalue ,& misetvalue , mdsetvalue , masetvalue , mlsetvalue procedure :: igetvalue , dgetvalue , zgetvalue , agetvalue , lgetvalue , tgetvalue ,& migetvalue , mdgetvalue , magetvalue , mlgetvalue generic , public :: getvalue => igetvalue , dgetvalue , zgetvalue , agetvalue , lgetvalue , tgetvalue ,& migetvalue , mdgetvalue , magetvalue , mlgetvalue procedure :: insert_int , insert_dbl , insert_com , insert_char , insert_logi , insert_ten ,& insert_int_ary , insert_dbl_ary , insert_char_ary , insert_logi_ary generic , public :: insert => insert_int , insert_dbl , insert_com , insert_char , insert_logi , insert_ten ,& insert_int_ary , insert_dbl_ary , insert_char_ary , insert_logi_ary procedure , public :: delete procedure , public :: ii , di , zi , ai , li , ti , mii , mdi , mai , mli procedure , public :: append procedure , public :: check_contain procedure :: find procedure , public :: search procedure :: append_by_name end type public dictionary contains subroutine init ( D ) implicit none class ( dictionary ), intent ( inout ) :: D allocate ( D % int_val ( itemmaxn )) allocate ( D % double_val ( itemmaxn )) allocate ( D % com_val ( itemmaxn )) allocate ( D % char_val ( itemmaxn )) allocate ( D % logi_val ( itemmaxn )) allocate ( D % ten_val ( itemmaxn )) allocate ( D % int_ary_val ( lenmax , itemmaxn )) allocate ( D % int_ary_len ( itemmaxn )) allocate ( D % dbl_ary_val ( lenmax , itemmaxn )) allocate ( D % dbl_ary_len ( itemmaxn )) allocate ( D % char_ary_val ( lenmax , itemmaxn )) allocate ( D % char_ary_len ( itemmaxn )) allocate ( D % logi_ary_val ( lenmax , itemmaxn )) allocate ( D % logi_ary_len ( itemmaxn )) allocate ( D % names ( itemmaxn , type_num )) allocate ( D % itemcurn ( type_num )) D % inited = . true . call D % clean () end subroutine subroutine clean ( D ) class ( dictionary ), intent ( inout ) :: D integer :: i if (. not . D % inited ) call D % init () D % names = '' D % itemcurn = 0 D % int_val = 0 D % double_val = 0 d0 D % com_val = 0 d0 D % char_val = '' D % logi_val = . false . do i = 1 , D % itemcurn ( 6 ) call D % ten_val ( i )% deallocate () end do D % int_ary_val = 0 D % int_ary_len = 0 D % dbl_ary_val = 0 d0 D % dbl_ary_len = 0 D % char_ary_val = '' D % char_ary_len = 0 D % logi_ary_val = . false . D % logi_ary_len = 0 end subroutine function get_names ( D ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len = max_char_length ), allocatable :: res (:) integer :: num , type allocate ( res ( sum ( D % itemcurn ))) num = 0 do type = 1 , type_num if ( D % itemcurn ( type ) > 0 ) then res ( num + 1 : num + D % itemcurn ( type )) = D % names (: D % itemcurn ( type ), type ) num = num + D % itemcurn ( type ) end if end do end function function sub_val ( D , value ) result ( res ) class ( dictionary ), intent ( in ) :: D type ( dictionary ) :: res character ( len =* ), intent ( in ) :: value integer :: i call res % init () if (. not . D % inited ) return do i = 1 , D % itemcurn ( 4 ) if ( D % char_val ( i ) == value ) then call res % insert ( D % names ( i , 4 ), value ) end if end do end function subroutine insert_int ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: value integer :: type if (. not . D % inited ) call D % init () type = 1 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of integer parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % int_val ( D % itemcurn ( type )) = value D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_int_ary ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: value (:) integer :: type if (. not . D % inited ) call D % init () type = 7 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of integer_ary parameter reaches limit' ) else if ( size ( value ) > lenmax ) then call wc_error_stop ( 'para-insert' , 'length of integer_ary parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % int_ary_val (: size ( value ), D % itemcurn ( type )) = value D % int_ary_len ( D % itemcurn ( type )) = size ( value ) D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_dbl ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), intent ( in ) :: value integer :: type if (. not . D % inited ) call D % init () type = 2 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of real parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % double_val ( D % itemcurn ( type )) = value D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_dbl_ary ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), intent ( in ) :: value (:) integer :: type if (. not . D % inited ) call D % init () type = 8 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of dbl_ary parameter reaches limit' ) else if ( size ( value ) > lenmax ) then call wc_error_stop ( 'para-insert' , 'length of dbl_ary parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % dbl_ary_val (: size ( value ), D % itemcurn ( type )) = value D % dbl_ary_len ( D % itemcurn ( type )) = size ( value ) D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_com ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name complex ( 8 ), intent ( in ) :: value integer :: type if (. not . D % inited ) call D % init () type = 3 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of complex parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % com_val ( D % itemcurn ( type )) = value D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_char ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value integer :: type if (. not . D % inited ) call D % init () type = 4 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of character parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % char_val ( D % itemcurn ( type )) = value D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_char_ary ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: value (:) integer :: type if (. not . D % inited ) call D % init () type = 9 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of character parameter reaches limit' ) else if ( size ( value ) > lenmax ) then call wc_error_stop ( 'para-insert' , 'length of character_ary parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % char_ary_val (: size ( value ), D % itemcurn ( type )) = value D % char_ary_len ( D % itemcurn ( type )) = size ( value ) D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_logi ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: value integer :: type if (. not . D % inited ) call D % init () type = 5 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of logical parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % logi_val ( D % itemcurn ( type )) = value D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_logi_ary ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: value (:) integer :: type if (. not . D % inited ) call D % init () type = 10 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of logical_ary parameter reaches limit' ) else if ( size ( value ) > lenmax ) then call wc_error_stop ( 'para-insert' , 'length of logical_ary parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % logi_ary_val (: size ( value ), D % itemcurn ( type )) = value D % logi_ary_len ( D % itemcurn ( type )) = size ( value ) D % names ( D % itemcurn ( type ), type ) = name end if end subroutine subroutine insert_ten ( D , name , value ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name type ( tensor ), intent ( in ) :: value integer :: type if (. not . D % inited ) call D % init () type = 6 if ( D % itemcurn ( type ) == itemmaxn ) then call wc_error_stop ( 'para-insert' , 'num of logical parameter reaches limit' ) else D % itemcurn ( type ) = D % itemcurn ( type ) + 1 D % ten_val ( D % itemcurn ( type )) = value D % names ( D % itemcurn ( type ), type ) = name end if end subroutine function ii ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name integer :: res call D % igetvalue ( name , res ) end function function mii ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name integer , allocatable :: res (:) call D % migetvalue ( name , res ) end function function di ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ) :: res call D % dgetvalue ( name , res ) end function function mdi ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), allocatable :: res (:) call D % mdgetvalue ( name , res ) end function function zi ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name complex ( 8 ) :: res call D % zgetvalue ( name , res ) end function function ai ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name character ( len = max_char_length ) :: res call D % agetvalue ( name , res ) end function function mai ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name character ( len = max_char_length ), allocatable :: res (:) call D % magetvalue ( name , res ) end function function li ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name logical :: res call D % lgetvalue ( name , res ) end function function mli ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name logical , allocatable :: res (:) call D % mlgetvalue ( name , res ) end function function ti ( D , name ) result ( res ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name type ( tensor ) :: res call D % tgetvalue ( name , res ) end function subroutine search ( D , name , type , pos , existed ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( out ) :: type , pos logical , intent ( out ) :: existed integer :: i type =- 1 pos =- 1 existed = . false . if ( D % inited ) then do type = 1 , type_num do i = 1 , D % itemcurn ( type ) if ( D % names ( i , type ) == name ) then pos = i existed = . true . end if end do if ( existed ) exit end do end if end subroutine subroutine find ( D , name , type , pos ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( out ) :: type , pos logical :: existed integer :: i call search ( D , name , type , pos , existed ) if (. not . existed ) call wc_error_stop ( 'dictionary.find' , trim ( name ) // ' not found in the paralist.' ) end subroutine function check_contain ( D , name ) result ( res ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name logical :: res integer :: type , pos call D % search ( name , type , pos , res ) end function subroutine delete ( D , name ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'integer' ) D % int_val ( pos : itemmaxn - 1 ) = D % int_val ( pos + 1 : itemmaxn ) case ( 'double' ) D % double_val ( pos : itemmaxn - 1 ) = D % double_val ( pos + 1 : itemmaxn ) case ( 'complex' ) D % com_val ( pos : itemmaxn - 1 ) = D % com_val ( pos + 1 : itemmaxn ) case ( 'character' ) D % char_val ( pos : itemmaxn - 1 ) = D % char_val ( pos + 1 : itemmaxn ) case ( 'logical' ) D % logi_val ( pos : itemmaxn - 1 ) = D % logi_val ( pos + 1 : itemmaxn ) case ( 'tensor' ) D % ten_val ( pos : itemmaxn - 1 ) = D % ten_val ( pos + 1 : itemmaxn ) case ( 'int_ary' ) D % int_ary_val (:, pos : itemmaxn - 1 ) = D % int_ary_val (:, pos + 1 : itemmaxn ) D % int_ary_len ( pos : itemmaxn - 1 ) = D % int_ary_len ( pos + 1 : itemmaxn ) case ( 'dbl_ary' ) D % dbl_ary_val (:, pos : itemmaxn - 1 ) = D % dbl_ary_val (:, pos + 1 : itemmaxn ) D % dbl_ary_len ( pos : itemmaxn - 1 ) = D % dbl_ary_len ( pos + 1 : itemmaxn ) case ( 'char_ary' ) D % char_ary_val (:, pos : itemmaxn - 1 ) = D % char_ary_val (:, pos + 1 : itemmaxn ) D % char_ary_len ( pos : itemmaxn - 1 ) = D % char_ary_len ( pos + 1 : itemmaxn ) case ( 'logi_ary' ) D % logi_ary_val (:, pos : itemmaxn - 1 ) = D % logi_ary_val (:, pos + 1 : itemmaxn ) D % logi_ary_len ( pos : itemmaxn - 1 ) = D % logi_ary_len ( pos + 1 : itemmaxn ) end select D % names ( pos : itemmaxn - 1 , type ) = D % names ( pos + 1 : itemmaxn , type ) D % itemcurn ( type ) = D % itemcurn ( type ) - 1 end subroutine subroutine isetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: val logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed integer :: type , pos add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'integer' ) D % int_val ( pos ) = val case ( 'double' ) D % double_val ( pos ) = val case ( 'complex' ) D % com_val ( pos ) = val case ( 'character' ) D % char_val ( pos ) = str ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from int to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_int ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine misetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: val (:) logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed integer :: type , pos if ( size ( val ) > lenmax ) then call wc_error_stop ( 'para-setvalue' , 'length of int_ary parameter reaches limit' ) end if add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'int_ary' ) D % int_ary_val (: size ( val ), pos ) = val D % int_ary_len ( pos ) = size ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from int_ary to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_int_ary ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine dsetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), intent ( in ) :: val integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'integer' ) D % int_val ( pos ) = val case ( 'double' ) D % double_val ( pos ) = val case ( 'complex' ) D % com_val ( pos ) = val case ( 'character' ) D % char_val ( pos ) = str ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from real to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_dbl ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine mdsetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), intent ( in ) :: val (:) integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed if ( size ( val ) > lenmax ) then call wc_error_stop ( 'para-setvalue' , 'length of dbl_ary parameter reaches limit' ) end if add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'dbl_ary' ) D % dbl_ary_val (: size ( val ), pos ) = val D % dbl_ary_len ( pos ) = size ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from dbl_ary to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_dbl_ary ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine zsetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name complex ( 8 ), intent ( in ) :: val integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'integer' ) D % int_val ( pos ) = val case ( 'double' ) D % double_val ( pos ) = val case ( 'complex' ) D % com_val ( pos ) = val case ( 'character' ) D % char_val ( pos ) = str ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from complex to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_com ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine asetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'character' ) D % char_val ( pos ) = val case default call wc_error_stop ( 'para-setvalue' , 'cannot change from char to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_char ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine masetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val (:) integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed if ( size ( val ) > lenmax ) then call wc_error_stop ( 'para-setvalue' , 'length of char_ary parameter reaches limit' ) end if add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'char_ary' ) D % char_ary_val (: size ( val ), pos ) = val D % char_ary_len ( pos ) = size ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from char_ary to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_char_ary ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine lsetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: val integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'character' ) D % char_val ( pos ) = val case ( 'logical' ) D % logi_val ( pos ) = val case default call wc_error_stop ( 'para-setvalue' , 'cannot change from logical to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_logi ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine mlsetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: val (:) integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed if ( size ( val ) > lenmax ) then call wc_error_stop ( 'para-setvalue' , 'length of logi_ary parameter reaches limit' ) end if add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then select case ( type_name ( type )) case ( 'logi_ary' ) D % logi_ary_val (: size ( val ), pos ) = val D % logi_ary_len ( pos ) = size ( val ) case default call wc_error_stop ( 'para-setvalue' , 'cannot change from logi_ary to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_logi_ary ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine tsetvalue ( D , name , val , add_tag ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name type ( tensor ), intent ( in ) :: val integer :: type , pos logical , intent ( in ), optional :: add_tag logical :: add_tag_ , existed add_tag_ = . false . if ( present ( add_tag )) then add_tag_ = add_tag end if call D % search ( name , type , pos , existed ) if ( existed ) then call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'tensor' ) D % ten_val ( pos ) = val case default call wc_error_stop ( 'para-setvalue' , 'cannot change from tensor to ' // trim ( type_name ( type ))) end select else if ( add_tag_ ) then call D % insert_ten ( name , val ) else call wc_error_stop ( 'para-setvalue' , 'Var ' // trim ( name ) // ' not existes' ) end if end if end subroutine subroutine igetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( inout ) :: val integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'integer' ) val = D % int_val ( pos ) case ( 'double' ) val = D % double_val ( pos ) case ( 'complex' ) val = D % com_val ( pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to int' ) end select end subroutine subroutine migetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name integer , intent ( inout ), allocatable :: val (:) integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'int_ary' ) allocate ( val ( D % int_ary_len ( pos ))) val = D % int_ary_val (: D % int_ary_len ( pos ), pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to int_ary' ) end select end subroutine subroutine dgetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), intent ( inout ) :: val integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'integer' ) val = D % int_val ( pos ) case ( 'double' ) val = D % double_val ( pos ) case ( 'complex' ) val = D % com_val ( pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to real' ) end select end subroutine subroutine mdgetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name real ( 8 ), intent ( inout ), allocatable :: val (:) integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'dbl_ary' ) allocate ( val ( D % dbl_ary_len ( pos ))) val = D % dbl_ary_val (: D % dbl_ary_len ( pos ), pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to dbl_ary' ) end select end subroutine subroutine zgetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name complex ( 8 ), intent ( inout ) :: val integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'integer' ) val = D % int_val ( pos ) case ( 'double' ) val = D % double_val ( pos ) case ( 'complex' ) val = D % com_val ( pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to complex' ) end select end subroutine subroutine agetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( inout ) :: val integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'integer' ) val = str ( D % int_val ( pos )) case ( 'double' ) val = str ( D % double_val ( pos )) case ( 'complex' ) val = str ( D % com_val ( pos )) case ( 'character' ) val = D % char_val ( pos ) case ( 'logical' ) val = str ( D % logi_val ( pos )) case ( 'char_ary' ) val = str ( D % char_ary_val (:, pos )) case default write ( * , * ) type call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to char' ) end select end subroutine subroutine magetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name character ( len = max_char_length ), intent ( inout ), allocatable :: val (:) integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'char_ary' ) allocate ( val ( D % char_ary_len ( pos ))) val = D % char_ary_val (: D % char_ary_len ( pos ), pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to char_ary' ) end select end subroutine subroutine lgetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name logical , intent ( inout ) :: val integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'logical' ) val = D % logi_val ( pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to logical' ) end select end subroutine subroutine mlgetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name logical , intent ( inout ), allocatable :: val (:) integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'logi_ary' ) allocate ( val ( D % logi_ary_len ( pos ))) val = D % logi_ary_val (: D % logi_ary_len ( pos ), pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to logi_ary' ) end select end subroutine subroutine tgetvalue ( D , name , val ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: name type ( tensor ), intent ( inout ) :: val integer :: type , pos call D % find ( name , type , pos ) select case ( type_name ( type )) case ( 'tensor' ) val = D % ten_val ( pos ) case default call wc_error_stop ( 'para-getvalue' , 'cannot change from ' // trim ( type_name ( type )) // '  to tensor' ) end select end subroutine subroutine rename ( D , name , new_name ) class ( dictionary ), intent ( inout ) :: D character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( inout ) :: new_name integer :: type , pos call D % find ( name , type , pos ) D % names ( pos , type ) = new_name end subroutine subroutine append_by_name ( D , D2 , names ) class ( dictionary ), intent ( inout ) :: D class ( dictionary ), intent ( in ) :: D2 character ( len =* ), intent ( in ) :: names (:) type ( dictionary ) :: out_list integer :: i , type , pos do i = 1 , size ( names ) call D2 % find ( names ( i ), type , pos ) select case ( type_name ( type )) case ( 'integer' ) call D % insert ( names ( i ), D2 % int_val ( pos )) case ( 'int_ary' ) call D % insert ( names ( i ), D2 % int_ary_val (: D2 % int_ary_len ( pos ), pos )) case ( 'double' ) call D % insert ( names ( i ), D2 % double_val ( pos )) case ( 'dbl_ary' ) call D % insert ( names ( i ), D2 % dbl_ary_val (: D2 % dbl_ary_len ( pos ), pos )) case ( 'complex' ) call D % insert ( names ( i ), D2 % com_val ( pos )) case ( 'character' ) call D % insert ( names ( i ), D2 % char_val ( pos )) case ( 'char_ary' ) call D % insert ( names ( i ), D2 % char_ary_val (: D2 % char_ary_len ( pos ), pos )) case ( 'logical' ) call D % insert ( names ( i ), D2 % logi_val ( pos )) case ( 'logi_ary' ) call D % insert ( names ( i ), D2 % logi_ary_val (: D2 % logi_ary_len ( pos ), pos )) case ( 'tensor' ) call D % insert ( names ( i ), D2 % ten_val ( pos )) end select end do end subroutine function sub_name ( D , names ) result ( out_list ) class ( dictionary ), intent ( in ) :: D character ( len =* ), intent ( in ) :: names (:) type ( dictionary ) :: out_list if ( sum ( D % itemcurn ) > 0 ) then call out_list % append_by_name ( D , names ) end if end function subroutine print ( D , unit , end_tag_ ) class ( dictionary ), intent ( in ) :: D integer , intent ( in ), optional :: unit logical , intent ( in ), optional :: end_tag_ logical :: end_tag integer :: k , i , type character ( len = max_char_length + 20 ) :: formatl end_tag = . true . if ( present ( end_tag_ )) end_tag = end_tag_ if (. not . D % inited ) then if ( present ( unit ) . and . end_tag ) write ( unit , * ) '/' return end if do type = 1 , type_num do k = 1 , D % itemcurn ( type ) formatl = type_abbr ( type ) formatl ( 4 :) = D % names ( k , type ) select case ( type_name ( type )) case ( 'integer' ) formatl ( 20 :) = str ( D % int_val ( k )) case ( 'double' ) formatl ( 20 :) = str ( D % double_val ( k )) case ( 'complex' ) formatl ( 20 :) = str ( D % com_val ( k )) case ( 'character' ) formatl ( 20 :) = D % char_val ( k ) case ( 'logical' ) formatl ( 20 :) = str ( D % logi_val ( k )) case ( 'tensor' ) formatl ( 20 :) = 'printed below' case ( 'int_ary' ) formatl ( 20 :) = str ( D % int_ary_len ( k )) // ' items:' case ( 'dbl_ary' ) formatl ( 20 :) = str ( D % dbl_ary_len ( k )) // ' items:' case ( 'char_ary' ) formatl ( 20 :) = str ( D % char_ary_len ( k )) // ' items:' case ( 'logi_ary' ) formatl ( 20 :) = str ( D % logi_ary_len ( k )) // ' items:' end select if ( present ( unit )) then write ( unit , * ) trim ( formatl ) else call writemess ( formatl ) end if select case ( type_name ( type )) case ( 'tensor' ) if ( present ( unit )) then call D % ten_val ( k )% write ( unit ) else call D % ten_val ( k )% print () end if case ( 'int_ary' ) do i = 1 , D % int_ary_len ( k ) formatl = '' formatl ( 20 :) = str ( D % int_ary_val ( i , k )) if ( present ( unit )) then write ( unit , * ) trim ( formatl ) else call writemess ( formatl ) end if end do case ( 'dbl_ary' ) do i = 1 , D % dbl_ary_len ( k ) formatl = '' formatl ( 20 :) = str ( D % dbl_ary_val ( i , k )) if ( present ( unit )) then write ( unit , * ) trim ( formatl ) else call writemess ( formatl ) end if end do case ( 'char_ary' ) do i = 1 , D % char_ary_len ( k ) formatl = '' formatl ( 20 :) = D % char_ary_val ( i , k ) if ( present ( unit )) then write ( unit , * ) trim ( formatl ) else call writemess ( formatl ) end if end do case ( 'logi_ary' ) do i = 1 , D % logi_ary_len ( k ) formatl = '' formatl ( 20 :) = str ( D % logi_ary_val ( i , k )) if ( present ( unit )) then write ( unit , * ) trim ( formatl ) else call writemess ( formatl ) end if end do end select end do end do if ( present ( unit ) . and . end_tag ) write ( unit , * ) '/' end subroutine subroutine read ( G , unit ) class ( dictionary ), intent ( inout ) :: G integer , intent ( in ) :: unit character ( len = max_char_length ) :: cur_class character ( len = 10 * max_char_length ) :: line character ( len = 4 ) :: type integer :: io_stat , len , i , pos character ( len = max_char_length ) :: no_use , cur_name integer :: ival real ( 8 ) :: dval complex ( 8 ) :: zval character ( len = max_char_length ) :: aval logical :: lval type ( tensor ) :: tval integer , allocatable :: mival (:) real ( 8 ), allocatable :: mdval (:) character ( len = max_char_length ), allocatable :: maval (:) logical , allocatable :: mlval (:) if (. not . G % inited ) call G % init () call G % clean () read ( unit , '(A)' , IOSTAT = io_stat ) line do while (. true .) if ( io_stat /= 0 ) call wc_error_stop ( 'dictionary.read' , 'EOF before identifier \"/\"' ) line = adjustl ( line ) type = '' if ( len_trim ( line ) > 0 ) then pos = scan ( line , ' ' // achar ( 9 )) ! achar(9) for tab type = line ( 1 : pos - 1 ) end if select case ( type ) case ( 'i' ) read ( line ( pos :), * ) cur_name , ival call G % insert ( cur_name , ival ) case ( 'd' ) read ( line ( pos :), * ) cur_name , dval call G % insert ( cur_name , dval ) case ( 'z' ) read ( line ( pos :), * ) cur_name , zval call G % insert ( cur_name , zval ) case ( 'a' ) read ( line ( pos :), * ) cur_name , aval call G % insert ( cur_name , aval ) case ( 'l' ) read ( line ( pos :), * ) cur_name , lval call G % insert ( cur_name , lval ) case ( 't' ) read ( line ( pos :), * ) cur_name call tval % read ( unit ) call G % insert ( cur_name , tval ) case ( 'mi' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( mival )) deallocate ( mival ) allocate ( mival ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) mival ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'dictionary.read' , 'array reading stopped' ) end do call G % insert ( cur_name , mival ) case ( 'md' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( mdval )) deallocate ( mdval ) allocate ( mdval ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) mdval ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'dictionary.read' , 'array reading stopped' ) end do call G % insert ( cur_name , mdval ) case ( 'ma' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( maval )) deallocate ( maval ) allocate ( maval ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) maval ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'dictionary.read' , 'array reading stopped' ) end do call G % insert ( cur_name , maval ) case ( 'ml' ) read ( line ( pos :), * ) cur_name , len if ( allocated ( mlval )) deallocate ( mlval ) allocate ( mlval ( len )) do i = 1 , len read ( unit , * , IOSTAT = io_stat ) mlval ( i ) if ( io_stat /= 0 ) call wc_error_stop ( 'dictionary.read' , 'array reading stopped' ) end do call G % insert ( cur_name , mlval ) case ( '/' ) exit end select read ( unit , '(A)' , IOSTAT = io_stat ) line end do end subroutine subroutine append ( P1 , P2 ) class ( dictionary ), intent ( inout ) :: P1 type ( dictionary ), intent ( in ) :: P2 if ( sum ( P2 % itemcurn ) > 0 ) then call P1 % append_by_name ( P2 , P2 % get_names ()) end if end subroutine end module","tags":"","loc":"sourcefile/dictionary.f90.html"},{"title":"percentage.f90 – TNSG","text":"This file depends on sourcefile~~percentage.f90~~EfferentGraph sourcefile~percentage.f90 percentage.f90 sourcefile~error.f90 error.f90 sourcefile~percentage.f90->sourcefile~error.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~percentage.f90->sourcefile~mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules mod_percent Source Code percentage.f90 Source Code module mod_percent use mod_mpi_info use error implicit none private real ( 8 ) :: perc_save = 0 d0 integer :: line_length = 80 public percent , percent_end contains subroutine percent ( words_in , perc_in , step_ ) real ( 8 ), intent ( in ) :: perc_in character ( len =* ), intent ( in ) :: words_in real ( 8 ), intent ( in ), optional :: step_ real ( 8 ) :: step character ( len = line_length ) :: words if ( present ( step_ )) then step = step_ else step = 1 d0 end if if ( len_trim ( words_in ) + 1 > line_length ) then call wc_error_stop ( 'percent' , 'input words are too long.' ) end if words = '' words ( 1 : 1 ) = char ( 13 ) words ( 2 :) = words_in if ( abs ( perc_in - perc_save ) >= step ) then if ( my_rank == 0 ) then write ( * , '(a,$)' ) words end if perc_save = perc_in end if end subroutine subroutine percent_end ( words_in ) character ( len =* ), intent ( in ) :: words_in character ( len = line_length ) :: words if ( len_trim ( words_in ) + 1 > line_length ) then call wc_error_stop ( 'percent' , 'input words are too long.' ) end if words = '' words ( 1 : 1 ) = char ( 13 ) words ( 2 :) = words_in if ( my_rank == 0 ) then write ( * , '(a)' ) words end if perc_save = 0 d0 end subroutine end module","tags":"","loc":"sourcefile/percentage.f90.html"},{"title":"unidic.f90 – TNSG","text":"This file depends on sourcefile~~unidic.f90~~EfferentGraph sourcefile~unidic.f90 unidic.f90 sourcefile~error.f90 error.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~string.f90 string.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~stack.f90 stack.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~stack.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~unidic.f90~~AfferentGraph sourcefile~unidic.f90 unidic.f90 sourcefile~timer.f90 timer.f90 sourcefile~timer.f90->sourcefile~unidic.f90 sourcefile~lattice.f90 lattice.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules type_unidic Source Code unidic.f90 Source Code module type_unidic use error use string use mod_stack implicit none private type node private type ( node ), pointer :: next => null () character ( len = max_char_length ) :: key = '' integer :: val = 0 end type node integer , parameter :: hash_size = 787 type node_head private type ( node ), pointer :: first => null () end type node_head type unidic private type ( node_head ) :: hash_ary ( hash_size ) integer :: item_num = 0 type ( stack ) :: avail_stack contains private procedure , public :: num procedure , public :: add procedure :: add_with_val procedure , public :: del procedure :: del_with_val procedure , public :: val procedure , public :: show procedure , public :: rename procedure , public :: clean procedure , public :: print procedure , public :: read procedure :: copy generic , public :: assignment ( = ) => copy !procedure,public::check_consistency final :: clean_dic end type unidic public unidic contains function num ( U ) result ( res ) class ( unidic ), intent ( in ) :: U integer :: res res = U % item_num end function subroutine clean_dic ( U ) type ( unidic ), intent ( inout ) :: U call U % clean () end subroutine subroutine clean ( U ) class ( unidic ), intent ( inout ) :: U type ( node ), pointer :: p , p_n integer :: i U % item_num = 0 call U % avail_stack % clean () do i = 1 , hash_size if ( associated ( U % hash_ary ( i )% first )) then p => U % hash_ary ( i )% first !first node U % hash_ary ( i )% first => null () do while ( associated ( p % next )) p_n => p % next p % next => p_n % next deallocate ( p_n ) end do deallocate ( p ) end if end do end subroutine subroutine copy ( U_out , U_in ) class ( unidic ), intent ( inout ) :: U_out class ( unidic ), intent ( in ) :: U_in type ( node ), pointer :: p_in , p_out integer :: i call clean ( U_out ) U_out % item_num = U_in % item_num U_out % avail_stack = U_in % avail_stack do i = 1 , hash_size if ( associated ( U_in % hash_ary ( i )% first )) then allocate ( U_out % hash_ary ( i )% first ) p_in => U_in % hash_ary ( i )% first p_out => U_out % hash_ary ( i )% first p_out % val = p_in % val p_out % key = p_in % key do while ( associated ( p_in % next )) allocate ( p_out % next ) p_in => p_in % next p_out => p_out % next p_out % val = p_in % val p_out % key = p_in % key end do end if end do end subroutine subroutine show ( U ) class ( unidic ), intent ( inout ) :: U type ( node ), pointer :: p integer :: i if ( U % item_num == 0 ) then write ( * , * ) 'Empty dictionary.' else write ( * , * ) 'Dictionary with ' // trim ( str ( U % item_num )) // ' items:' do i = 1 , hash_size if ( associated ( U % hash_ary ( i )% first )) then p => U % hash_ary ( i )% first write ( * , '(A)' , advance = 'no' ) '  hash(' // trim ( str ( i )) // '):' do while ( associated ( p )) write ( * , '(A)' , advance = 'no' ) ' (' // trim ( p % key ) // ':' // trim ( str ( p % val )) // ')' if ( associated ( p % next )) then write ( * , '(A)' , advance = 'no' ) ',' else write ( * , '(A)' ) '' end if p => p % next end do end if end do end if end subroutine subroutine print ( U , f_unit ) class ( unidic ), intent ( inout ) :: U integer , intent ( in ) :: f_unit type ( node ), pointer :: p integer :: i write ( f_unit , * ) U % item_num call U % avail_stack % write ( f_unit ) do i = 1 , hash_size if ( associated ( U % hash_ary ( i )% first )) then p => U % hash_ary ( i )% first do while ( associated ( p )) write ( f_unit , * ) trim ( p % key ), p % val p => p % next end do end if end do end subroutine subroutine read ( U , f_unit ) class ( unidic ), intent ( inout ) :: U integer , intent ( in ) :: f_unit type ( node ), pointer :: p integer :: i , val character ( len = max_char_length ) :: key read ( f_unit , * ) U % item_num call U % avail_stack % read ( f_unit ) do i = 1 , U % item_num read ( f_unit , * ) key , val call U % add_with_val ( key , val ) end do end subroutine subroutine add ( U , key , val ) class ( unidic ), intent ( inout ) :: U character ( len =* ), intent ( in ) :: key integer , intent ( out ) :: val U % item_num = U % item_num + 1 if ( U % avail_stack % num () == 0 ) then val = U % item_num else val = U % avail_stack % pop () end if call U % add_with_val ( key , val ) end subroutine subroutine add_with_val ( U , key , val ) class ( unidic ), intent ( inout ) :: U character ( len =* ), intent ( in ) :: key integer , intent ( in ) :: val type ( node ), pointer :: p integer :: pos pos = hash_func ( U , key ) if (. not . associated ( U % hash_ary ( pos )% first )) then allocate ( U % hash_ary ( pos )% first ) U % hash_ary ( pos )% first % key = key U % hash_ary ( pos )% first % val = val else p => U % hash_ary ( pos )% first if ( p % key == key ) then call wc_error_stop ( 'unidic.add' , 'key ' // trim ( key ) // ' already exist' ) end if do while ( associated ( p % next )) p => p % next if ( p % key == key ) then call wc_error_stop ( 'unidic.add' , 'key ' // trim ( key ) // ' already exist' ) end if end do allocate ( p % next ) p % next % key = key p % next % val = val end if end subroutine subroutine del_with_val ( U , key , val ) class ( unidic ), intent ( inout ) :: U character ( len =* ), intent ( in ) :: key integer , intent ( out ) :: val type ( node ), pointer :: p , q integer :: pos logical :: found pos = hash_func ( U , key ) found = . false . if ( associated ( U % hash_ary ( pos )% first )) then p => U % hash_ary ( pos )% first !first node if ( p % key == key ) then val = p % val U % hash_ary ( pos )% first => p % next deallocate ( p ) found = . true . else do while ( associated ( p % next )) if ( p % next % key == key ) then val = p % next % val q => p % next p % next => p % next % next deallocate ( q ) found = . true . exit end if p => p % next end do end if end if if (. not . found ) call wc_error_stop ( 'unidic.del' , 'key ' // trim ( key ) // ' not exist' ) end subroutine subroutine del ( U , key ) class ( unidic ), intent ( inout ) :: U character ( len =* ), intent ( in ) :: key type ( node ), pointer :: p , q integer :: val call U % del_with_val ( key , val ) U % item_num = U % item_num - 1 call U % avail_stack % push ( val ) end subroutine integer function val ( U , key ) class ( unidic ), intent ( in ) :: U character ( len =* ), intent ( in ) :: key type ( node ), pointer :: p integer :: pos logical :: found pos = hash_func ( U , key ) found = . false . if ( associated ( U % hash_ary ( pos )% first )) then p => U % hash_ary ( pos )% first !first node do while ( associated ( p )) if ( p % key == key ) then val = p % val found = . true . exit end if p => p % next end do end if if (. not . found ) val = 0 end function subroutine rename ( U , key1 , key2 ) class ( unidic ), intent ( inout ) :: U character ( len =* ), intent ( in ) :: key1 , key2 integer :: val call U % del_with_val ( key1 , val ) call U % add_with_val ( key2 , val ) end subroutine integer function hash_func ( U , key ) class ( unidic ), intent ( in ) :: U character ( len =* ), intent ( in ) :: key integer :: i hash_func = 0 do i = 1 , len_trim ( key ) hash_func = hash_func + iachar ( key ( i : i )) end do hash_func = mod ( hash_func , hash_size ) + 1 end function end module type_unidic","tags":"","loc":"sourcefile/unidic.f90.html"},{"title":"zdotu.f90 – TNSG","text":"Contents Functions ZDOTU1 Source Code zdotu.f90 Source Code COMPLEX ( 8 ) FUNCTION ZDOTU1 ( N , ZX , INCX , ZY , INCY ) implicit none INTEGER :: INCX , INCY , N COMPLEX ( 8 ) :: ZX (( N - 1 ) * INCX + 1 ), ZY (( N - 1 ) * INCY + 1 ) COMPLEX ( 8 ) :: ZDOTU EXTERNAL :: ZDOTU INTEGER I , IX , IY #if BAD_ZDU IF ( N < 0 ) RETURN IF ( INCX == 1 . AND . INCY == 1 ) THEN ZDOTU1 = ZDOTU1 + sum ( ZX ( 1 : N ) * ZY ( 1 : N )) ELSE ZDOTU1 = ZDOTU1 + sum ( ZX ( 1 :( N - 1 ) * INCX + 1 : INCX ) * ZY ( 1 :( N - 1 ) * INCY + 1 : INCY )) END IF #else ZDOTU1 = ZDOTU ( N , ZX , INCX , ZY , INCY ) #endif END FUNCTION","tags":"","loc":"sourcefile/zdotu.f90.html"},{"title":"lattice.f90 – TNSG","text":"This file depends on sourcefile~~lattice.f90~~EfferentGraph sourcefile~lattice.f90 lattice.f90 sourcefile~dictionary.f90 dictionary.f90 sourcefile~lattice.f90->sourcefile~dictionary.f90 sourcefile~mpi_info.f90 mpi_info.f90 sourcefile~lattice.f90->sourcefile~mpi_info.f90 sourcefile~string.f90 string.f90 sourcefile~lattice.f90->sourcefile~string.f90 sourcefile~unidic.f90 unidic.f90 sourcefile~lattice.f90->sourcefile~unidic.f90 sourcefile~error.f90 error.f90 sourcefile~lattice.f90->sourcefile~error.f90 sourcefile~dictionary.f90->sourcefile~string.f90 sourcefile~dictionary.f90->sourcefile~error.f90 sourcefile~string.f90->sourcefile~error.f90 sourcefile~unidic.f90->sourcefile~string.f90 sourcefile~unidic.f90->sourcefile~error.f90 sourcefile~stack.f90 stack.f90 sourcefile~unidic.f90->sourcefile~stack.f90 sourcefile~error.f90->sourcefile~mpi_info.f90 sourcefile~stack.f90->sourcefile~error.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~lattice.f90~~AfferentGraph sourcefile~lattice.f90 lattice.f90 sourcefile~lattice_clt.f90 lattice_clt.f90 sourcefile~lattice_clt.f90->sourcefile~lattice.f90 sourcefile~tn_tensor.f90 tn_tensor.f90 sourcefile~lattice_clt.f90->sourcefile~tn_tensor.f90 sourcefile~tn_tensor.f90->sourcefile~lattice.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules tensor_network Source Code lattice.f90 Source Code MODULE tensor_network use tensor_type use error use tools use string use type_unidic use mod_dictionary implicit none private type bond private integer :: nb_rawpos integer :: nb_no logical :: env_tag = . false . type ( tensor ) :: env character ( len = max_char_length ) :: ind = '' end type type site private integer :: pos ( 2 ) = 0 type ( bond ), allocatable :: bonds (:) character ( len = max_char_length ) :: name = '' type ( tensor ), pointer :: tensor => Null () type ( tensor ) :: tensor_save type ( tensor ) :: tensor_bac integer :: nb_num = 0 logical :: tensor_save_tag = . false . logical :: back_up_tag = . false . logical :: con_tag = . false . logical :: exist_tag = . false . type ( dictionary ) :: info contains private procedure :: copy_site generic :: assignment ( = ) => copy_site !final:: clean_site end type type lattice private logical ( kind = 1 ) :: empty_tag = . true . type ( site ), allocatable :: sites (:) type ( dictionary ) :: info type ( unidic ) :: name_dic integer , allocatable :: raw_pos (:,:) ! =0 if not exist integer :: L1 = 0 , L2 = 0 , max_nb_num = 0 , max_site_num = 0 character ( len = max_char_length ) :: name = '' contains private procedure , public :: initialize procedure , public :: clean procedure , public :: mirror_con procedure , public :: copy_line procedure , public :: copy_line_ten procedure , public :: copy_line_link procedure :: set_bond_as_pure procedure :: set_bond_as_cluster procedure :: set_bond_as_path generic , public :: set_bond_as => set_bond_as_pure , set_bond_as_cluster , set_bond_as_path procedure , public :: draw_l procedure , public :: draw_tn generic , public :: draw => draw_l , draw_tn !final:: clean_lat procedure :: add_from_ten procedure :: add_from_lat_pos generic , public :: add => add_from_ten , add_from_lat_pos procedure :: delete_pos procedure :: delete_name generic , public :: delete => delete_pos , delete_name procedure :: move_pos procedure :: move_name generic , public :: move => move_pos , move_name procedure , public :: move_row procedure , public :: move_column procedure :: rename_pos procedure :: rename_name generic , public :: rename => rename_pos , rename_name procedure :: back_up_pos procedure :: back_up_name generic , public :: back_up => back_up_pos , back_up_name procedure :: restore_pos procedure :: restore_name generic , public :: restore => restore_pos , restore_name procedure :: get_tensor_pos procedure :: get_tensor_name generic , public :: get_tensor => get_tensor_pos , get_tensor_name procedure :: get_tensor_link_pos procedure :: get_tensor_link_name generic , public :: get_tensor_link => get_tensor_link_pos , get_tensor_link_name procedure :: get_env_link_pos procedure :: get_env_link_name generic , public :: get_env_link => get_env_link_pos , get_env_link_name procedure :: get_env_bond_pos generic , public :: get_env_bond => get_env_bond_pos procedure :: set_env_bond_pos generic , public :: set_env_bond => set_env_bond_pos procedure :: update_tensor_pos procedure :: update_tensor_name generic , public :: update_tensor => update_tensor_pos , update_tensor_name procedure :: set_tensor_pos procedure :: set_tensor_name generic , public :: set_tensor => set_tensor_pos , set_tensor_name procedure :: point_info_pos procedure :: point_info_name procedure :: point_info_lat generic , public :: point_info => point_info_pos , point_info_name , point_info_lat procedure :: set_bond_name procedure :: set_bond_pos generic , public :: set_bond => set_bond_pos , set_bond_name procedure :: get_bond_pos procedure :: get_bond_name generic , public :: get_bond => get_bond_pos , get_bond_name procedure :: get_bonds_pos procedure :: get_bonds_name generic , public :: get_bonds => get_bonds_pos , get_bonds_name procedure :: get_bond_no_pos procedure :: get_bond_no_name generic , public :: get_bond_no => get_bond_no_pos , get_bond_no_name procedure :: remove_bond_name procedure :: remove_bond_pos generic , public :: remove_bond => remove_bond_pos , remove_bond_name procedure :: invert_bond_pos procedure :: invert_bond_name generic , public :: invert_bond => invert_bond_pos , invert_bond_name procedure :: move_nb procedure :: remove_nb procedure :: get_nb_num_pos procedure :: get_nb_num_name generic , public :: get_nb_num => get_nb_num_pos , get_nb_num_name procedure , public :: get_max_nb_num procedure , public :: absorb procedure :: get_rawpos_pos procedure :: get_rawpos_name generic :: get_rawpos => get_rawpos_pos , get_rawpos_name procedure , public :: get_size procedure , public :: get_range procedure :: get_max_site_num procedure :: get_name_whole procedure :: get_name_site generic , public :: get_name => get_name_whole , get_name_site procedure , public :: get_pos procedure :: set_name_lat generic , public :: set_name => set_name_lat procedure , public :: ind_name procedure , public :: check_boundary procedure , public :: get_contag_pos procedure , public :: get_contag_name generic , public :: get_contag => get_contag_pos , get_contag_name procedure :: set_contag_pos procedure :: set_contag_name generic , public :: set_contag => set_contag_pos , set_contag_name procedure , public :: cut_bonds procedure , public :: max_cut_bonds procedure , public :: get_empty_tag procedure :: check_exist_pos procedure :: check_exist_name generic , public :: check_exist => check_exist_pos , check_exist_name procedure :: check_exist_bond_pos procedure :: check_exist_bond_name generic , public :: check_exist_bond => check_exist_bond_pos , check_exist_bond_name procedure :: bonds_num_pos procedure :: bonds_num_name procedure :: bonds_num_rawpos generic , public :: bonds_num => bonds_num_pos , bonds_num_name procedure :: check_empty_whole procedure :: check_empty_site_pos procedure :: check_empty_site_name generic , public :: check_empty => check_empty_whole , check_empty_site_pos , check_empty_site_name procedure :: check_unempty_whole procedure :: check_unempty_site_pos procedure :: check_unempty_site_name generic , public :: check_unempty => check_unempty_whole , check_unempty_site_pos , check_unempty_site_name procedure :: check_consistency procedure , public :: write procedure , public :: read procedure , public :: generate_ten ! env related procedure , public :: generate_env procedure :: absorb_env_whole procedure :: absorb_env_pos_bond procedure :: absorb_env_name_bond procedure :: absorb_env_inner procedure :: absorb_env_pos_site procedure :: tensor_absorb_env_pos generic , public :: absorb_env => absorb_env_whole generic , public :: absorb_env_bond => absorb_env_pos_bond , absorb_env_name_bond generic , public :: absorb_env_site => absorb_env_pos_site generic , public :: tensor_absorb_env => tensor_absorb_env_pos procedure :: spit_env_whole procedure :: spit_env_pos_bond procedure :: spit_env_name_bond procedure :: spit_env_inner generic , public :: spit_env => spit_env_whole generic , public :: spit_env_bond => spit_env_pos_bond , spit_env_name_bond procedure :: copy_lat generic , public :: assignment ( = ) => copy_lat procedure , public :: transpose_lat procedure :: dinsert_info_whole , zinsert_info_whole , iinsert_info_whole , linsert_info_whole , ainsert_info_whole , tinsert_info_whole procedure :: dinsert_info_pos , zinsert_info_pos , iinsert_info_pos , linsert_info_pos , ainsert_info_pos , tinsert_info_pos procedure :: dinsert_info_name , zinsert_info_name , iinsert_info_name , linsert_info_name , ainsert_info_name , tinsert_info_name generic , public :: insert_info => dinsert_info_whole , dinsert_info_pos , dinsert_info_name ,& zinsert_info_whole , zinsert_info_pos , zinsert_info_name ,& iinsert_info_whole , iinsert_info_pos , iinsert_info_name ,& linsert_info_whole , linsert_info_pos , linsert_info_name ,& ainsert_info_whole , ainsert_info_pos , ainsert_info_name ,& tinsert_info_whole , tinsert_info_pos , tinsert_info_name procedure , public :: dget_info_whole , zget_info_whole , iget_info_whole , lget_info_whole , aget_info_whole , tget_info_whole procedure , public :: dget_info_pos , zget_info_pos , iget_info_pos , lget_info_pos , aget_info_pos , tget_info_pos procedure , public :: dget_info_name , zget_info_name , iget_info_name , lget_info_name , aget_info_name , tget_info_name generic , public :: get_info => dget_info_whole , dget_info_pos , dget_info_name ,& zget_info_whole , zget_info_pos , zget_info_name ,& iget_info_whole , iget_info_pos , iget_info_name ,& lget_info_whole , lget_info_pos , lget_info_name ,& aget_info_whole , aget_info_pos , aget_info_name ,& tget_info_whole , tget_info_pos , tget_info_name procedure , public :: dset_info_whole , zset_info_whole , iset_info_whole , lset_info_whole , aset_info_whole , tset_info_whole procedure , public :: dset_info_pos , zset_info_pos , iset_info_pos , lset_info_pos , aset_info_pos , tset_info_pos procedure , public :: dset_info_name , zset_info_name , iset_info_name , lset_info_name , aset_info_name , tset_info_name generic , public :: set_info => dset_info_whole , dset_info_pos , dset_info_name ,& zset_info_whole , zset_info_pos , zset_info_name ,& iset_info_whole , iset_info_pos , iset_info_name ,& lset_info_whole , lset_info_pos , lset_info_name ,& aset_info_whole , aset_info_pos , aset_info_name ,& tset_info_whole , tset_info_pos , tset_info_name end type type group private class ( lattice ), pointer :: lat => NULL () character ( len = max_char_length ) :: name = '' logical , allocatable :: includes (:) contains private procedure , public :: get_info procedure :: get_name_grp generic , public :: get_name => get_name_grp procedure :: set_name_grp generic , public :: set_name => set_name_grp procedure :: draw_grp generic , public :: draw => draw_grp procedure :: empty_grp generic , public :: empty => empty_grp procedure , public :: check_can_take procedure :: take_pos procedure :: take_name procedure :: take_group generic , public :: take => take_pos , take_name , take_group procedure :: check_contain_grp_pos procedure :: check_contain_grp_name generic , public :: check_contain => check_contain_grp_pos , check_contain_grp_name procedure :: belong_group generic , public :: belong => belong_group procedure :: copy_grp generic , public :: assignment ( = ) => copy_grp procedure , public :: get_names procedure :: get_num_group generic , public :: get_num => get_num_group procedure , public :: point_lat procedure :: invert_bond_grp generic , public :: invert_bond => invert_bond_grp procedure , public :: get_dangle_inds procedure :: get_lattice_link_grp generic , public :: get_lattice_link => get_lattice_link_grp end type type path private integer , allocatable :: raw_path (:) character ( len = max_char_length ) :: name = '' integer :: num = 0 , current_pos = 0 class ( lattice ), pointer :: lat => null () contains private procedure :: get_name_path generic , public :: get_name => get_name_path procedure :: set_name_path generic , public :: set_name => set_name_path procedure :: belong_path generic , public :: belong => belong_path procedure :: add_name procedure :: add_pos generic , public :: add => add_name , add_pos procedure :: get_next_name procedure :: get_next_pos generic , public :: get_next => get_next_name , get_next_pos procedure :: get_order_name procedure :: get_order_pos generic , public :: get_order => get_order_name , get_order_pos procedure :: get_name_order generic , public :: get_name => get_name_order procedure :: get_pos_order generic , public :: get_pos => get_pos_order procedure :: get_num_path generic , public :: get_num => get_num_path procedure :: iterate_pos procedure :: iterate_name generic , public :: iterate => iterate_pos , iterate_name procedure :: copy_path generic , public :: assignment ( = ) => copy_path procedure :: inverse_path generic , public :: inverse => inverse_path procedure :: clean_path generic , public :: clean => clean_path procedure :: generate_path generic , public :: generate => generate_path procedure :: draw_path generic , public :: draw => draw_path procedure :: get_lattice_link_path generic , public :: get_lattice_link => get_lattice_link_path procedure :: check_contain_path_pos procedure :: check_contain_path_name generic , public :: check_contain => check_contain_path_pos , check_contain_path_name end type public lattice , group , path , lat_absorb_tensor , lat_absorb_env , lat_contract_type contains ! I/O subroutine write ( L , funit ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: funit integer :: i write ( funit , * ) L % empty_tag if (. not . L % empty_tag ) then write ( funit , * ) L % L1 write ( funit , * ) L % L2 write ( funit , * ) L % max_nb_num write ( funit , * ) L % max_site_num call L % info % print ( funit ) call L % name_dic % print ( funit ) write ( funit , * ) L % raw_pos write ( funit , * ) L % name do i = 1 , L % max_site_num call write_site ( L % sites ( i ), funit ) end do end if end subroutine subroutine read ( L , funit ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: funit integer :: i call L % clean read ( funit , * ) L % empty_tag if (. not . L % empty_tag ) then read ( funit , * ) L % L1 read ( funit , * ) L % L2 read ( funit , * ) L % max_nb_num read ( funit , * ) L % max_site_num allocate ( L % sites ( L % max_site_num )) allocate ( L % raw_pos ( L % L1 , L % L2 )) call L % info % read ( funit ) call L % name_dic % read ( funit ) read ( funit , * ) L % raw_pos read ( funit , * ) L % name do i = 1 , L % max_site_num call read_site ( L % sites ( i ), funit ) end do end if end subroutine subroutine write_site ( S , funit ) class ( site ), intent ( inout ) :: S integer , intent ( in ) :: funit integer :: i write ( funit , * ) S % exist_tag if ( S % exist_tag ) then write ( funit , * ) S % pos write ( funit , * ) S % nb_num write ( funit , * ) trim ( S % name ) do i = 1 , S % nb_num write ( funit , * ) S % bonds ( i )% nb_rawpos write ( funit , * ) S % bonds ( i )% nb_no write ( funit , * ) S % bonds ( i )% env_tag if ( S % bonds ( i )% env_tag ) then call S % bonds ( i )% env % write ( funit ) end if write ( funit , * ) trim ( S % bonds ( i )% ind ) end do write ( funit , * ) associated ( S % tensor ) if ( associated ( S % tensor )) then call S % tensor % write ( funit ) end if write ( funit , * ) S % con_tag call S % info % print ( funit ) end if end subroutine subroutine read_site ( S , funit ) class ( site ), intent ( inout ), target :: S integer , intent ( in ) :: funit integer :: i logical :: associated read ( funit , * ) S % exist_tag if ( S % exist_tag ) then read ( funit , * ) S % pos read ( funit , * ) S % nb_num allocate ( S % bonds ( S % nb_num )) read ( funit , * ) S % name do i = 1 , S % nb_num read ( funit , * ) S % bonds ( i )% nb_rawpos read ( funit , * ) S % bonds ( i )% nb_no read ( funit , * ) S % bonds ( i )% env_tag if ( S % bonds ( i )% env_tag ) then call S % bonds ( i )% env % read ( funit ) end if read ( funit , * ) S % bonds ( i )% ind end do read ( funit , * ) associated if ( associated ) then S % tensor => S % tensor_save call S % tensor % read ( funit ) S % tensor_save_tag = . true . end if read ( funit , * ) S % con_tag call S % info % read ( funit ) end if end subroutine ! init subroutine initialize ( L , my_name , L1 , L2 , max_nb_num ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: L1 , L2 , max_nb_num character ( len =* ), intent ( in ) :: my_name L % L1 = L1 L % L2 = L2 L % name = my_name L % max_nb_num = max_nb_num L % max_site_num = L1 * L2 allocate ( L % sites ( L % max_site_num )) allocate ( L % raw_pos ( L1 , L2 )) L % raw_pos = 0 L % empty_tag = . false . end subroutine subroutine generate_ten ( L , D , datatype , type_ ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: D character ( len =* ), intent ( in ) :: datatype character ( len =* ), intent ( in ), optional :: type_ character ( len = 20 ) :: type integer :: i , k , nb_num , phy_dim if ( present ( type_ )) then type = type_ else type = 'rand' end if call L % check_unempty () do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then nb_num = L % sites ( i )% nb_num phy_dim = L % sites ( i )% info % ii ( 'Dp' ) L % sites ( i )% tensor => L % sites ( i )% tensor_save L % sites ( i )% tensor_save_tag = . true . if ( phy_dim > 0 ) then call L % sites ( i )% tensor % allocate ([( D , k = 1 , nb_num ), phy_dim ], datatype ) else call L % sites ( i )% tensor % allocate ([( D , k = 1 , nb_num )], datatype ) end if select case ( type ) case ( 'rand' ) call L % sites ( i )% tensor % random ([ - 1.0d0 , 1.0d0 ]) case ( 'one' ) call L % sites ( i )% tensor % random ([ 1.0d0 - 1 d - 2 , 1.0d0 + 1 d - 2 ]) case ( 'zero' ) call L % sites ( i )% tensor % setValue ( 0 d0 ) case default call wc_error_stop ( 'lattice.generate_ten' , 'The type ' // trim ( type ) // ' is unidentified.' ) end select do k = 1 , nb_num call L % sites ( i )% tensor % setName ( k , L % sites ( i )% bonds ( k )% ind ) end do if ( phy_dim > 0 ) call L % sites ( i )% tensor % setName ( nb_num + 1 , L % sites ( i )% name + '.phy' ) end if end do end subroutine subroutine generate_env ( L , type_ ) class ( lattice ), intent ( inout ) :: L character ( len =* ), optional :: type_ integer :: i , k , nb_num , nb_k , nb_rawpos , D character ( len = max_char_length ) :: ind , type type ( tensor ) :: env if ( present ( type_ )) then type = type_ else type = 'rand' end if call L % check_unempty () do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then nb_num = L % sites ( i )% nb_num do k = 1 , nb_num L % sites ( i )% bonds ( k )% env_tag = . true . nb_rawpos = L % sites ( i )% bonds ( k )% nb_rawpos if ( nb_rawpos < i ) then nb_k = L % sites ( i )% bonds ( k )% nb_no L % sites ( i )% bonds ( k )% env = L % sites ( nb_rawpos )% bonds ( nb_k )% env else ind = L % sites ( i )% bonds ( k )% ind D = L % sites ( i )% tensor % dim ( ind ) select case ( type ) case ( 'rand' ) call env % deallocate () call env % allocate ([ D , D ], 'real*8' ) call env % random () !env=eye(env) case ( 'one' ) env = eye ( D , D ) end select L % sites ( i )% bonds ( k )% env = env call L % sites ( i )% bonds ( k )% env % setName ( 1 , 'env.in' ) call L % sites ( i )% bonds ( k )% env % setName ( 2 , 'env.out' ) end if end do end if end do end subroutine ! clean subroutine clean ( L ) class ( lattice ), intent ( inout ) :: L integer :: i if (. not . L % empty_tag ) then L % L1 = 0 L % L2 = 0 L % name = '' L % max_nb_num = 0 do i = 1 , L % max_site_num call clean_site ( L % sites ( i )) end do deallocate ( L % sites ) deallocate ( L % raw_pos ) L % max_site_num = 0 call L % name_dic % clean () L % empty_tag = . true . end if end subroutine subroutine clean_lat ( L ) type ( lattice ), intent ( inout ) :: L call L % clean () end subroutine subroutine clean_site ( S ) type ( site ), intent ( inout ) :: S if ( S % exist_tag ) then S % pos = 0 deallocate ( S % bonds ) S % name = '' call S % tensor_save % deallocate () S % tensor => Null () S % nb_num = 0 S % con_tag = . false . S % exist_tag = . false . S % tensor_save_tag = . false . end if end subroutine ! check legitimation logical function get_empty_tag ( L ) class ( lattice ), intent ( in ) :: L get_empty_tag = L % empty_tag end function logical function check_exist_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) call L % check_unempty () if ( pos ( 1 ) >= 1 . and . pos ( 1 ) <= L % L1 . and . pos ( 2 ) >= 1 . and . pos ( 2 ) <= L % L2 ) then check_exist_pos = ( L % raw_pos ( pos ( 1 ), pos ( 2 )) > 0 ) else check_exist_pos = . false . end if end function logical function check_exist_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name call L % check_unempty () check_exist_name = ( L % name_dic % val ( name ) > 0 ) end function logical function check_exist_bond_pos ( L , pos1 , pos2 ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) logical :: exist1 , exist2 integer :: rawpos1 , rawpos2 call L % check_unempty () exist1 = L % check_exist ( pos1 ) exist2 = L % check_exist ( pos2 ) if (. not .( exist1 . and . exist2 )) then check_exist_bond_pos = . false . else rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) check_exist_bond_pos = ( L % bonds_num_rawpos ( rawpos1 , rawpos2 ) > 0 ) end if end function logical function check_exist_bond_name ( L , name1 , name2 ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name1 , name2 logical :: exist1 , exist2 integer :: rawpos1 , rawpos2 call L % check_unempty () exist1 = L % check_exist ( name1 ) exist2 = L % check_exist ( name2 ) if (. not .( exist1 . and . exist2 )) then check_exist_bond_name = . false . else rawpos1 = L % get_rawpos ( name1 ) rawpos2 = L % get_rawpos ( name2 ) check_exist_bond_name = ( L % bonds_num_rawpos ( rawpos1 , rawpos2 ) > 0 ) end if end function subroutine check_empty_whole ( L ) class ( lattice ), intent ( in ) :: L if (. not . L % empty_tag ) then call writemess ( 'Lattice is not empty!' ) call wc_error_stop end if end subroutine subroutine check_empty_site_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) call L % check_unempty () call L % check_boundary ( pos ) if ( L % raw_pos ( pos ( 1 ), pos ( 2 )) > 0 ) then call writemess ( trim ( str ( pos )) // ' is not empty in Lattice ' // trim ( L % name )) call wc_error_stop end if end subroutine subroutine check_empty_site_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name call L % check_unempty () if ( L % get_rawpos ( name ) > 0 ) then call writemess ( trim ( name ) // ' is not empty in Lattice ' // trim ( L % name )) call wc_error_stop end if end subroutine subroutine check_unempty_whole ( L ) class ( lattice ), intent ( in ) :: L if ( L % empty_tag ) then call writemess ( 'Lattice is empty!' ) call wc_error_stop end if end subroutine subroutine check_unempty_site_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) call L % check_boundary ( pos ) call L % check_unempty () if ( L % raw_pos ( pos ( 1 ), pos ( 2 )) == 0 ) then call writemess ( trim ( str ( pos )) // ' is empty in Lattice ' // trim ( L % name )) call wc_error_stop end if end subroutine subroutine check_unempty_site_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name call L % check_unempty () if ( L % get_rawpos ( name ) == 0 ) then call writemess ( trim ( name ) // ' is empty in Lattice ' // trim ( L % name )) call wc_error_stop end if end subroutine subroutine check_boundary ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) call L % check_unempty () if ( pos ( 1 ) < 1. or . pos ( 1 ) > L % L1 . or . pos ( 2 ) < 1. or . pos ( 2 ) > L % L2 ) then call writemess ( 'Site (' + pos ( 1 ) + ',' + pos ( 2 ) + ') is out of boundary of a_' + L % L1 + 'X' + L % L2 + '_lattice:' + L % name ) call wc_error_stop end if end subroutine subroutine check_consistency ( L ) class ( lattice ), intent ( in ) :: L integer :: num1 , num2 , num3 integer :: i , k , nb_rawpos , nb_no , nb_nb_rawpos , nb_nb_no logical :: pass ( 4 ) = . true ., pass2 = . true . call writemess ( '=======================================' ) call writemess ( 'check_consistency' ) if ( L % empty_tag ) then pass2 = pass2 . and .( L % L1 == 0 ) pass2 = pass2 . and .( L % L2 == 0 ) pass2 = pass2 . and .( L % max_site_num == 0 ) pass2 = pass2 . and .( L % name_dic % num () == 0 ) pass2 = pass2 . and .(. not . allocated ( L % sites )) pass2 = pass2 . and .(. not . allocated ( L % raw_pos )) if ( pass2 ) then call writemess ( 'Everything is consistent' ) else call writemess ( 'Something is inconsistent for empty lattice' ) end if else pass ( 1 ) = pass ( 1 ). and . ( size ( L % sites ) == L % max_site_num ) pass ( 1 ) = pass ( 1 ). and . all ( shape ( L % raw_pos ) >= [ L % L1 , L % L2 ]) if (. not . pass ( 1 )) then write ( * , * ) size ( L % sites ), L % max_site_num write ( * , * ) shape ( L % raw_pos ),[ L % L1 , L % L2 ] call wc_error_stop ( 'check_consistency' , 'size of aux arrays inconsistent!' ) end if num1 = 0 do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) num1 = num1 + 1 end do num2 = count ( L % raw_pos > 0 ) num3 = L % name_dic % num () pass ( 2 ) = num1 == num2 . and . num1 == num3 if (. not . pass ( 2 )) then write ( * , * ) num1 , num2 , num3 call wc_error_stop ( 'check_consistency' , 'total number of sites inconsistent!' ) end if do i = 1 , L % max_site_num if (. not . site_consistent ( L % sites ( i ))) then pass ( 3 ) = . false . end if end do if (. not . pass ( 3 )) then call wc_error_stop ( 'check_consistency' , 'some sites are inconsistent!' ) end if do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then do k = 1 , L % sites ( i )% nb_num nb_rawpos = L % sites ( i )% bonds ( k )% nb_rawpos nb_no = L % sites ( i )% bonds ( k )% nb_no if ( nb_rawpos == i ) then pass ( 4 ) = . false . call writemess ( 'site (' + i + '-' + k + ') links to itself' ) end if if ( nb_rawpos > i ) then nb_nb_rawpos = L % sites ( nb_rawpos )% bonds ( nb_no )% nb_rawpos nb_nb_no = L % sites ( nb_rawpos )% bonds ( nb_no )% nb_no if (. not .( nb_nb_rawpos == i . and . nb_nb_no == k )) then pass ( 4 ) = . false . call writemess ( 'site (' + i + '-' + k + ') has wrong return' ) end if end if end do end if end do if (. not . pass ( 4 )) then call wc_error_stop ( 'check_consistency' , 'some bonds are inconsistent!' ) end if if ( all ( pass )) then call writemess ( 'Everything is consistent' ) end if end if call writemess ( '=======================================' ) end subroutine logical function site_consistent ( S ) class ( site ), intent ( in ) :: S character ( len = max_char_length ) :: symptom integer :: i site_consistent = . true . if (. not . S % exist_tag ) then site_consistent = site_consistent . and .( len_trim ( S % name ) == 0 ) site_consistent = site_consistent . and .(. not . allocated ( S % bonds )) site_consistent = site_consistent . and . all ( S % pos == 0 ) site_consistent = site_consistent . and .(. not . S % con_tag ) !site_consistent=site_consistent.and.(.not.associated(S%tensor)) site_consistent = site_consistent . and .( S % nb_num == 0 ) if (. not . site_consistent ) then write ( * , * ) len_trim ( S % name ) == 0 write ( * , * ) all ( S % pos == 0 ) write ( * , * ). not . S % con_tag !write(*,*).not.associated(S%tensor) write ( * , * ) S % nb_num == 0 write ( * , * ). not . allocated ( S % bonds ) end if else if ( len_trim ( S % name ) <= 0 ) then site_consistent = . false . symptom = 'Name is empty.' end if if ( site_consistent ) then if ( size ( S % bonds ) < S % nb_num ) then site_consistent = . false . symptom = 'Number of bonds exceeds limit.' end if end if if ( associated ( S % tensor )) then if ( site_consistent ) then if (. not . S % tensor % getflag ()) then site_consistent = . false . symptom = 'tensor is empty.' else do i = 1 , S % nb_num if ( S % tensor % nameorder ( S % bonds ( i )% ind ) <= 0 ) then site_consistent = . false . symptom = trim ( S % bonds ( i )% ind ) // ' is not found.' exit end if end do end if end if end if if (. not . site_consistent ) then write ( * , * ) '---------------------' write ( * , * ) 'site is inconsistent' write ( * , * ) 'symptom is: ' , trim ( symptom ) write ( * , * ) 'position is: ' , S % pos write ( * , * ) 'name is ' , trim ( S % name ) write ( * , * ) 'max neighbor num is: ' , size ( S % bonds ) write ( * , * ) 'neighbor num is: ' , S % nb_num if ( S % nb_num > 0 ) then write ( * , * ) 'indices are ' do i = 1 , S % nb_num write ( * , * ) trim ( S % bonds ( i )% ind ) end do end if write ( * , * ) 'points to a tensor ? ' , associated ( S % tensor ) if ( associated ( S % tensor )) call S % tensor % diminfo () write ( * , * ) '---------------------' end if end if end function ! env subroutine absorb_env_whole ( L ) class ( lattice ), intent ( inout ) :: L integer :: i , k call L % check_unempty () do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then if ( L % sites ( i )% info % li ( 'absorb_env' )) then do k = 1 , L % sites ( i )% nb_num call L % absorb_env_inner ( i , k ) end do end if end if end do end subroutine subroutine absorb_env_pos_site ( L , pos , T ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ) type ( tensor ), intent ( inout ) :: T integer :: n , rawpos , k type ( tensor ) :: temp rawpos = L % get_rawpos ( pos ) T = L % sites ( rawpos )% tensor if ( L % sites ( rawpos )% info % li ( 'absorb_env' )) then do k = 1 , L % sites ( rawpos )% nb_num temp = L % sites ( rawpos )% bonds ( k )% env do n = 1 , temp % dim ( 1 ) call temp % setValue ([ n , n ], dsqrt ( temp % di ([ n , n ])) ) end do T = contract ( T , L % sites ( rawpos )% bonds ( k )% ind , temp , 'env.in' ) call T % setName ( 'env.out' , L % sites ( rawpos )% bonds ( k )% ind ) end do end if end subroutine subroutine tensor_absorb_env_pos ( L , pos1 , pos2 , T ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) integer :: n , rawpos1 , rawpos2 , no , nb_no type ( tensor ), intent ( inout ) :: T type ( tensor ) :: temp character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) call L % get_bond ( pos1 , no , ind , pos2 , nb_no , nb_ind ) temp = L % sites ( rawpos1 )% bonds ( no )% env do n = 1 , temp % dim ( 1 ) call temp % setValue ([ n , n ], dsqrt ( temp % di ([ n , n ])) ) end do T = contract ( T , L % sites ( rawpos1 )% bonds ( no )% ind , temp , 'env.in' ) call T % setName ( 'env.out' , L % sites ( rawpos1 )% bonds ( no )% ind ) end subroutine subroutine absorb_env_pos_bond ( L , pos1 , pos2 ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) integer :: n , rawpos1 , rawpos2 , no , nb_no type ( tensor ) :: temp character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) call L % get_bond ( pos1 , no , ind , pos2 , nb_no , nb_ind ) if ( L % sites ( rawpos1 )% info % li ( 'absorb_env' )) call L % absorb_env_inner ( rawpos1 , no ) if ( L % sites ( rawpos2 )% info % li ( 'absorb_env' )) call L % absorb_env_inner ( rawpos2 , nb_no ) end subroutine subroutine absorb_env_name_bond ( L , name1 , name2 ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name1 , name2 integer :: n , rawpos1 , rawpos2 , no , nb_no type ( tensor ) :: temp character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( name1 ) rawpos2 = L % get_rawpos ( name2 ) call L % get_bond ( name1 , no , ind , name2 , nb_no , nb_ind ) if ( L % sites ( rawpos1 )% info % li ( 'absorb_env' )) call L % absorb_env_inner ( rawpos1 , no ) if ( L % sites ( rawpos2 )% info % li ( 'absorb_env' )) call L % absorb_env_inner ( rawpos2 , nb_no ) end subroutine subroutine absorb_env_inner ( L , rawpos , no ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: rawpos , no integer :: n type ( tensor ) :: temp temp = L % sites ( rawpos )% bonds ( no )% env do n = 1 , temp % dim ( 1 ) call temp % setValue ([ n , n ], dsqrt ( temp % di ([ n , n ])) ) end do L % sites ( rawpos )% tensor = contract ( L % sites ( rawpos )% tensor , L % sites ( rawpos )% bonds ( no )% ind , temp , 'env.in' ) call L % sites ( rawpos )% tensor % setName ( 'env.out' , L % sites ( rawpos )% bonds ( no )% ind ) end subroutine subroutine spit_env_whole ( L ) class ( lattice ), intent ( inout ) :: L integer :: i , k call L % check_unempty () do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then if ( L % sites ( i )% info % li ( 'absorb_env' )) then do k = 1 , L % sites ( i )% nb_num call L % spit_env_inner ( i , k ) end do end if end if end do end subroutine subroutine spit_env_pos_bond ( L , pos1 , pos2 ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) integer :: n , rawpos1 , rawpos2 , no , nb_no type ( tensor ) :: temp character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) call L % get_bond ( pos1 , no , ind , pos2 , nb_no , nb_ind ) if ( L % sites ( rawpos1 )% info % li ( 'absorb_env' )) call L % spit_env_inner ( rawpos1 , no ) if ( L % sites ( rawpos2 )% info % li ( 'absorb_env' )) call L % spit_env_inner ( rawpos2 , nb_no ) end subroutine subroutine spit_env_name_bond ( L , name1 , name2 ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name1 , name2 integer :: n , rawpos1 , rawpos2 , no , nb_no type ( tensor ) :: temp character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( name1 ) rawpos2 = L % get_rawpos ( name2 ) call L % get_bond ( name1 , no , ind , name2 , nb_no , nb_ind ) if ( L % sites ( rawpos1 )% info % li ( 'absorb_env' )) call L % spit_env_inner ( rawpos1 , no ) if ( L % sites ( rawpos2 )% info % li ( 'absorb_env' )) call L % spit_env_inner ( rawpos2 , nb_no ) end subroutine subroutine spit_env_inner ( L , rawpos , no ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: rawpos , no integer :: n type ( tensor ) :: temp temp = L % sites ( rawpos )% bonds ( no )% env do n = 1 , temp % dim ( 1 ) call temp % setValue ([ n , n ], 1 / dsqrt ( temp % di ([ n , n ])) ) end do L % sites ( rawpos )% tensor = contract ( L % sites ( rawpos )% tensor , L % sites ( rawpos )% bonds ( no )% ind , temp , 'env.in' ) call L % sites ( rawpos )% tensor % setName ( 'env.out' , L % sites ( rawpos )% bonds ( no )% ind ) end subroutine ! copy subroutine copy_lat ( L , L_old ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old character ( len = max_char_length ) :: dir , dir2 , name , name2 logical :: exist , exist2 integer :: i , j , nb_rawpos , nb_no call L % clean () if (. not . L_old % empty_tag ) then call L % initialize ( L_old % name , L_old % L1 , L_old % L2 , L_old % max_nb_num ) L % name_dic = L_old % name_dic L % info = L_old % info L % raw_pos = L_old % raw_pos L % max_site_num = L_old % max_site_num do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then L % sites ( i ) = L_old % sites ( i ) end if end do end if end subroutine subroutine copy_site ( S , S_old ) class ( site ), intent ( inout ), target :: S type ( site ), intent ( in ) :: S_old call clean_site ( S ) S % pos = S_old % pos if ( allocated ( S % bonds )) then if ( size ( S % bonds ) /= size ( S_old % bonds )) then deallocate ( S % bonds ) end if end if if (. not . allocated ( S % bonds )) allocate ( S % bonds ( size ( S_old % bonds ))) S % bonds = S_old % bonds S % name = S_old % name S % tensor_save_tag = S_old % tensor_save_tag S % back_up_tag = S_old % back_up_tag S % tensor_bac = S_old % tensor_bac if ( S_old % tensor_save_tag ) then S % tensor_save = S_old % tensor_save S % tensor => S % tensor_save else S % tensor => S_old % tensor end if S % nb_num = S_old % nb_num S % con_tag = S_old % con_tag S % exist_tag = S_old % exist_tag S % info = S_old % info end subroutine subroutine set_bond_as_pure ( L , L_old ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old character ( len = max_char_length ) :: dir , dir2 , name , name2 integer :: i , j , nb_rawpos , nb_no call L % check_unempty () do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos if ( nb_rawpos > i ) then name = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name if ( L % check_exist ( name ). and . L % check_exist ( name2 ) . and . . not . L % check_exist_bond ( name , name2 )) then nb_no = L_old % sites ( i )% bonds ( j )% nb_no dir = L_old % sites ( i )% bonds ( j )% ind dir2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind call L % set_bond ( name , name2 , dir , dir2 ) end if end if end do end if end do end subroutine subroutine set_bond_as_cluster ( L , L_old , clusters ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old type ( lattice ), target , intent ( in ) :: clusters (:,:) character ( len = max_char_length ) :: ind1 , ind2 , name1 , name2 , actual_name1 , actual_name2 , actual_ind1 , actual_ind2 logical :: found1 , found2 , incl1 , incl2 integer :: i , j , k , m , n , p , nb_rawpos , no , nb_no , L1 , L2 integer , allocatable :: nos (:), nb_nos (:) character ( len = max_char_length ), allocatable :: inds (:), nb_inds (:) type ( lattice ), pointer :: belong1 , belong2 L1 = size ( clusters , 1 ) L2 = size ( clusters , 2 ) call L % check_unempty () do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos !write(*,*)'########',trim(L_old%sites(i)%name),'#',trim(L_old%sites(nb_rawpos)%name) if ( nb_rawpos > i ) then found1 = . false . found2 = . false . name1 = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name ind1 = L_old % sites ( i )% bonds ( j )% ind nb_no = L_old % sites ( i )% bonds ( j )% nb_no ind2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind !write(*,*)trim(ind1),' ',trim(ind2) if ( L % check_exist ( name1 )) then found1 = . true . actual_name1 = name1 incl1 = . false . actual_ind1 = ind1 else do m = 1 , L1 do n = 1 , L2 if ( . not . clusters ( m , n )% empty_tag ) then if ( clusters ( m , n )% check_exist ( name1 )) then actual_name1 = clusters ( m , n )% get_name ([ 1 , 1 ]) if ( found1 ) call wc_error_stop ( 'lattice.set_bond_as' , 'clusters overlap!' ) found1 = . true . incl1 = . true . belong1 => clusters ( m , n ) !write(*,*)'belong1,',name1 !call belong1%draw('belong1') if (. not . L % check_exist ( actual_name1 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'cluster of ' & // trim ( actual_name1 ) // ' missing in lattice!' ) end if end if end if end do end do end if if ( L % check_exist ( name2 )) then found2 = . true . actual_name2 = name2 incl2 = . false . actual_ind2 = ind2 else do m = 1 , L1 do n = 1 , L2 if ( . not . clusters ( m , n )% empty_tag ) then if ( clusters ( m , n )% check_exist ( name2 )) then actual_name2 = clusters ( m , n )% get_name ([ 1 , 1 ]) if ( found2 ) call wc_error_stop ( 'lattice.set_bond_as' , 'clusters overlap!' ) found2 = . true . incl2 = . true . belong2 => clusters ( m , n ) !write(*,*)'belong2,',name2 !call belong2%draw('belong2') if (. not . L % check_exist ( actual_name2 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'cluster of ' & // trim ( actual_name2 ) // ' missing in lattice!' ) end if end if end if end do end do end if if ( found1 . and . found2 ) then if ( incl1 . and . incl2 ) then if ( associated ( belong1 , belong2 )) then ! in same cluster if (. not . belong1 % check_exist_bond ( name1 , name2 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'bond in cluster missing! from ' & // trim ( name1 ) // ' to ' // trim ( name2 )) else cycle ! do nothing end if end if end if if ( incl1 ) then if (. not . belong1 % check_exist_bond ( actual_name1 , name1 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'bond in cluster missing! from ' & // trim ( name1 ) // ' to ' // trim ( actual_name1 )) end if call belong1 % get_bonds ( actual_name1 , nos , inds , name1 , nb_nos , nb_inds ) do k = 1 , size ( nb_inds ) !write(*,*)'-----1',trim(inds(k)),'-',trim(nb_inds(k)) if ( ind1 == nb_inds ( k )) actual_ind1 = inds ( k ) end do end if if ( incl2 ) then if (. not . belong2 % check_exist_bond ( actual_name2 , name2 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'bond in cluster missing! from ' & // trim ( name2 ) // ' to ' // trim ( actual_name2 )) end if call belong2 % get_bonds ( actual_name2 , nos , inds , name2 , nb_nos , nb_inds ) do k = 1 , size ( nb_inds ) !write(*,*)'-----2',trim(inds(k)),'-',trim(nb_inds(k)) if ( ind2 == nb_inds ( k )) actual_ind2 = inds ( k ) end do end if !write(*,*)trim(actual_name1),' ',trim(actual_name2),' ',trim(actual_ind1),' ',trim(actual_ind2) if (. not . L % check_exist_bond ( actual_name1 , actual_name2 )) then call L % set_bond ( actual_name1 , actual_name2 , actual_ind1 , actual_ind2 ) end if !call L%draw('set_bond_as',check_tag=.false.) end if end if end do end if end do end subroutine subroutine set_bond_as_path ( L , L_old , clusters ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old type ( path ), target , intent ( in ) :: clusters (:,:) character ( len = max_char_length ) :: ind1 , ind2 , name1 , name2 , actual_name1 , actual_name2 logical :: found1 , found2 , incl1 , incl2 integer :: i , j , k , m , n , p , nb_rawpos , no , nb_no , L1 , L2 integer , allocatable :: nos (:), nb_nos (:) character ( len = max_char_length ), allocatable :: inds (:), nb_inds (:) type ( path ), pointer :: belong1 , belong2 L1 = size ( clusters , 1 ) L2 = size ( clusters , 2 ) call L % check_unempty () do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos !write(*,*)'########',trim(L_old%sites(i)%name),'#',trim(L_old%sites(nb_rawpos)%name) if ( nb_rawpos > i ) then found1 = . false . found2 = . false . name1 = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name ind1 = L_old % sites ( i )% bonds ( j )% ind nb_no = L_old % sites ( i )% bonds ( j )% nb_no ind2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind !write(*,*)trim(ind1),' ',trim(ind2) if ( L % check_exist ( name1 )) then found1 = . true . actual_name1 = name1 incl1 = . false . else do m = 1 , L1 do n = 1 , L2 if ( clusters ( m , n )% get_num () > 0 ) then if ( clusters ( m , n )% check_contain ( name1 )) then actual_name1 = clusters ( m , n )% get_name () if ( found1 ) call wc_error_stop ( 'lattice.set_bond_as' , 'clusters overlap!' ) found1 = . true . incl1 = . true . belong1 => clusters ( m , n ) if (. not . L % check_exist ( actual_name1 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'cluster of ' & // trim ( actual_name1 ) // ' missing in lattice!' ) end if end if end if end do end do end if if ( L % check_exist ( name2 )) then found2 = . true . actual_name2 = name2 incl2 = . false . else do m = 1 , L1 do n = 1 , L2 if ( clusters ( m , n )% get_num () > 0 ) then if ( clusters ( m , n )% check_contain ( name2 )) then actual_name2 = clusters ( m , n )% get_name () if ( found2 ) call wc_error_stop ( 'lattice.set_bond_as' , 'clusters overlap!' ) found2 = . true . incl2 = . true . belong2 => clusters ( m , n ) if (. not . L % check_exist ( actual_name2 )) then call wc_error_stop ( 'lattice.set_bond_as' , 'cluster of ' & // trim ( actual_name2 ) // ' missing in lattice!' ) end if end if end if end do end do end if if ( found1 . and . found2 ) then if ( incl1 . and . incl2 ) then if ( associated ( belong1 , belong2 )) cycle ! in same cluster,do nothing end if if (. not . L % check_exist_bond ( actual_name1 , actual_name2 )) then call L % set_bond ( actual_name1 , actual_name2 , ind1 , ind2 ) end if end if end if end do end if end do end subroutine function transpose_lat ( L_old ) result ( L ) type ( lattice ) :: L class ( lattice ), intent ( in ) :: L_old integer :: i , j , pos ( 2 ), nb_rawpos , nb_no character ( len = max_char_length ) :: dir , dir2 , name , name2 type ( dictionary ), pointer :: pinfo if (. not . L_old % empty_tag ) then call L % initialize ( L_old % name , L_old % L2 , L_old % L1 , L_old % max_nb_num ) L % info = L_old % info do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos call L % add ([ pos ( 2 ), pos ( 1 )], L_old % sites ( i )% name , L_old % sites ( i )% tensor , L_old % sites ( i )% tensor_save_tag ) if ( L_old % sites ( i )% con_tag ) call L % set_contag ( L_old % sites ( i )% name ,. true .) call L % point_info ( L_old % sites ( i )% name , pinfo ) pinfo = L_old % sites ( i )% info end if end do do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos if ( nb_rawpos >= i ) then nb_no = L_old % sites ( i )% bonds ( j )% nb_no dir = L_old % sites ( i )% bonds ( j )% ind dir2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind name = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name call L % set_bond ( name , name2 , dir , dir2 ) end if end do end if end do end if end function subroutine copy_line ( L , line , L_old , line2 , nline ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old integer , intent ( in ) :: line , line2 , nline integer :: i , j , k , L1_old , L2_old , pos ( 2 ), nb_pos ( 2 ), nb_rawpos , nb_no , line2_ character ( len = max_char_length ) :: dir , dir2 , name , name2 call L % check_unempty () if ( all ( L_old % raw_pos == 0 )) return ! nothing to copy call L_old % get_size ( L1_old , L2_old ) if ( line2 >= 0 ) then ! line2=-1 for last line line2_ = line2 else do i = L1_old , 1 , - 1 if ( any ( L_old % raw_pos ( i ,:) > 0 )) then line2_ = i + line2 + 1 exit end if end do end if if (. not .( 1 <= line . and . line + nline - 1 <= L % L1 )) then call wc_error_stop ( 'lattice.copy_line' , 'Input for lattice: ' // trim ( L % name ) // ' is out of range' ) end if if (. not .( 1 <= line2_ . and . line2_ + nline - 1 <= L1_old )) then call wc_error_stop ( 'lattice.copy_line' , 'Input for lattice: ' // trim ( L_old % get_name ()) // ' is out of range' ) end if do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2_ . and . pos ( 1 ) <= line2_ + nline - 1 ) then call L % add ([ pos ( 1 ) - line2_ + line , pos ( 2 )], L_old % sites ( i )% name , L_old % sites ( i )% tensor , L_old % sites ( i )% tensor_save_tag ) if ( L_old % sites ( i )% con_tag ) call L % set_contag ( L_old % sites ( i )% name ,. true .) end if end if end do do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2_ . and . pos ( 1 ) <= line2_ + nline - 1 ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos nb_pos = L_old % sites ( nb_rawpos )% pos if ( nb_rawpos > i . and . nb_pos ( 1 ) >= line2_ . and . nb_pos ( 1 ) <= line2_ + nline - 1 ) then nb_no = L_old % sites ( i )% bonds ( j )% nb_no dir = L_old % sites ( i )% bonds ( j )% ind dir2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind name = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name call L % set_bond ( name , name2 , dir , dir2 ) end if end do end if end if end do end subroutine subroutine copy_line_ten ( L , line , L_old , line2 , nline ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old integer , intent ( in ) :: line , line2 , nline integer :: i , j , k , L1_old , L2_old , pos ( 2 ), nb_pos ( 2 ), nb_rawpos , nb_no , line2_ character ( len = max_char_length ) :: dir , dir2 , name , name2 call L % check_unempty () if ( all ( L_old % raw_pos == 0 )) return ! nothing to copy call L_old % get_size ( L1_old , L2_old ) if ( line2 >= 0 ) then ! line2=-1 for last line line2_ = line2 else do i = L1_old , 1 , - 1 if ( any ( L_old % raw_pos ( i ,:) > 0 )) then line2_ = i + line2 + 1 exit end if end do end if if (. not .( 1 <= line . and . line + nline - 1 <= L % L1 )) then call wc_error_stop ( 'lattice.copy_line' , 'Input for lattice: ' // trim ( L % name ) // ' is out of range' ) end if if (. not .( 1 <= line2_ . and . line2_ + nline - 1 <= L1_old )) then call wc_error_stop ( 'lattice.copy_line' , 'Input for lattice: ' // trim ( L_old % get_name ()) // ' is out of range' ) end if do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2_ . and . pos ( 1 ) <= line2_ + nline - 1 ) then call L % add ([ pos ( 1 ) - line2_ + line , pos ( 2 )], L_old % sites ( i )% name , L_old % sites ( i )% tensor ,. true .) if ( L_old % sites ( i )% con_tag ) call L % set_contag ( L_old % sites ( i )% name ,. true .) end if end if end do do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2_ . and . pos ( 1 ) <= line2_ + nline - 1 ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos nb_pos = L_old % sites ( nb_rawpos )% pos if ( nb_rawpos > i . and . nb_pos ( 1 ) >= line2_ . and . nb_pos ( 1 ) <= line2_ + nline - 1 ) then nb_no = L_old % sites ( i )% bonds ( j )% nb_no dir = L_old % sites ( i )% bonds ( j )% ind dir2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind name = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name call L % set_bond ( name , name2 , dir , dir2 ) end if end do end if end if end do end subroutine subroutine copy_line_link ( L , line , L_old , line2 , nline ) class ( lattice ), intent ( inout ) :: L type ( lattice ), intent ( in ) :: L_old integer , intent ( in ) :: line , line2 , nline integer :: i , j , k , L1_old , L2_old , pos ( 2 ), nb_pos ( 2 ), nb_rawpos , nb_no , line2_ character ( len = max_char_length ) :: dir , dir2 , name , name2 call L % check_unempty () if ( all ( L_old % raw_pos == 0 )) return ! nothing to copy call L_old % get_size ( L1_old , L2_old ) if ( line2 >= 0 ) then ! line2=-1 for last line line2_ = line2 else do i = L1_old , 1 , - 1 if ( any ( L_old % raw_pos ( i ,:) > 0 )) then line2_ = i + line2 + 1 exit end if end do end if if (. not .( 1 <= line . and . line + nline - 1 <= L % L1 )) then call wc_error_stop ( 'lattice.copy_line' , 'Input for lattice: ' // trim ( L % name ) // ' is out of range' ) end if if (. not .( 1 <= line2_ . and . line2_ + nline - 1 <= L1_old )) then call wc_error_stop ( 'lattice.copy_line' , 'Input for lattice: ' // trim ( L_old % get_name ()) // ' is out of range' ) end if do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2_ . and . pos ( 1 ) <= line2_ + nline - 1 ) then call L % add ([ pos ( 1 ) - line2_ + line , pos ( 2 )], L_old % sites ( i )% name , L_old % sites ( i )% tensor ,. false .) if ( L_old % sites ( i )% con_tag ) call L % set_contag ( L_old % sites ( i )% name ,. true .) end if end if end do do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2_ . and . pos ( 1 ) <= line2_ + nline - 1 ) then do j = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( j )% nb_rawpos nb_pos = L_old % sites ( nb_rawpos )% pos if ( nb_rawpos > i . and . nb_pos ( 1 ) >= line2_ . and . nb_pos ( 1 ) <= line2_ + nline - 1 ) then nb_no = L_old % sites ( i )% bonds ( j )% nb_no dir = L_old % sites ( i )% bonds ( j )% ind dir2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind name = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name call L % set_bond ( name , name2 , dir , dir2 ) end if end do end if end if end do end subroutine subroutine mirror_con ( L , L_old , line2 , nline ) class ( lattice ), intent ( inout ), target :: L type ( lattice ), intent ( in ) :: L_old integer , intent ( in ) :: line2 , nline integer :: i , j , k , L1_old , L2_old , pos ( 2 ), nb_pos ( 2 ), rawpos , nb_rawpos , nb_no , tn_num character ( len = max_char_length ) :: name , name2 , ind , ind2 type ( tensor ), pointer :: tn_pointer call L % clean () call L_old % get_size ( L1_old , L2_old ) if (. not .( 1 <= line2 . and . line2 + nline - 1 <= L1_old )) then call writemess ( 'Input for lattice:' + L_old % get_name () + '_do not statisfy 1<=line2<=line2+nline-1<=height' ) call wc_error_stop end if call L % initialize ( L_old % name + '_mirror' , 2 * L_old % L1 , L_old % L2 , L_old % max_nb_num ) tn_num = 0 do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2 . and . pos ( 1 ) <= line2 + nline - 1 ) then tn_num = tn_num + 1 call L % add ([ pos ( 1 ) - line2 + 1 , pos ( 2 )], L_old % sites ( i )% name , L_old % sites ( i )% tensor ,. false .) call L % set_contag ( L_old % sites ( i )% name , L_old % sites ( i )% con_tag ) call L % add ([ line2 + 2 * nline - pos ( 1 ), pos ( 2 )], 'mir_' + L_old % sites ( i )% name , L_old % sites ( i )% tensor ,. true .) call L % set_contag ( 'mir_' + L_old % sites ( i )% name ,. not . L_old % sites ( i )% con_tag ) end if end if end do do i = 1 , L_old % max_site_num if ( L_old % sites ( i )% exist_tag ) then pos = L_old % sites ( i )% pos if ( pos ( 1 ) >= line2 . and . pos ( 1 ) <= line2 + nline - 1 ) then do k = 1 , L_old % sites ( i )% nb_num nb_rawpos = L_old % sites ( i )% bonds ( k )% nb_rawpos nb_pos = L_old % sites ( nb_rawpos )% pos name = L_old % sites ( i )% name name2 = L_old % sites ( nb_rawpos )% name nb_no = L_old % sites ( i )% bonds ( k )% nb_no ind = L_old % sites ( i )% bonds ( k )% ind ind2 = L_old % sites ( nb_rawpos )% bonds ( nb_no )% ind if ( nb_rawpos > i . and . nb_pos ( 1 ) >= line2 . and . nb_pos ( 1 ) <= line2 + nline - 1 ) then call L % set_bond ( name , name2 , ind , ind2 ) call L % set_bond ( 'mir_' + name , 'mir_' + name2 , 'mir_' + ind , 'mir_' + ind2 ) call L % get_tensor_link ( 'mir_' + name , tn_pointer ) call tn_pointer % setname ( ind , 'mir_' + ind ) call L % get_tensor_link ( 'mir_' + name2 , tn_pointer ) call tn_pointer % setname ( ind2 , 'mir_' + ind2 ) else if ( nb_pos ( 1 ) > line2 + nline - 1 . or . nb_pos ( 1 ) < line2 ) then call L % get_tensor_link ( 'mir_' + name , tn_pointer ) call tn_pointer % setname ( ind , 'mir_' + ind ) call L % set_bond ( name , 'mir_' + name , ind , 'mir_' + ind ) end if end do end if end if end do end subroutine ! basic operations subroutine back_up_pos ( L , pos ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) if (. not . associated ( L % sites ( rawpos )% tensor )) then call wc_error_stop ( 'lattice.backup' , 'no tensor at ' // str ( pos )) end if L % sites ( rawpos )% tensor_bac = L % sites ( rawpos )% tensor L % sites ( rawpos )% back_up_tag = . true . end subroutine subroutine back_up_name ( L , name ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name integer :: rawpos rawpos = L % get_rawpos ( name ) if (. not . associated ( L % sites ( rawpos )% tensor )) then call wc_error_stop ( 'lattice.backup' , 'no tensor at ' // name ) end if L % sites ( rawpos )% tensor_bac = L % sites ( rawpos )% tensor L % sites ( rawpos )% back_up_tag = . true . end subroutine subroutine restore_pos ( L , pos ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) if (. not . associated ( L % sites ( rawpos )% tensor )) then call wc_error_stop ( 'lattice.restore' , 'no tensor at ' // str ( pos )) end if if (. not . L % sites ( rawpos )% back_up_tag ) then call wc_error_stop ( 'lattice.restore' , 'tensor at ' // trim ( str ( pos )) // ' has not been backed up before in lattice ' // trim ( L % name )) end if L % sites ( rawpos )% tensor = L % sites ( rawpos )% tensor_bac L % sites ( rawpos )% back_up_tag = . false . end subroutine subroutine restore_name ( L , name ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name integer :: rawpos rawpos = L % get_rawpos ( name ) if (. not . associated ( L % sites ( rawpos )% tensor )) then call wc_error_stop ( 'lattice.restore' , 'no tensor at ' // name ) end if if (. not . L % sites ( rawpos )% back_up_tag ) then call wc_error_stop ( 'lattice.restore' , 'tensor at ' // trim ( name ) // ' has not been backed up before' ) end if L % sites ( rawpos )% tensor = L % sites ( rawpos )% tensor_bac L % sites ( rawpos )% back_up_tag = . false . end subroutine function get_pos ( L , name ) result ( pos ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name integer :: pos ( 2 ), rawpos rawpos = L % get_rawpos ( name ) pos = L % sites ( rawpos )% pos end function function bonds_num_pos ( L , pos1 , pos2 ) result ( res ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) integer :: res integer :: rawpos1 , rawpos2 rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) res = L % bonds_num_rawpos ( rawpos1 , rawpos2 ) end function function bonds_num_name ( L , name1 , name2 ) result ( res ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name1 , name2 integer :: res integer :: rawpos1 , rawpos2 rawpos1 = L % get_rawpos ( name1 ) rawpos2 = L % get_rawpos ( name2 ) res = L % bonds_num_rawpos ( rawpos1 , rawpos2 ) end function function bonds_num_rawpos ( L , rawpos1 , rawpos2 ) result ( res ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: rawpos1 , rawpos2 integer :: res integer :: i call L % check_unempty () res = 0 do i = 1 , L % sites ( rawpos1 )% nb_num if ( L % sites ( rawpos1 )% bonds ( i )% nb_rawpos == rawpos2 ) res = res + 1 end do end function integer function get_rawpos_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) call L % check_unempty () call L % check_boundary ( pos ) get_rawpos_pos = L % raw_pos ( pos ( 1 ), pos ( 2 )) if ( get_rawpos_pos <= 0 ) then call writemess ( trim ( str ( pos )) // ' is empty in Lattice ' // trim ( L % name )) call wc_error_stop end if end function integer function get_rawpos_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name call L % check_unempty () get_rawpos_name = L % name_dic % val ( name ) if ( get_rawpos_name <= 0 ) then call writemess ( trim ( name ) // ' is empty in Lattice ' // trim ( L % name )) call wc_error_stop end if end function subroutine add_from_ten ( L , pos , my_name , my_tensor , save_tag ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: my_name type ( tensor ), intent ( in ), optional :: my_tensor logical , intent ( in ), optional :: save_tag integer :: rawpos call L % check_unempty () call L % check_empty ( pos ) call L % name_dic % add ( my_name , rawpos ) L % raw_pos ( pos ( 1 ), pos ( 2 )) = rawpos L % sites ( rawpos )% pos = pos L % sites ( rawpos )% name = my_name L % sites ( rawpos )% exist_tag = . true . allocate ( L % sites ( rawpos )% bonds ( L % max_nb_num )) if ( present ( save_tag )) then L % sites ( rawpos )% tensor_save_tag = save_tag else L % sites ( rawpos )% tensor_save_tag = . false . end if if ( L % sites ( rawpos )% tensor_save_tag ) then L % sites ( rawpos )% tensor => L % sites ( rawpos )% tensor_save end if if ( present ( my_tensor )) call L % set_tensor ( my_name , my_tensor , L % sites ( rawpos )% tensor_save_tag ) end subroutine subroutine add_from_lat_pos ( L , pos , lat , pos2 , save_tag ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ), pos2 ( 2 ) type ( lattice ), intent ( in ) :: lat logical , intent ( in ), optional :: save_tag character ( len = max_char_length ) :: my_name type ( tensor ), pointer :: my_tensor call lat % check_unempty ( pos2 ) my_name = lat % get_name ( pos2 ) call lat % get_tensor_link ( pos2 , my_tensor ) if ( associated ( my_tensor )) then call L % add ( pos , my_name , my_tensor , save_tag ) else call L % add ( pos , my_name ) end if end subroutine subroutine rename_pos ( L , pos , new_name ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: new_name integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % name_dic % rename ( L % sites ( rawpos )% name , new_name ) L % sites ( rawpos )% name = new_name end subroutine subroutine rename_name ( L , old_name , new_name ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: old_name , new_name integer :: rawpos rawpos = L % get_rawpos ( old_name ) call L % name_dic % rename ( old_name , new_name ) L % sites ( rawpos )% name = new_name end subroutine subroutine delete_pos ( L , pos ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos , nb_rawpos , i rawpos = L % get_rawpos ( pos ) call L % name_dic % del ( L % sites ( rawpos )% name ) L % raw_pos ( pos ( 1 ), pos ( 2 )) = 0 do i = 1 , L % sites ( rawpos )% nb_num nb_rawpos = L % sites ( rawpos )% bonds ( i )% nb_rawpos call L % remove_nb ( nb_rawpos , rawpos ) end do call clean_site ( L % sites ( rawpos )) end subroutine subroutine delete_name ( L , name ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name integer :: rawpos , pos ( 2 ), nb_rawpos , i rawpos = L % get_rawpos ( name ) call L % name_dic % del ( name ) pos = L % sites ( rawpos )% pos L % raw_pos ( pos ( 1 ), pos ( 2 )) = 0 do i = 1 , L % sites ( rawpos )% nb_num nb_rawpos = L % sites ( rawpos )% bonds ( i )% nb_rawpos call L % remove_nb ( nb_rawpos , rawpos ) end do call clean_site ( L % sites ( rawpos )) end subroutine subroutine move_pos ( L , pos , new_pos ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ), new_pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) if ( rawpos /= L % raw_pos ( new_pos ( 1 ), new_pos ( 2 ))) then ! do nothing when unmoved call L % check_empty ( new_pos ) L % raw_pos ( pos ( 1 ), pos ( 2 )) = 0 L % raw_pos ( new_pos ( 1 ), new_pos ( 2 )) = rawpos L % sites ( rawpos )% pos = new_pos end if end subroutine subroutine move_row ( L , row , new_row ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: row , new_row integer :: j if ( row < 1 . or . row > L % L1 ) then call wc_error_stop ( 'lattice.move_row' , 'Source row out of range' ) end if if ( new_row < 1 . or . new_row > L % L1 ) then call wc_error_stop ( 'lattice.move_row' , 'Target row out of range' ) end if do j = 1 , L % L2 if ( L % check_exist ([ row , j ])) then if ( L % check_exist ([ new_row , j ])) then call wc_error_stop ( 'lattice.move_row' , 'Target row occupied' ) end if call L % move ([ row , j ],[ new_row , j ]) end if end do end subroutine subroutine move_column ( L , column , new_column ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: column , new_column integer :: i if ( column < 1 . or . column > L % L2 ) then call wc_error_stop ( 'lattice.move_column' , 'Source column out of range' ) end if if ( new_column < 1 . or . new_column > L % L2 ) then call wc_error_stop ( 'lattice.move_column' , 'Target column out of range' ) end if do i = 1 , L % L2 if ( L % check_exist ([ i , column ])) then if ( L % check_exist ([ i , new_column ])) then call wc_error_stop ( 'lattice.move_column' , 'Target column occupied' ) end if call L % move ([ i , column ],[ i , new_column ]) end if end do end subroutine subroutine move_name ( L , name , new_pos ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name integer , intent ( in ) :: new_pos ( 2 ) integer :: rawpos , old_pos ( 2 ) rawpos = L % get_rawpos ( name ) if ( rawpos /= L % raw_pos ( new_pos ( 1 ), new_pos ( 2 ))) then ! do nothing when unmoved call L % check_empty ( new_pos ) old_pos = L % sites ( rawpos )% pos L % raw_pos ( old_pos ( 1 ), old_pos ( 2 )) = 0 L % raw_pos ( new_pos ( 1 ), new_pos ( 2 )) = rawpos L % sites ( rawpos )% pos = new_pos end if end subroutine type ( tensor ) function get_tensor_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) get_tensor_pos = L % sites ( rawpos )% tensor end function type ( tensor ) function get_tensor_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name integer :: rawpos rawpos = L % get_rawpos ( name ) get_tensor_name = L % sites ( rawpos )% tensor end function subroutine get_tensor_link_pos ( L , pos , tlink ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) type ( tensor ), pointer , intent ( out ) :: tlink integer :: rawpos rawpos = L % get_rawpos ( pos ) tlink => L % sites ( rawpos )% tensor end subroutine subroutine get_tensor_link_name ( L , name , tlink ) class ( lattice ), intent ( in ) :: L character ( len =* ), optional , intent ( in ) :: name type ( tensor ), pointer , intent ( out ) :: tlink integer :: rawpos rawpos = L % get_rawpos ( name ) tlink => L % sites ( rawpos )% tensor end subroutine subroutine get_env_link_pos ( L , pos , no , tlink ) class ( lattice ), intent ( in ), target :: L integer , intent ( in ) :: pos ( 2 ), no type ( tensor ), pointer , intent ( out ) :: tlink integer :: rawpos rawpos = L % get_rawpos ( pos ) if (. not . L % sites ( rawpos )% bonds ( no )% env_tag ) then call wc_error_stop ( 'lattice.get_env_link' , 'env at ' // trim ( str ( pos )) // '-' // trim ( str ( no )) // ' does not exist' ) end if tlink => L % sites ( rawpos )% bonds ( no )% env end subroutine function get_env_bond_pos ( L , pos1 , pos2 ) result ( res ) class ( lattice ), intent ( in ), target :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) type ( tensor ) :: res integer :: rawpos1 , rawpos2 , no , nb_no character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) call L % get_bond ( pos1 , no , ind , pos2 , nb_no , nb_ind ) if (. not . L % sites ( rawpos1 )% bonds ( no )% env_tag ) then call wc_error_stop ( 'lattice.get_env_link' , 'env at ' // trim ( str ( pos1 )) // '-' // trim ( str ( pos2 )) // ' does not exist' ) end if res = L % sites ( rawpos1 )% bonds ( no )% env end function subroutine set_env_bond_pos ( L , pos1 , pos2 , env ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos1 ( 2 ), pos2 ( 2 ) type ( tensor ), intent ( in ) :: env integer :: rawpos1 , rawpos2 , no , nb_no character ( len = max_char_length ) :: ind , nb_ind rawpos1 = L % get_rawpos ( pos1 ) rawpos2 = L % get_rawpos ( pos2 ) call L % get_bond ( pos1 , no , ind , pos2 , nb_no , nb_ind ) if (. not . L % sites ( rawpos1 )% bonds ( no )% env_tag ) then call wc_error_stop ( 'lattice.get_env_link' , 'env at ' // trim ( str ( pos1 )) // '-' // trim ( str ( pos2 )) // ' does not exist' ) end if L % sites ( rawpos1 )% bonds ( no )% env = env L % sites ( rawpos2 )% bonds ( nb_no )% env = env end subroutine subroutine get_env_link_name ( L , name , no , tlink ) class ( lattice ), intent ( in ), target :: L character ( len =* ), optional , intent ( in ) :: name integer , intent ( in ) :: no type ( tensor ), pointer , intent ( out ) :: tlink integer :: rawpos rawpos = L % get_rawpos ( name ) if (. not . L % sites ( rawpos )% bonds ( no )% env_tag ) then call wc_error_stop ( 'lattice.get_env_link' , 'env at ' // trim ( name ) // '-' // trim ( str ( no )) // ' does not exist' ) end if tlink => L % sites ( rawpos )% bonds ( no )% env end subroutine subroutine update_tensor_pos ( L , pos , new_tensor ) class ( lattice ), intent ( inout ) :: L class ( tensor ), intent ( in ) :: new_tensor integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) L % sites ( rawpos )% tensor = new_tensor end subroutine subroutine update_tensor_name ( L , name , new_tensor ) class ( lattice ), intent ( inout ) :: L class ( tensor ), intent ( in ) :: new_tensor character ( len =* ), intent ( in ) :: name integer :: rawpos rawpos = L % get_rawpos ( name ) L % sites ( rawpos )% tensor = new_tensor end subroutine subroutine set_tensor_name ( L , name , my_tensor , save_tag_ ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name type ( tensor ), intent ( in ), target :: my_tensor logical , intent ( in ), optional :: save_tag_ logical :: save_tag integer :: rawpos if ( present ( save_tag_ )) then save_tag = save_tag_ else save_tag = . false . end if rawpos = L % get_rawpos ( name ) if ( save_tag ) then L % sites ( rawpos )% tensor_save = my_tensor L % sites ( rawpos )% tensor => L % sites ( rawpos )% tensor_save else L % sites ( rawpos )% tensor => my_tensor end if L % sites ( rawpos )% tensor_save_tag = save_tag end subroutine subroutine set_tensor_pos ( L , pos , my_tensor , save_tag_ ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) type ( tensor ), intent ( in ), target :: my_tensor logical , intent ( in ), optional :: save_tag_ logical :: save_tag integer :: rawpos if ( present ( save_tag_ )) then save_tag = save_tag_ else save_tag = . false . end if rawpos = L % get_rawpos ( pos ) if ( save_tag ) then L % sites ( rawpos )% tensor_save = my_tensor L % sites ( rawpos )% tensor => L % sites ( rawpos )% tensor_save else L % sites ( rawpos )% tensor => my_tensor end if L % sites ( rawpos )% tensor_save_tag = save_tag end subroutine subroutine set_bond_pos ( L , pos , pos2 , dir_ , dir2_ ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ), pos2 ( 2 ) character ( len =* ), optional , intent ( in ) :: dir_ , dir2_ character ( len = max_char_length ) :: dir , dir2 logical :: exist , exist2 integer :: rawpos , rawpos2 rawpos = L % get_rawpos ( pos ) rawpos2 = L % get_rawpos ( pos2 ) if ( present ( dir_ )) then dir = dir_ else dir = trim ( L % sites ( rawpos )% name + '.' + L % sites ( rawpos2 )% name ) end if if ( present ( dir2_ )) then dir2 = dir2_ else dir2 = trim ( L % sites ( rawpos2 )% name + '.' + L % sites ( rawpos )% name ) end if call set_bond_rawpos ( L , rawpos , dir , rawpos2 , dir2 , exist , exist2 ) if ( exist ) call wc_error_stop ( 'set_bond' , dir + '_existed at (' + pos ( 1 ) + ',' + pos ( 2 ) + ') for lattice_' + L % name ) if ( exist2 ) call wc_error_stop ( 'set_bond' , dir2 + '_existed at (' + pos2 ( 1 ) + ',' + pos2 ( 2 ) + ') for lattice_' + L % name ) end subroutine subroutine set_bond_name ( L , name , name2 , dir_ , dir2_ ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name , name2 character ( len =* ), optional , intent ( in ) :: dir_ , dir2_ character ( len = max_char_length ) :: dir , dir2 logical :: exist , exist2 integer :: rawpos , rawpos2 rawpos = L % get_rawpos ( name ) if ( rawpos <= 0 ) then call wc_error_stop ( 'set_bond_name' , 'site: ' + name + ' donot exist' ) end if rawpos2 = L % get_rawpos ( name2 ) if ( rawpos2 <= 0 ) then call wc_error_stop ( 'set_bond_name' , 'site: ' + name2 + ' donot exist' ) end if if ( present ( dir_ )) then dir = dir_ else dir = trim ( L % sites ( rawpos )% name + '.' + L % sites ( rawpos2 )% name ) end if if ( present ( dir2_ )) then dir2 = dir2_ else dir2 = trim ( L % sites ( rawpos2 )% name + '.' + L % sites ( rawpos )% name ) end if call set_bond_rawpos ( L , rawpos , dir , rawpos2 , dir2 , exist , exist2 ) if ( exist ) call wc_error_stop ( 'set_bond' , trim ( dir ) // ' existed at ' // trim ( name ) // ' for lattice ' // trim ( L % name )) if ( exist2 ) call wc_error_stop ( 'set_bond' , trim ( dir2 ) // ' existed at ' // trim ( name2 ) // ' for lattice ' // trim ( L % name )) end subroutine subroutine set_bond_rawpos ( L , rawpos , dir , rawpos2 , dir2 , exist , exist2 ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: rawpos , rawpos2 character ( len =* ), intent ( in ) :: dir , dir2 logical , intent ( out ) :: exist , exist2 integer :: k , no , nb_no , nb_pos ( 2 ) exist = . false . exist2 = . false . call L % check_unempty () do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% ind == dir ) then exist = . true . return end if end do do k = 1 , L % sites ( rawpos2 )% nb_num if ( L % sites ( rawpos2 )% bonds ( k )% ind == dir2 ) then exist2 = . true . return end if end do if ( L % sites ( rawpos )% nb_num < L % max_nb_num ) then L % sites ( rawpos )% nb_num = L % sites ( rawpos )% nb_num + 1 no = L % sites ( rawpos )% nb_num else call wc_error_stop ( 'set_bond' , 'site: ' // trim ( L % sites ( rawpos )% name ) // ' has reach the limit of bonds number' ) end if if ( L % sites ( rawpos2 )% nb_num < L % max_nb_num ) then L % sites ( rawpos2 )% nb_num = L % sites ( rawpos2 )% nb_num + 1 nb_no = L % sites ( rawpos2 )% nb_num else call wc_error_stop ( 'set_bond' , 'site: ' // trim ( L % sites ( rawpos2 )% name ) // ' has reach the limit of bonds number' ) end if L % sites ( rawpos )% bonds ( no )% nb_rawpos = rawpos2 L % sites ( rawpos )% bonds ( no )% ind = dir L % sites ( rawpos )% bonds ( no )% nb_no = nb_no L % sites ( rawpos2 )% bonds ( nb_no )% nb_rawpos = rawpos L % sites ( rawpos2 )% bonds ( nb_no )% ind = dir2 L % sites ( rawpos2 )% bonds ( nb_no )% nb_no = no end subroutine subroutine remove_bond_pos ( L , pos , pos2 ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ), pos2 ( 2 ) integer :: rawpos , rawpos2 rawpos = L % get_rawpos ( pos ) rawpos2 = L % get_rawpos ( pos2 ) call remove_bond_rawpos ( L , rawpos , rawpos2 ) end subroutine subroutine remove_bond_name ( L , name , name2 ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name , name2 integer :: rawpos , rawpos2 rawpos = L % get_rawpos ( name ) rawpos2 = L % get_rawpos ( name2 ) call remove_bond_rawpos ( L , rawpos , rawpos2 ) end subroutine subroutine remove_bond_rawpos ( L , rawpos , rawpos2 ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: rawpos , rawpos2 call L % remove_nb ( rawpos , rawpos2 ) call L % remove_nb ( rawpos2 , rawpos ) end subroutine character ( len = max_char_length ) function ind_name ( L , pos , no ) result ( ind ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ), no integer :: rawpos rawpos = L % get_rawpos ( pos ) if ( no > L % sites ( rawpos )% nb_num ) then call wc_error_stop ( 'ind_name' , 'Bond NO.' + no + ' at (' + pos ( 1 ) + ',' + pos ( 2 ) + ') does not exist.' ) end if ind = L % sites ( rawpos )% bonds ( no )% ind end function subroutine get_size ( L , L1 , L2 ) class ( lattice ), intent ( in ) :: L integer , intent ( out ) :: L1 , L2 integer :: k call L % check_unempty () L1 = L % L1 L2 = L % L2 end subroutine subroutine get_range ( L , left , right , top , bottom ) class ( lattice ), intent ( in ) :: L integer , intent ( out ) :: left , right , top , bottom integer :: i if ( all ( L % raw_pos == 0 )) then call wc_error_stop ( 'lattice.get_range' , 'The lattice is empty.' ) end if top = L % L1 bottom = 1 do i = 1 , L % L1 if ( any ( L % raw_pos ( i ,:) > 0 )) then if ( i < top ) top = i if ( i > bottom ) bottom = i end if end do left = L % L2 right = 1 do i = 1 , L % L2 if ( any ( L % raw_pos (:, i ) > 0 )) then if ( i < left ) left = i if ( i > right ) right = i end if end do end subroutine integer function get_max_site_num ( L ) class ( lattice ), intent ( in ) :: L call L % check_unempty () get_max_site_num = L % max_site_num end function subroutine get_bond_pos ( L , pos , no , ind , nb_pos , nb_no , nb_ind ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ), nb_pos ( 2 ) integer , intent ( out ) :: no , nb_no character ( len = max_char_length ), intent ( out ) :: ind , nb_ind integer :: k , rawpos , nb_rawpos rawpos = L % get_rawpos ( pos ) nb_rawpos = L % get_rawpos ( nb_pos ) do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% nb_rawpos == nb_rawpos ) then no = k nb_no = L % sites ( rawpos )% bonds ( k )% nb_no ind = L % sites ( rawpos )% bonds ( k )% ind nb_ind = L % sites ( nb_rawpos )% bonds ( nb_no )% ind return end if end do call wc_error_stop ( 'get_bond_pos' , 'Bond from (' + pos ( 1 ) + ',' + pos ( 2 ) + ') to (' + nb_pos ( 1 ) + ',' + nb_pos ( 2 ) + ') does not exist.' ) end subroutine subroutine get_bond_name ( L , name , no , ind , nb_name , nb_no , nb_ind ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name , nb_name integer , intent ( out ) :: no , nb_no character ( len = max_char_length ), intent ( out ) :: ind , nb_ind integer :: k , rawpos , nb_rawpos rawpos = L % get_rawpos ( name ) nb_rawpos = L % get_rawpos ( nb_name ) do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% nb_rawpos == nb_rawpos ) then no = k nb_no = L % sites ( rawpos )% bonds ( k )% nb_no ind = L % sites ( rawpos )% bonds ( k )% ind nb_ind = L % sites ( nb_rawpos )% bonds ( nb_no )% ind return end if end do call wc_error_stop ( 'get_bond_name' , 'Bond from ' + name + ' to ' + nb_name + ' does not exist.' ) end subroutine subroutine get_bonds_pos ( L , pos , no , ind , nb_pos , nb_no , nb_ind ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ), nb_pos ( 2 ) integer , allocatable , intent ( out ) :: no (:), nb_no (:) character ( len = max_char_length ), allocatable , intent ( out ) :: ind (:), nb_ind (:) integer :: k , rawpos , nb_rawpos , num rawpos = L % get_rawpos ( pos ) nb_rawpos = L % get_rawpos ( nb_pos ) num = 0 do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% nb_rawpos == nb_rawpos ) then num = num + 1 end if end do allocate ( no ( num )) allocate ( nb_no ( num )) allocate ( ind ( num )) allocate ( nb_ind ( num )) num = 0 do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% nb_rawpos == nb_rawpos ) then num = num + 1 no ( num ) = k nb_no ( num ) = L % sites ( rawpos )% bonds ( k )% nb_no ind ( num ) = L % sites ( rawpos )% bonds ( k )% ind nb_ind ( num ) = L % sites ( nb_rawpos )% bonds ( nb_no ( num ))% ind end if end do end subroutine subroutine get_bonds_name ( L , name , no , ind , nb_name , nb_no , nb_ind ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name , nb_name integer , allocatable , intent ( out ) :: no (:), nb_no (:) character ( len = max_char_length ), allocatable , intent ( out ) :: ind (:), nb_ind (:) integer :: k , rawpos , nb_rawpos , num rawpos = L % get_rawpos ( name ) nb_rawpos = L % get_rawpos ( nb_name ) num = 0 do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% nb_rawpos == nb_rawpos ) then num = num + 1 end if end do allocate ( no ( num )) allocate ( nb_no ( num )) allocate ( ind ( num )) allocate ( nb_ind ( num )) num = 0 do k = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( k )% nb_rawpos == nb_rawpos ) then num = num + 1 no ( num ) = k nb_no ( num ) = L % sites ( rawpos )% bonds ( k )% nb_no ind ( num ) = L % sites ( rawpos )% bonds ( k )% ind nb_ind ( num ) = L % sites ( nb_rawpos )% bonds ( nb_no ( num ))% ind end if end do end subroutine subroutine get_bond_no_pos ( L , pos , no , ind , nb_pos , nb_no , nb_ind ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ), no integer , intent ( out ) :: nb_no , nb_pos ( 2 ) character ( len = max_char_length ), intent ( out ) :: ind , nb_ind integer :: k , rawpos , nb_rawpos rawpos = L % get_rawpos ( pos ) if ( no > L % sites ( rawpos )% nb_num ) then call wc_error_stop ( 'get_bond_no' , 'Bond NO.' + no + ' at (' + pos ( 1 ) + ',' + pos ( 2 ) + ') does not exist.' ) end if nb_rawpos = L % sites ( rawpos )% bonds ( no )% nb_rawpos nb_no = L % sites ( rawpos )% bonds ( no )% nb_no ind = L % sites ( rawpos )% bonds ( no )% ind nb_pos = L % sites ( nb_rawpos )% pos nb_ind = L % sites ( nb_rawpos )% bonds ( nb_no )% ind end subroutine subroutine get_bond_no_name ( L , name , no , ind , nb_name , nb_no , nb_ind ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: no character ( len =* ), intent ( in ) :: name integer , intent ( out ) :: nb_no character ( len = max_char_length ), intent ( out ) :: nb_name character ( len = max_char_length ), intent ( out ) :: ind , nb_ind integer :: k , rawpos , nb_rawpos rawpos = L % get_rawpos ( name ) if ( no > L % sites ( rawpos )% nb_num ) then call wc_error_stop ( 'get_bond_no' , 'Bond NO.' + no + ' at (' + name + ') does not exist.' ) end if nb_rawpos = L % sites ( rawpos )% bonds ( no )% nb_rawpos nb_no = L % sites ( rawpos )% bonds ( no )% nb_no ind = L % sites ( rawpos )% bonds ( no )% ind nb_name = L % sites ( nb_rawpos )% name nb_ind = L % sites ( nb_rawpos )% bonds ( nb_no )% ind end subroutine character ( len = max_char_length ) function get_name_whole ( L ) class ( lattice ), intent ( in ) :: L call L % check_unempty () get_name_whole = L % name end function character ( len = max_char_length ) function get_name_site ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) get_name_site = L % sites ( rawpos )% name end function subroutine set_name_lat ( L , my_name ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: my_name call L % check_unempty () L % name = my_name end subroutine integer function get_max_nb_num ( L ) class ( lattice ), intent ( in ) :: L get_max_nb_num = L % max_nb_num end function integer function get_nb_num_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) get_nb_num_pos = L % sites ( rawpos )% nb_num end function integer function get_nb_num_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name integer :: rawpos rawpos = L % get_rawpos ( name ) get_nb_num_name = L % sites ( rawpos )% nb_num end function logical function get_contag_pos ( L , pos ) class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: pos ( 2 ) integer :: rawpos rawpos = L % get_rawpos ( pos ) get_contag_pos = L % sites ( rawpos )% con_tag end function logical function get_contag_name ( L , name ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: name integer :: rawpos rawpos = L % get_rawpos ( name ) get_contag_name = L % sites ( rawpos )% con_tag end function subroutine set_contag_pos ( L , pos , status ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ) logical , intent ( in ) :: status integer :: rawpos rawpos = L % get_rawpos ( pos ) L % sites ( rawpos )% con_tag = status end subroutine subroutine set_contag_name ( L , name , status ) class ( lattice ), intent ( inout ) :: L character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: status integer :: rawpos rawpos = L % get_rawpos ( name ) L % sites ( rawpos )% con_tag = status end subroutine subroutine invert_bond_name ( L , name , temp ) class ( lattice ), intent ( in ) :: L class ( tensor ), intent ( inout ) :: temp character ( len =* ), intent ( in ) :: name integer :: no , nb_pos ( 2 ), nb_no , rawpos , nb_rawpos rawpos = L % get_rawpos ( name ) do no = 1 , L % sites ( rawpos )% nb_num nb_rawpos = L % sites ( rawpos )% bonds ( no )% nb_rawpos nb_no = L % sites ( rawpos )% bonds ( no )% nb_no call temp % setName ( L % sites ( nb_rawpos )% bonds ( nb_no )% ind , L % sites ( rawpos )% bonds ( no )% ind ) end do end subroutine subroutine invert_bond_pos ( L , pos , temp ) class ( lattice ), intent ( in ) :: L class ( tensor ), intent ( inout ) :: temp integer , intent ( in ) :: pos ( 2 ) integer :: no , nb_pos ( 2 ), nb_no , rawpos , nb_rawpos rawpos = L % get_rawpos ( pos ) do no = 1 , L % sites ( rawpos )% nb_num nb_rawpos = L % sites ( rawpos )% bonds ( no )% nb_rawpos nb_no = L % sites ( rawpos )% bonds ( no )% nb_no call temp % setName ( L % sites ( nb_rawpos )% bonds ( nb_no )% ind , L % sites ( rawpos )% bonds ( no )% ind ) end do end subroutine integer function cut_bonds ( L , i , range ) !bond between ith and i+1th line class ( lattice ), intent ( in ) :: L integer , intent ( in ) :: i integer , intent ( in ), optional :: range integer :: j , k , no , L1 , L2 , rawpos , nb_rawpos , nb_pos ( 2 ), jfrom , jto if ( present ( range )) then jfrom = max ( 1 , i - range + 1 ) jto = i + range else jfrom = i jto = i + 1 end if call L % check_unempty () call check_boundary ( L ,[ i , 1 ]) cut_bonds = 0 do j = jfrom , i do k = 1 , L % L2 rawpos = L % raw_pos ( j , k ) if ( rawpos > 0 ) then do no = 1 , L % sites ( rawpos )% nb_num nb_rawpos = L % sites ( rawpos )% bonds ( no )% nb_rawpos if ( L % sites ( nb_rawpos )% pos ( 1 ) > i . and . L % sites ( nb_rawpos )% pos ( 1 ) <= jto ) then ! essential to pbc and cyl cut_bonds = cut_bonds + 1 end if end do end if end do end do end function integer function max_cut_bonds ( L , range ) class ( lattice ), intent ( in ) :: L integer , intent ( in ), optional :: range integer :: i max_cut_bonds = 0 do i = 1 , L % L1 - 1 max_cut_bonds = max ( max_cut_bonds , L % cut_bonds ( i , range )) end do end function !!!!!!!!!!!!!!!!!!!!!!!!! info !!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine point_info_lat ( L , dic ) class ( lattice ), intent ( inout ), target :: L type ( dictionary ), pointer , intent ( inout ) :: dic call L % check_unempty () dic => L % info end subroutine subroutine point_info_pos ( L , pos , dic ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) type ( dictionary ), pointer , intent ( inout ) :: dic integer :: rawpos rawpos = L % get_rawpos ( pos ) dic => L % sites ( rawpos )% info end subroutine subroutine point_info_name ( L , name , dic ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name type ( dictionary ), pointer , intent ( inout ) :: dic integer :: rawpos rawpos = L % get_rawpos ( name ) dic => L % sites ( rawpos )% info end subroutine subroutine dget_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( inout ) :: val call L % check_unempty () call L % info % getvalue ( val_name , val ) end subroutine subroutine zget_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( inout ) :: val call L % check_unempty () call L % info % getvalue ( val_name , val ) end subroutine subroutine iget_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name integer , intent ( inout ) :: val call L % check_unempty () call L % info % getvalue ( val_name , val ) end subroutine subroutine lget_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name logical , intent ( inout ) :: val call L % check_unempty () call L % info % getvalue ( val_name , val ) end subroutine subroutine aget_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( inout ) :: val call L % check_unempty () call L % info % getvalue ( val_name , val ) end subroutine subroutine tget_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( inout ) :: val call L % check_unempty () call L % info % getvalue ( val_name , val ) end subroutine subroutine dget_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine zget_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine iget_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name integer , intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine lget_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name logical , intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine aget_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine tget_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine dget_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine zget_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine iget_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name integer , intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine lget_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name logical , intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine aget_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine tget_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( inout ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % getvalue ( val_name , val ) end subroutine subroutine dset_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( in ) :: val call L % check_unempty () call L % info % setvalue ( val_name , val ) end subroutine subroutine zset_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( in ) :: val call L % check_unempty () call L % info % setvalue ( val_name , val ) end subroutine subroutine iset_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name integer , intent ( in ) :: val call L % check_unempty () call L % info % setvalue ( val_name , val ) end subroutine subroutine lset_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name logical , intent ( in ) :: val call L % check_unempty () call L % info % setvalue ( val_name , val ) end subroutine subroutine aset_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name character ( len =* ), intent ( in ) :: val call L % check_unempty () call L % info % setvalue ( val_name , val ) end subroutine subroutine tset_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( in ) :: val call L % check_unempty () call L % info % setvalue ( val_name , val ) end subroutine subroutine dset_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine zset_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine iset_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name integer , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine lset_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name logical , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine aset_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine tset_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine dset_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine zset_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine iset_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name integer , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine lset_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name logical , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine aset_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine tset_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % setvalue ( val_name , val ) end subroutine subroutine dinsert_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( in ) :: val call L % check_unempty () call L % info % insert ( val_name , val ) end subroutine subroutine zinsert_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( in ) :: val call L % check_unempty () call L % info % insert ( val_name , val ) end subroutine subroutine iinsert_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name integer , intent ( in ) :: val call L % check_unempty () call L % info % insert ( val_name , val ) end subroutine subroutine linsert_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name logical , intent ( in ) :: val call L % check_unempty () call L % info % insert ( val_name , val ) end subroutine subroutine ainsert_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( in ) :: val call L % check_unempty () call L % info % insert ( val_name , val ) end subroutine subroutine tinsert_info_whole ( L , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( in ) :: val call L % check_unempty () call L % info % insert ( val_name , val ) end subroutine subroutine dinsert_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine zinsert_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine iinsert_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name integer , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine linsert_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name logical , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine ainsert_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine tinsert_info_name ( L , name , val_name , val ) class ( lattice ), intent ( inout ), target :: L character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( name ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine dinsert_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name real ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine zinsert_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name complex ( 8 ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine iinsert_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name integer , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine linsert_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name logical , intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine ainsert_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name character ( len = max_char_length ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine subroutine tinsert_info_pos ( L , pos , val_name , val ) class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: pos ( 2 ) character ( len =* ), intent ( in ) :: val_name type ( tensor ), intent ( in ) :: val integer :: rawpos rawpos = L % get_rawpos ( pos ) call L % sites ( rawpos )% info % insert ( val_name , val ) end subroutine !!!!!!!!!!!!!!!!!!!!!!!!! Dynamic lattice !!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine remove_nb ( L , rawpos , nb_rawpos ) ! at rawpos, remove nb_rawpos class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: rawpos , nb_rawpos integer :: i , num , nb_rawpos2 , nb_no2 integer , allocatable :: move (:) call L % check_unempty () allocate ( move ( L % sites ( rawpos )% nb_num )) num = 0 do i = 1 , L % sites ( rawpos )% nb_num nb_rawpos2 = L % sites ( rawpos )% bonds ( i )% nb_rawpos if ( nb_rawpos2 /= nb_rawpos ) then num = num + 1 if ( num /= i ) then nb_no2 = L % sites ( rawpos )% bonds ( i )% nb_no L % sites ( nb_rawpos2 )% bonds ( nb_no2 )% nb_no = num L % sites ( rawpos )% bonds ( num ) = L % sites ( rawpos )% bonds ( i ) end if end if end do L % sites ( rawpos )% nb_num = num end subroutine subroutine move_nb ( L , rawpos , nb_rawpos1 , nb_rawpos2 ) ! at rawpos, move bonds connected to nb_rawpos1 to nb_rawpos2 class ( lattice ), intent ( inout ), target :: L integer , intent ( in ) :: rawpos , nb_rawpos1 , nb_rawpos2 integer :: i , nb_no , bond_num , nb_no2 character ( len = max_char_length ) :: old_name , old_name2 , new_name , new_name2 type ( bond ), pointer :: this_bond , nb_bond , nb_bond2 call L % check_unempty () do i = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( i )% nb_rawpos == nb_rawpos1 ) then L % sites ( nb_rawpos2 )% nb_num = L % sites ( nb_rawpos2 )% nb_num + 1 nb_no2 = L % sites ( nb_rawpos2 )% nb_num nb_no = L % sites ( rawpos )% bonds ( i )% nb_no this_bond => L % sites ( rawpos )% bonds ( i ) nb_bond => L % sites ( nb_rawpos1 )% bonds ( nb_no ) nb_bond2 => L % sites ( nb_rawpos2 )% bonds ( nb_no2 ) nb_bond2 = nb_bond this_bond % nb_rawpos = nb_rawpos2 this_bond % nb_no = nb_no2 bond_num = L % bonds_num_rawpos ( rawpos , nb_rawpos2 ) old_name = this_bond % ind new_name = L % sites ( rawpos )% name + '.' + L % sites ( nb_rawpos2 )% name if ( bond_num > 1 ) new_name = new_name + ( bond_num + 1 ) call L % sites ( rawpos )% tensor % setName ( old_name , new_name ) this_bond % ind = new_name old_name2 = nb_bond2 % ind new_name2 = L % sites ( nb_rawpos2 )% name + '.' + L % sites ( rawpos )% name if ( bond_num > 1 ) new_name2 = new_name2 + ( bond_num + 1 ) call L % sites ( nb_rawpos2 )% tensor % setName ( old_name2 , new_name2 ) nb_bond2 % ind = new_name2 end if end do end subroutine subroutine absorb ( L , pos , nb_pos ) class ( lattice ), intent ( inout ) :: L integer , intent ( in ) :: pos ( 2 ), nb_pos ( 2 ) character ( len = max_char_length ) :: leg ( 20 ), leg_nb ( 20 ) integer :: i , num , nb ( 2 ), nb_no , rawpos , nb_rawpos integer , allocatable :: move (:) call L % check_unempty () rawpos = L % get_rawpos ( pos ) nb_rawpos = L % get_rawpos ( nb_pos ) num = 0 do i = 1 , L % sites ( rawpos )% nb_num if ( L % sites ( rawpos )% bonds ( i )% nb_rawpos == nb_rawpos ) then num = num + 1 nb_no = L % sites ( rawpos )% bonds ( i )% nb_no leg ( num ) = L % sites ( rawpos )% bonds ( i )% ind leg_nb ( num ) = L % sites ( nb_rawpos )% bonds ( nb_no )% ind end if end do if ( L % sites ( rawpos )% con_tag . neqv . L % sites ( nb_rawpos )% con_tag ) then if ( num == 0 ) then L % sites ( rawpos )% tensor = L % sites ( rawpos )% tensor . kron .(. con . L % sites ( nb_rawpos )% tensor ) else L % sites ( rawpos )% tensor = contract ( L % sites ( rawpos )% tensor , leg ( 1 : num ),. con . L % sites ( nb_rawpos )% tensor , leg_nb ( 1 : num )) end if else if ( num == 0 ) then L % sites ( rawpos )% tensor = L % sites ( rawpos )% tensor . kron . L % sites ( nb_rawpos )% tensor else L % sites ( rawpos )% tensor = contract ( L % sites ( rawpos )% tensor , leg ( 1 : num ), L % sites ( nb_rawpos )% tensor , leg_nb ( 1 : num )) end if end if L % sites ( rawpos )% nb_num = L % sites ( rawpos )% nb_num - num call L % remove_nb ( rawpos , nb_rawpos ) do i = 1 , L % sites ( nb_rawpos )% nb_num if ( L % sites ( nb_rawpos )% bonds ( i )% nb_rawpos /= rawpos ) then call L % move_nb ( L % sites ( nb_rawpos )% bonds ( i )% nb_rawpos , nb_rawpos , rawpos ) end if end do L % sites ( nb_rawpos )% nb_num = 0 end subroutine ! subroutine QR(L,pos,new_name,bonds,unpair_inds) ! implicit none ! \tclass(lattice),intent(inout)::L ! end subroutine ! subroutine SVD(L,old_name,new_name1,new_name2,bonds,unpair_inds,env) ! implicit none ! \tclass(lattice),intent(inout)::L ! end subroutine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Output Info !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine draw_l ( L , filename , label_bond , fixed , check_tag , stop_tag ) class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ), optional :: filename logical , intent ( in ), optional :: label_bond , fixed , check_tag , stop_tag integer :: i if ( present ( filename )) then call L % draw_tn ( trim ( filename ), '' ,[(. false ., i = 1 , L % max_site_num )],[( - 1 , i = 1 , L % max_site_num )]& , label_bond , fixed , check_tag , stop_tag ) else call L % draw_tn ( trim ( L % name ), '' ,[(. false ., i = 1 , L % max_site_num )],[( - 1 , i = 1 , L % max_site_num )]& , label_bond , fixed , check_tag , stop_tag ) end if end subroutine subroutine draw_tn ( L , filename , tnname , includes , path , label_bond_ , fixed_ , check_tag_ , stop_tag_ ) use mod_mpi_info class ( lattice ), intent ( in ) :: L character ( len =* ), intent ( in ) :: filename character ( len =* ), intent ( in ) :: tnname logical , intent ( in ) :: includes (:) integer , intent ( in ) :: path (:) logical , intent ( in ), optional :: label_bond_ , fixed_ , check_tag_ , stop_tag_ logical :: label_bond , fixed , check_tag , stop_tag character ( len = 200 ) :: command integer :: i , j , k , nb , pos ( 2 ), nb_no , nattr if ( present ( label_bond_ )) then label_bond = label_bond_ else label_bond = . true . end if if ( present ( fixed_ )) then fixed = fixed_ else fixed = . true . end if if ( present ( check_tag_ )) then check_tag = check_tag_ else check_tag = . true . end if if ( present ( stop_tag_ )) then stop_tag = stop_tag_ else stop_tag = . true . end if if ( L % empty_tag ) then call writemess ( '-----------------------------------------------' ) call writemess ( 'empty lattice, do not draw anything' ) call writemess ( '-----------------------------------------------' ) call L % check_consistency () return end if if ( my_rank == 0 ) then open ( unit = 7878 , file = './' // trim ( filename ) // '.dot' ) write ( 7878 , * ) 'digraph G {' if ( len_trim ( tnname ) > 0 ) then write ( 7878 , * ) '  label = \"' // trim ( tnname ) // ' in ' // trim ( L % name ) // '\"' else write ( 7878 , * ) '  label = \"' // trim ( L % name ) // '\"' end if !write(*,*)includes do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then command = '  node_' + i + ' [' if ( L % sites ( i )% con_tag ) then command = command + 'style = \"filled,solid\", fillcolor = \"lemonchiffon\", ' end if if ( includes ( i )) then command = command + 'color=\"red\"' else command = command + 'color=\"black\"' end if command = command + ', label = \"' + L % sites ( i )% name + '\"' pos = L % sites ( i )% pos !write(*,*)L%sites(i)%name,'---',L%sites(i)%pos if ( all ( pos > 0 )) then if ( fixed ) then command = command + ', pos = \"' + ( 3 * pos ( 2 )) + ',' + ( - pos ( 1 )) + '\" ,pin=\"true\"]' else command = command + ']' end if end if write ( 7878 , '(A)' ) trim ( command ) end if end do write ( 7878 , * ) 'subgraph bond {' write ( 7878 , * ) 'edge[dir=none]' do i = 1 , L % max_site_num if ( L % sites ( i )% exist_tag ) then do k = 1 , L % sites ( i )% nb_num nb = L % sites ( i )% bonds ( k )% nb_rawpos nb_no = L % sites ( i )% bonds ( k )% nb_no if ( nb > i ) then nattr = 0 command = '  node_' + i + ' -> node_' + nb + ' [' if ( label_bond ) then command = command + 'taillabel = \"' + after_dot ( L % sites ( i )% bonds ( k )% ind ) & + '\",headlabel =\"' + after_dot ( L % sites ( nb )% bonds ( nb_no )% ind ) + '\"' nattr = nattr + 1 end if if ( includes ( i ). and . includes ( nb )) then if ( nattr > 0 ) command = command + ', ' command = command + 'color=\"red\"' nattr = nattr + 1 end if if (. not . fixed ) then if ( nattr > 0 ) command = command + ', ' command = command + 'len=3' nattr = nattr + 1 end if command = command + ']' write ( 7878 , '(A)' ) trim ( command ) end if end do end if end do write ( 7878 , * ) '}' write ( 7878 , * ) 'subgraph path {' do i = 1 , count ( path > 0 ) - 1 nattr = 0 command = '  node_' + path ( i ) + ' -> node_' + path ( i + 1 ) + ' [color=\"blue\",style=\"dashed\",penwidth=2.0]' write ( 7878 , '(A)' ) trim ( command ) end do write ( 7878 , * ) '}' write ( 7878 , * ) '}' close ( 7878 ) call system ( 'neato -Tpng -Gdpi=200 ./' // trim ( filename ) // '.dot > ./' // trim ( filename ) // '.png' ) #if DRAW_SHOW call system ( './show.sh ./' // trim ( filename ) // '.png' ) #endif #if DRAW_ENVICE call system ( 'evince ./' // trim ( filename ) // '.png' ) #endif !call system('rm ./'//trim(filename)//'.dot') if ( check_tag ) call L % check_consistency () if ( stop_tag ) then call writemess ( 'The program has been paused. Please press enter to continue' ) read ( * , * ) end if end if end subroutine !!!!!!!!!!!!!!!!!!!!!!! Used in tn_tensor !!!!!!!!!!!!!!!!!!!!!! subroutine lat_absorb_tensor ( fn_tensor , ori_tensor , G , pos ) type ( group ), intent ( inout ) :: G type ( tensor ), target , intent ( inout ) :: ori_tensor type ( tensor ), target , intent ( inout ) :: fn_tensor integer , intent ( in ) :: pos ( 2 ) character ( len = max_char_length ) :: leg ( 20 ), leg_nb ( 20 ) integer :: k , num , nb ( 2 ), nb_no , rawpos , nb_rawpos type ( tensor ) :: testen type ( tensor ), pointer :: tpf , tpo complex ( 8 ), pointer :: tendata (:) call G % lat % check_unempty () rawpos = G % lat % raw_pos ( pos ( 1 ), pos ( 2 )) if ( rawpos <= 0 ) return tpf => fn_tensor tpo => ori_tensor if ( all (. not . G % includes )) then if ( G % lat % sites ( rawpos )% con_tag ) then fn_tensor = . con . G % lat % sites ( rawpos )% tensor else fn_tensor = G % lat % sites ( rawpos )% tensor end if else if (. not . G % includes ( rawpos )) then num = 0 do k = 1 , G % lat % sites ( rawpos )% nb_num nb_rawpos = G % lat % sites ( rawpos )% bonds ( k )% nb_rawpos nb_no = G % lat % sites ( rawpos )% bonds ( k )% nb_no if ( G % includes ( nb_rawpos )) then num = num + 1 leg ( num ) = G % lat % sites ( rawpos )% bonds ( k )% ind leg_nb ( num ) = G % lat % sites ( nb_rawpos )% bonds ( nb_no )% ind end if end do if ( G % lat % sites ( rawpos )% con_tag ) then if ( num == 0 ) then fn_tensor = (. con . G % lat % sites ( rawpos )% tensor ). kron . ori_tensor else if ( associated ( tpf , tpo )) then call fn_tensor % contract ( leg_nb ( 1 : num ),. con . G % lat % sites ( rawpos )% tensor , leg ( 1 : num )) else fn_tensor = contract ( ori_tensor , leg_nb ( 1 : num ),. con . G % lat % sites ( rawpos )% tensor , leg ( 1 : num )) end if end if else if ( num == 0 ) then fn_tensor = G % lat % sites ( rawpos )% tensor . kron . ori_tensor else if ( associated ( tpf , tpo )) then call fn_tensor % contract ( leg_nb ( 1 : num ), G % lat % sites ( rawpos )% tensor , leg ( 1 : num )) else fn_tensor = contract ( ori_tensor , leg_nb ( 1 : num ), G % lat % sites ( rawpos )% tensor , leg ( 1 : num )) end if end if end if end if call G % take ( pos ) end subroutine subroutine lat_absorb_env ( fn_tensor , ori_tensor , G , pos ) type ( group ), intent ( inout ) :: G type ( tensor ), target , intent ( inout ) :: ori_tensor type ( tensor ), target , intent ( inout ) :: fn_tensor integer , intent ( in ) :: pos ( 2 ) character ( len = max_char_length ) :: nb_ind integer :: k , num , nb_no , rawpos , nb_rawpos type ( tensor ) :: env type ( tensor ), pointer :: tpf , tpo call G % lat % check_unempty () rawpos = G % lat % raw_pos ( pos ( 1 ), pos ( 2 )) if ( rawpos <= 0 ) return tpf => fn_tensor tpo => ori_tensor if ( any ( G % includes ). and .(. not . G % includes ( rawpos ))) then do k = 1 , G % lat % sites ( rawpos )% nb_num nb_rawpos = G % lat % sites ( rawpos )% bonds ( k )% nb_rawpos nb_no = G % lat % sites ( rawpos )% bonds ( k )% nb_no nb_ind = G % lat % sites ( nb_rawpos )% bonds ( nb_no )% ind if ( G % includes ( nb_rawpos )) then if ( G % lat % sites ( nb_rawpos )% bonds ( nb_no )% env_tag ) then env = G % lat % sites ( nb_rawpos )% bonds ( nb_no )% env if ( associated ( tpf , tpo )) then call fn_tensor % contract ( nb_ind , env , 'env.in' ) else fn_tensor = contract ( ori_tensor , nb_ind , env , 'env.in' ) end if call fn_tensor % setName ( 'env.out' , nb_ind ) end if end if end do end if end subroutine subroutine lat_contract_type ( Tout , T1 , T2 , G1 , G2 ) ! G1 will take G2 type ( group ), intent ( inout ) :: G1 , G2 type ( tensor ), intent ( inout ) :: Tout , T1 , T2 character ( len = max_char_length ) :: leg ( 30 ), leg_nb ( 30 ) integer :: m , n , k , num , nb_no , rawpos , nb_rawpos type ( tensor ) :: test_speed call G1 % check_can_take ( G2 ) call G1 % lat % check_unempty () if ( all (. not . G1 % includes )) then Tout = T2 else if ( all (. not . G2 % includes )) then Tout = T1 else if ( any ( G1 % includes . and . G2 % includes )) then call wc_error_stop ( 'lattice.contract_type' , 'Two includes shound not overlap!' ) else num = 0 do m = 1 , G1 % lat % max_site_num if ( G1 % includes ( m )) then do k = 1 , G1 % lat % sites ( m )% nb_num nb_rawpos = G1 % lat % sites ( m )% bonds ( k )% nb_rawpos if ( G2 % includes ( nb_rawpos )) then nb_no = G1 % lat % sites ( m )% bonds ( k )% nb_no num = num + 1 leg ( num ) = G1 % lat % sites ( m )% bonds ( k )% ind leg_nb ( num ) = G1 % lat % sites ( nb_rawpos )% bonds ( nb_no )% ind end if end do end if end do if ( num == 0 ) then Tout = T1 . kron . T2 else Tout = contract ( T1 , leg ( 1 : num ), T2 , leg_nb ( 1 : num )) end if end if call G1 % take ( G2 ) end subroutine !!!!!!!!!!!!!!!!!!!!!!!!!! Group !!!!!!!!!!!!!!!!!!!!!!!! subroutine set_name_grp ( G , my_name ) class ( group ), intent ( inout ) :: G character ( len =* ), intent ( in ) :: my_name G % name = my_name end subroutine function get_name_grp ( G ) result ( my_name ) class ( group ), intent ( in ) :: G character ( len = max_char_length ) :: my_name my_name = G % name end function function check_contain_grp_pos ( G , pos ) result ( ct ) class ( group ), intent ( in ) :: G integer , intent ( in ) :: pos ( 2 ) integer :: rawpos logical :: ct ct = . false . if ( associated ( G % lat )) then if ( G % lat % check_exist ( pos )) then rawpos = G % lat % get_rawpos ( pos ) ct = G % includes ( rawpos ) end if end if end function function check_contain_grp_name ( G , name ) result ( ct ) class ( group ), intent ( in ) :: G character ( len =* ), intent ( in ) :: name integer :: rawpos logical :: ct ct = . false . if ( associated ( G % lat )) then if ( G % lat % check_exist ( name )) then rawpos = G % lat % get_rawpos ( name ) ct = G % includes ( rawpos ) end if end if end function subroutine copy_grp ( G1 , G2 ) class ( group ), intent ( inout ) :: G1 type ( group ), intent ( in ) :: G2 if ( associated ( G2 % lat )) then call G1 % belong ( G2 % lat ) deallocate ( G1 % includes ) G1 % includes = G2 % includes end if end subroutine subroutine belong_group ( G , L ) class ( group ), intent ( inout ) :: G class ( lattice ), target , intent ( in ) :: L integer :: num G % lat => L num = max ( L % get_max_site_num (), 1 ) if ( allocated ( G % includes )) then if ( size ( G % includes ) /= num ) then deallocate ( G % includes ) allocate ( G % includes ( num )) end if else allocate ( G % includes ( num )) end if G % includes = . false . end subroutine subroutine empty_grp ( G ) class ( group ), intent ( inout ) :: G if ( allocated ( G % includes )) G % includes = . false . end subroutine subroutine draw_grp ( G , filename , tnname , label_bond , fixed , check_tag ) class ( group ), intent ( in ) :: G character ( len =* ), intent ( in ) :: tnname , filename logical , intent ( in ), optional :: label_bond , fixed , check_tag integer :: i if (. not . associated ( G % lat )) then call writemess ( '-------------------------------------------------------' ) call writemess ( 'Group not belong to any lattice, do not draw anything' ) call writemess ( '-------------------------------------------------------' ) return end if call G % lat % draw ( filename , tnname , G % includes ,[( - 1 , i = 1 , G % lat % max_site_num )], label_bond , fixed , check_tag ) end subroutine subroutine get_info ( G ) class ( group ), intent ( in ) :: G integer :: L1 , L2 call G % lat % get_size ( L1 , L2 ) call writemess ( 'The group is in lattice :' + G % lat % get_name ()) call writemess ( 'with sites included are' ) write ( * , '(L2)' ) G % includes end subroutine subroutine take_pos ( G , pos ) !if already includes or pos have no site, don't do anything class ( group ), intent ( inout ) :: G integer , intent ( in ) :: pos ( 2 ) if ( G % lat % check_exist ( pos )) then G % includes ( G % lat % get_rawpos ( pos )) = . true . end if end subroutine subroutine take_name ( G , name ) !if already includes or pos have no site, don't do anything class ( group ), intent ( inout ) :: G character ( len =* ), intent ( in ) :: name if ( G % lat % check_exist ( name )) then G % includes ( G % lat % get_rawpos ( name )) = . true . end if end subroutine subroutine take_group ( G , G2 ) class ( group ), intent ( inout ) :: G class ( group ), intent ( in ) :: G2 call G % check_can_take ( G2 ) G % includes = G % includes . or . G2 % includes end subroutine subroutine check_can_take ( G , G2 ) class ( group ), intent ( in ) :: G class ( group ), intent ( in ) :: G2 if (. not . associated ( G % lat , G2 % lat )) then call wc_error_stop ( 'group.check_can_take' , 'Groups not in the same lattice.' ) end if if ( any ( G % includes . and . G2 % includes )) then call wc_error_stop ( 'group.check_can_take' , 'Groups overlap.' ) end if end subroutine subroutine point_lat ( G , L ) class ( group ), target , intent ( in ) :: G type ( lattice ), pointer , intent ( inout ) :: L L => G % lat end subroutine function get_num_group ( G ) result ( num ) class ( group ), intent ( in ) :: G integer :: num num = count ( G % includes ) end function function get_names ( G ) result ( names ) class ( group ), intent ( in ) :: G character ( len = max_char_length ), allocatable :: names (:) integer :: num , i , n num = count ( G % includes ) allocate ( names ( num )) n = 1 do i = 1 , size ( G % includes ) if ( G % includes ( i )) then names ( n ) = G % lat % sites ( i )% name n = n + 1 end if end do end function subroutine invert_bond_grp ( G , T ) class ( group ), intent ( in ) :: G class ( tensor ), intent ( inout ) :: T integer :: i , j , nb_i , nb_j if (. not . associated ( G % lat )) then call wc_error_stop ( 'group.invert_bond' , 'lattice not associated' ) end if call G % lat % check_unempty () do i = 1 , G % lat % max_site_num if ( G % includes ( i )) then do j = 1 , G % lat % sites ( i )% nb_num nb_i = G % lat % sites ( i )% bonds ( j )% nb_rawpos if (. not . G % includes ( nb_i )) then nb_j = G % lat % sites ( i )% bonds ( j )% nb_no call T % setName ( G % lat % sites ( i )% bonds ( j )% ind , G % lat % sites ( nb_i )% bonds ( nb_j )% ind ) end if end do end if end do end subroutine function get_dangle_inds ( G , pos ) result ( inds ) class ( group ), intent ( in ) :: G integer , intent ( in ) :: pos ( 2 ) character ( len = max_char_length ), allocatable :: inds (:) integer :: num , j , rawpos , nb_rawpos rawpos = G % lat % get_rawpos ( pos ) num = 0 do j = 1 , G % lat % sites ( rawpos )% nb_num nb_rawpos = G % lat % sites ( rawpos )% bonds ( j )% nb_rawpos if (. not . G % includes ( nb_rawpos )) num = num + 1 end do allocate ( inds ( num )) num = 0 do j = 1 , G % lat % sites ( rawpos )% nb_num nb_rawpos = G % lat % sites ( rawpos )% bonds ( j )% nb_rawpos if (. not . G % includes ( nb_rawpos )) then num = num + 1 inds ( num ) = G % lat % sites ( rawpos )% bonds ( j )% ind end if end do end function subroutine get_lattice_link_grp ( G , L ) class ( group ), target , intent ( in ) :: G type ( lattice ), pointer , intent ( inout ) :: L L => G % lat end subroutine !!!!!!!!!!!!path!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine set_name_path ( P , my_name ) class ( path ), intent ( inout ) :: P character ( len =* ), intent ( in ) :: my_name P % name = my_name end subroutine function get_name_path ( P ) result ( my_name ) class ( path ), intent ( in ) :: P character ( len = max_char_length ) :: my_name my_name = P % name end function function check_contain_path_pos ( P , pos ) result ( ct ) class ( path ), intent ( in ) :: P integer , intent ( in ) :: pos ( 2 ) integer :: rawpos logical :: ct ct = . false . if ( associated ( P % lat )) then if ( P % lat % check_exist ( pos )) then rawpos = P % lat % get_rawpos ( pos ) ct = any ( P % raw_path == rawpos ) end if end if end function function check_contain_path_name ( P , name ) result ( ct ) class ( path ), intent ( in ) :: P character ( len =* ), intent ( in ) :: name integer :: rawpos logical :: ct ct = . false . if ( associated ( P % lat )) then if ( P % lat % check_exist ( name )) then rawpos = P % lat % get_rawpos ( name ) ct = any ( P % raw_path == rawpos ) end if end if end function subroutine belong_path ( P , L ) class ( path ), intent ( inout ) :: P class ( lattice ), target , intent ( in ) :: L integer :: num P % lat => L num = max ( L % get_max_site_num (), 1 ) if ( allocated ( P % raw_path )) then if ( size ( P % raw_path ) /= num ) then deallocate ( P % raw_path ) allocate ( P % raw_path ( num )) end if else allocate ( P % raw_path ( num )) end if P % raw_path =- 1 P % num = 0 end subroutine subroutine add_name ( P , name ) class ( path ), intent ( inout ) :: P character ( len =* ), intent ( in ) :: name integer :: rawpos if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.add' , 'path not belong to any lattice' ) end if rawpos = P % lat % get_rawpos ( name ) if ( any ( P % raw_path ( 1 : P % num ) == rawpos )) then call wc_error_stop ( 'path.add' , 'path already contains ' // trim ( name )) end if P % num = P % num + 1 P % raw_path ( P % num ) = rawpos end subroutine subroutine add_pos ( P , pos ) class ( path ), intent ( inout ) :: P integer , intent ( in ) :: pos ( 2 ) integer :: rawpos if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.add' , 'path not belong to any lattice' ) end if rawpos = P % lat % get_rawpos ( pos ) if ( any ( P % raw_path ( 1 : P % num ) == rawpos )) then call wc_error_stop ( 'path.add' , 'path already contains ' // trim ( str ( pos ))) end if P % num = P % num + 1 P % raw_path ( P % num ) = rawpos end subroutine function get_order_name ( P , name ) result ( order ) class ( path ), intent ( inout ) :: P character ( len =* ), intent ( in ) :: name integer :: order logical :: found integer :: rawpos if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.get_order' , 'path not belong to any lattice' ) end if rawpos = P % lat % get_rawpos ( name ) found = . false . do order = 1 , P % num if ( P % raw_path ( order ) == rawpos ) then found = . true . exit end if end do if (. not . found ) then call wc_error_stop ( 'path.get_order' , trim ( name ) // ' is not found in the path.' ) end if end function function get_order_pos ( P , pos ) result ( order ) class ( path ), intent ( inout ) :: P integer , intent ( in ) :: pos ( 2 ) integer :: order logical :: found integer :: rawpos if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.get_order' , 'path not belong to any lattice' ) end if rawpos = P % lat % get_rawpos ( pos ) found = . false . do order = 1 , P % num if ( P % raw_path ( order ) == rawpos ) then found = . true . exit end if end do if (. not . found ) then call wc_error_stop ( 'path.get_order' , trim ( str ( pos )) // ' is not found in the path.' ) end if end function function get_name_order ( P , order ) result ( name ) class ( path ), intent ( inout ) :: P integer , intent ( in ) :: order character ( len = max_char_length ) :: name if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.get_name' , 'path not belong to any lattice' ) end if if (. not . ( order >= 1 . and . order <= P % num ) ) then call wc_error_stop ( 'path.get_name' , str ( order ) // ' is not in the path.' ) end if name = P % lat % sites ( P % raw_path ( order ))% name end function function get_pos_order ( P , order ) result ( pos ) class ( path ), intent ( inout ) :: P integer , intent ( in ) :: order integer :: pos ( 2 ) if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.get_pos' , 'path not belong to any lattice' ) end if if (. not . ( order >= 1 . and . order <= P % num ) ) then call wc_error_stop ( 'path.get_pos' , str ( order ) // ' is not in the path.' ) end if pos = P % lat % sites ( P % raw_path ( order ))% pos end function subroutine get_next_pos ( P , this_pos , next_pos ) class ( path ), intent ( inout ) :: P integer , intent ( in ) :: this_pos ( 2 ) integer , intent ( out ) :: next_pos ( 2 ) integer :: this_order this_order = P % get_order ( this_pos ) if ( this_order == P % num ) then call wc_error_stop ( 'path.get_next' , trim ( str ( this_pos )) // ' is the last one.' ) end if next_pos = P % lat % sites ( P % raw_path ( this_order ) + 1 )% pos end subroutine subroutine get_next_name ( P , this_name , next_name ) class ( path ), intent ( inout ) :: P character ( len =* ), intent ( in ) :: this_name character ( len =* ), intent ( out ) :: next_name integer :: this_order this_order = P % get_order ( this_name ) if ( this_order == P % num ) then call wc_error_stop ( 'path.get_next' , trim ( this_name ) // ' is the last one.' ) end if next_name = P % lat % sites ( P % raw_path ( this_order ) + 1 )% name end subroutine subroutine iterate_pos ( P , pos , first_tag ) class ( path ), intent ( inout ) :: P logical , intent ( in ) :: first_tag integer , intent ( out ) :: pos ( 2 ) if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.iterate' , 'path not belong to any lattice' ) end if if ( P % num == 0 ) then call wc_error_stop ( 'path.iterate' , 'No sites in the path.' ) end if if ( first_tag ) then P % current_pos = 1 pos = P % lat % sites ( P % raw_path ( P % current_pos ))% pos else if ( P % current_pos == P % num ) then call wc_error_stop ( 'path.iterate' , 'Already reached the last one.' ) end if P % current_pos = P % current_pos + 1 pos = P % lat % sites ( P % raw_path ( P % current_pos ))% pos end if end subroutine subroutine iterate_name ( P , name , first_tag ) class ( path ), intent ( inout ) :: P logical , intent ( in ) :: first_tag character ( len = max_char_length ), intent ( out ) :: name if (. not . associated ( P % lat )) then call wc_error_stop ( 'path.iterate' , 'path not belong to any lattice' ) end if if ( P % num == 0 ) then call wc_error_stop ( 'path.iterate' , 'No sites in the path.' ) end if if ( first_tag ) then P % current_pos = 1 name = P % lat % sites ( P % raw_path ( P % current_pos ))% name else if ( P % current_pos == P % num ) then call wc_error_stop ( 'path.iterate' , 'Already reached the last one.' ) end if P % current_pos = P % current_pos + 1 name = P % lat % sites ( P % raw_path ( P % current_pos ))% name end if end subroutine function get_num_path ( P ) result ( num ) class ( path ), intent ( in ) :: P integer :: num num = P % num end function subroutine copy_path ( P1 , P2 ) class ( path ), intent ( inout ) :: P1 type ( path ), intent ( in ) :: P2 if ( associated ( P2 % lat )) then call P1 % belong ( P2 % lat ) deallocate ( P1 % raw_path ) P1 % raw_path = P2 % raw_path P1 % num = P2 % num P1 % current_pos = P2 % current_pos end if end subroutine function inverse_path ( P2 ) result ( P1 ) class ( path ), intent ( inout ) :: P2 type ( path ) :: P1 integer :: i if ( associated ( P2 % lat )) then call P1 % belong ( P2 % lat ) P1 % num = P2 % num do i = 1 , P1 % num P1 % raw_path ( i ) = P2 % raw_path ( P1 % num + 1 - i ) end do P1 % current_pos = P2 % current_pos end if end function subroutine clean_path ( P ) class ( path ), intent ( inout ) :: P if ( associated ( P % lat )) then P % num = 0 P % current_pos = 0 P % raw_path =- 1 end if end subroutine subroutine generate_path ( P , dir , avoid ) class ( path ), intent ( inout ) :: P character ( len =* ), intent ( in ) :: dir type ( group ), optional , intent ( in ) :: avoid integer :: L1 , L2 , m , n call P % lat % get_size ( L1 , L2 ) call P % clean () select case ( dir ) case ( 'lu' ) do n = 1 , L2 do m = 1 , L1 if ( P % lat % check_exist ([ m , n ])) then if ( present ( avoid )) then if (. not . avoid % check_contain ([ m , n ])) then call P % add ([ m , n ]) end if else call P % add ([ m , n ]) end if end if end do end do case ( 'ru' ) do n = L2 , 1 , - 1 do m = 1 , L1 if ( P % lat % check_exist ([ m , n ])) then if ( present ( avoid )) then if (. not . avoid % check_contain ([ m , n ])) then call P % add ([ m , n ]) end if else call P % add ([ m , n ]) end if end if end do end do case ( 'ld' ) do n = 1 , L2 do m = L1 , 1 , - 1 if ( P % lat % check_exist ([ m , n ])) then if ( present ( avoid )) then if (. not . avoid % check_contain ([ m , n ])) then call P % add ([ m , n ]) end if else call P % add ([ m , n ]) end if end if end do end do case ( 'rd' ) do n = L2 , 1 , - 1 do m = L1 , 1 , - 1 if ( P % lat % check_exist ([ m , n ])) then if ( present ( avoid )) then if (. not . avoid % check_contain ([ m , n ])) then call P % add ([ m , n ]) end if else call P % add ([ m , n ]) end if end if end do end do end select end subroutine subroutine draw_path ( P , filename , label_bond , fixed , check_tag ) class ( path ), intent ( in ) :: P character ( len =* ), intent ( in ) :: filename logical , intent ( in ), optional :: label_bond , fixed , check_tag integer :: i if (. not . associated ( P % lat )) then call writemess ( '-------------------------------------------------------' ) call writemess ( 'Path not belong to any lattice, do not draw anything' ) call writemess ( '-------------------------------------------------------' ) return end if call P % lat % draw_tn ( filename , filename ,[(. false ., i = 1 , P % lat % max_site_num )], P % raw_path , label_bond , fixed , check_tag ) end subroutine subroutine get_lattice_link_path ( P , L ) class ( path ), target , intent ( in ) :: P type ( lattice ), pointer , intent ( inout ) :: L L => P % lat end subroutine end module","tags":"","loc":"sourcefile/lattice.f90.html"},{"title":"statis – TNSG ","text":"type, public :: statis Contents Type-Bound Procedures add get_perc get_ave_val clean show show2 sort_key sort_val Type-Bound Procedures generic, public :: add => add_sig, add_ary private subroutine add_sig(ST, new_key, val) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST integer, intent(in) :: new_key real(kind=8), intent(in), optional :: val private subroutine add_ary(ST, new_key, val_) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST integer, intent(in) :: new_key (:) real(kind=8), intent(in), optional :: val_ generic, public :: get_perc => get_perc_sig, get_perc_ary private function get_perc_sig(ST, new_key) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST integer, intent(in) :: new_key Return Value real(kind=8) private function get_perc_ary(ST, new_key) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST integer, intent(in) :: new_key (:) Return Value real(kind=8) generic, public :: get_ave_val => get_ave_val_sig, get_ave_val_ary private function get_ave_val_sig(ST, new_key) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST integer, intent(in) :: new_key Return Value real(kind=8) private function get_ave_val_ary(ST, new_key) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST integer, intent(in) :: new_key (:) Return Value real(kind=8) procedure, public :: clean private subroutine clean(ST) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST procedure, public :: show private subroutine show(ST, sta_name) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST character(len=*) :: sta_name procedure, public :: show2 private subroutine show2(ST, sta_name) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST character(len=*) :: sta_name procedure, public :: sort_key private subroutine sort_key(ST) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST procedure, public :: sort_val private subroutine sort_val(ST) Arguments Type Intent Optional Attributes Name class( statis ), intent(inout) :: ST","tags":"","loc":"type/statis.html"},{"title":"randomer – TNSG ","text":"type, public :: randomer Contents Type-Bound Procedures check_uninited clean initialize randreal randInteger get_seed get_subseed Type-Bound Procedures procedure, public :: check_uninited private function check_uninited(myrand) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand Return Value logical procedure, public :: clean private subroutine clean(myrand) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand generic, public :: initialize => initialize1, initialize2 private subroutine initialize1(myrand, myseed, my_rank) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand integer, intent(in) :: myseed integer, intent(in) :: my_rank private subroutine initialize2(myrand, myseed) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand integer, intent(in) :: myseed procedure, public :: randreal private function randreal(myrand) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand Return Value real(kind=8) procedure, public :: randInteger private function randInteger(myrand, iMin, iMax) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand integer, intent(in) :: iMin integer, intent(in) :: iMax Return Value integer procedure, public :: get_seed private function get_seed(myrand) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand Return Value integer procedure, public :: get_subseed private function get_subseed(myrand) Arguments Type Intent Optional Attributes Name class( randomer ), intent(inout) :: myrand Return Value integer","tags":"","loc":"type/randomer.html"},{"title":"para_list – TNSG ","text":"type, public, extends( dictionary ) :: para_list Inherits type~~para_list~~InheritsGraph type~para_list para_list type~dictionary dictionary type~para_list->type~dictionary dic_class type~para_list->type~dictionary tensor tensor type~dictionary->tensor ten_val Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures get_names sub_name sub_val setvalue getvalue insert mli mai mdi mii ti li ai zi di ii append check_contain search read print subpara_name subpara_class clean rename setclass pinsert delete append_para Type-Bound Procedures procedure, public :: get_names private function get_names(D) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D Return Value character(len=max_char_length),\n  allocatable, (:) procedure, public :: sub_name private function sub_name(D, names) result(out_list) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: names (:) Return Value type( dictionary ) procedure, public :: sub_val private function sub_val(D, value) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: value Return Value type( dictionary ) generic, public :: setvalue => isetvalue, dsetvalue, zsetvalue, asetvalue, lsetvalue, tsetvalue, misetvalue, mdsetvalue, masetvalue, mlsetvalue private subroutine isetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: val logical, intent(in), optional :: add_tag private subroutine dsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine zsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name complex(kind=8), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine asetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine lsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: val logical, intent(in), optional :: add_tag private subroutine tsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name type(tensor), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine misetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: val (:) logical, intent(in), optional :: add_tag private subroutine mdsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: val (:) logical, intent(in), optional :: add_tag private subroutine masetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: val (:) logical, intent(in), optional :: add_tag private subroutine mlsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: val (:) logical, intent(in), optional :: add_tag generic, public :: getvalue => igetvalue, dgetvalue, zgetvalue, agetvalue, lgetvalue, tgetvalue, migetvalue, mdgetvalue, magetvalue, mlgetvalue private subroutine igetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name integer, intent(inout) :: val private subroutine dgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name real(kind=8), intent(inout) :: val private subroutine zgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name complex(kind=8), intent(inout) :: val private subroutine agetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name character(len=*), intent(inout) :: val private subroutine lgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name logical, intent(inout) :: val private subroutine tgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name type(tensor), intent(inout) :: val private subroutine migetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name integer, intent(inout), allocatable :: val (:) private subroutine mdgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name real(kind=8), intent(inout), allocatable :: val (:) private subroutine magetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name character(len=max_char_length), intent(inout), allocatable :: val (:) private subroutine mlgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name logical, intent(inout), allocatable :: val (:) generic, public :: insert => insert_int, insert_dbl, insert_com, insert_char, insert_logi, insert_ten, insert_int_ary, insert_dbl_ary, insert_char_ary, insert_logi_ary private subroutine insert_int(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: value private subroutine insert_dbl(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: value private subroutine insert_com(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name complex(kind=8), intent(in) :: value private subroutine insert_char(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: value private subroutine insert_logi(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: value private subroutine insert_ten(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name type(tensor), intent(in) :: value private subroutine insert_int_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: value (:) private subroutine insert_dbl_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: value (:) private subroutine insert_char_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: value (:) private subroutine insert_logi_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: value (:) procedure, public :: mli private function mli(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value logical,\n  allocatable, (:) procedure, public :: mai private function mai(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value character(len=max_char_length),\n  allocatable, (:) procedure, public :: mdi private function mdi(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value real(kind=8),\n  allocatable, (:) procedure, public :: mii private function mii(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value integer,\n  allocatable, (:) procedure, public :: ti private function ti(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value type(tensor) procedure, public :: li private function li(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value logical procedure, public :: ai private function ai(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value character(len=max_char_length) procedure, public :: zi private function zi(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value complex(kind=8) procedure, public :: di private function di(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value real(kind=8) procedure, public :: ii private function ii(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value integer procedure, public :: append private subroutine append(P1, P2) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: P1 type( dictionary ), intent(in) :: P2 procedure, public :: check_contain private function check_contain(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name Return Value logical procedure, public :: search private subroutine search(D, name, type, pos, existed) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name integer, intent(out) :: type integer, intent(out) :: pos logical, intent(out) :: existed procedure, public :: read private subroutine read(G, unit) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: G integer, intent(in) :: unit procedure, public :: print private subroutine print(D, unit, end_tag_) Arguments Type Intent Optional Attributes Name class( para_list ), intent(in) :: D integer, intent(in), optional :: unit logical, intent(in), optional :: end_tag_ procedure, public :: subpara_name private function subpara_name(D, names) result(out_list) Arguments Type Intent Optional Attributes Name class( para_list ), intent(in) :: D character(len=*), intent(in) :: names (:) Return Value type( para_list ) procedure, public :: subpara_class private function subpara_class(D, class) result(out_list) Arguments Type Intent Optional Attributes Name class( para_list ), intent(in) :: D character(len=*), intent(in) :: class Return Value type( para_list ) procedure, public :: clean private subroutine clean(D) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D procedure, public :: rename private subroutine rename(D, name, new_name) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(inout) :: new_name procedure, public :: setclass private subroutine setclass(D, name, new_class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(inout) :: new_class generic, public :: pinsert => pinsert_int, pinsert_real, pinsert_com, pinsert_char, pinsert_logi, pinsert_int_ary, pinsert_real_ary, pinsert_char_ary, pinsert_logi_ary private subroutine pinsert_int(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: value character(len=*), intent(in), optional :: class private subroutine pinsert_real(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: value character(len=*), intent(in), optional :: class private subroutine pinsert_com(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name complex(kind=8), intent(in) :: value character(len=*), intent(in), optional :: class private subroutine pinsert_char(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: value character(len=*), intent(in), optional :: class private subroutine pinsert_logi(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: value character(len=*), intent(in), optional :: class private subroutine pinsert_int_ary(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: value (:) character(len=*), intent(in), optional :: class private subroutine pinsert_real_ary(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: value (:) character(len=*), intent(in), optional :: class private subroutine pinsert_char_ary(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: value (:) character(len=*), intent(in), optional :: class private subroutine pinsert_logi_ary(D, name, value, class) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: value (:) character(len=*), intent(in), optional :: class procedure, public :: delete private subroutine delete(D, name) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: D character(len=*), intent(in) :: name procedure, public :: append_para private subroutine append_para(P1, P2) Arguments Type Intent Optional Attributes Name class( para_list ), intent(inout) :: P1 class( para_list ), intent(in) :: P2","tags":"","loc":"type/para_list.html"},{"title":"stack – TNSG ","text":"type, public :: stack Inherits type~~stack~~InheritsGraph type~stack stack type~node node type~stack->type~node last type~node->type~node previous Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~stack~~InheritedByGraph type~stack stack type~unidic unidic type~unidic->type~stack avail_stack type~lattice lattice type~lattice->type~unidic name_dic type~nest_lattice nest_lattice type~nest_lattice->type~lattice lat_pre type~nest_lattice->type~lattice type~path path type~nest_lattice->type~path cluster type~path->type~lattice lat type~group group type~group->type~lattice lat type~tn_tensor tn_tensor type~tn_tensor->type~group grp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures push pop top num clean read write real_length consistent items copy assignment(=) compare operator(==) Type-Bound Procedures procedure, public :: push private subroutine push(S, val) Arguments Type Intent Optional Attributes Name class( stack ) :: S integer, intent(in) :: val procedure, public :: pop private function pop(S) result(res) Arguments Type Intent Optional Attributes Name class( stack ) :: S Return Value integer procedure, public :: top private function top(S) result(res) Arguments Type Intent Optional Attributes Name class( stack ) :: S Return Value integer procedure, public :: num private function num(S) result(res) Arguments Type Intent Optional Attributes Name class( stack ) :: S Return Value integer procedure, public :: clean private subroutine clean(S) Arguments Type Intent Optional Attributes Name class( stack ) :: S procedure, public :: read private subroutine read(S, unit) Arguments Type Intent Optional Attributes Name class( stack ) :: S integer, intent(in) :: unit procedure, public :: write private subroutine write(S, unit) Arguments Type Intent Optional Attributes Name class( stack ) :: S integer, intent(in) :: unit procedure, public :: real_length private function real_length(S) result(res) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: S Return Value integer procedure, public :: consistent private function consistent(S) result(res) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: S Return Value logical procedure, public :: items private function items(S) result(res) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: S Return Value integer,\n  allocatable, (:) procedure, public :: copy private subroutine copy(Sout, Sin) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: Sout class( stack ), intent(in) :: Sin generic, public :: assignment(=) => copy private subroutine copy(Sout, Sin) Arguments Type Intent Optional Attributes Name class( stack ), intent(inout) :: Sout class( stack ), intent(in) :: Sin procedure, public :: compare private function compare(S1, S2) result(res) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: S1 class( stack ), intent(in) :: S2 Return Value logical generic, public :: operator(==) => compare private function compare(S1, S2) result(res) Arguments Type Intent Optional Attributes Name class( stack ), intent(in) :: S1 class( stack ), intent(in) :: S2 Return Value logical","tags":"","loc":"type/stack.html"},{"title":"tnary – TNSG ","text":"type, public :: tnary Inherits type~~tnary~~InheritsGraph type~tnary tnary Tensor Tensor type~tnary->Tensor tn, tns Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables tn tns Components Type Visibility Attributes Name Initial type(Tensor), public :: tn type(Tensor), public, allocatable :: tns (:,:)","tags":"","loc":"type/tnary.html"},{"title":"cumulator – TNSG ","text":"type, public :: cumulator Inherits type~~cumulator~~InheritsGraph type~cumulator cumulator tensor tensor type~cumulator->tensor tcumu Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures init add clean dave zave tave get_weight Type-Bound Procedures procedure, public :: init private subroutine init(C, type, T) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C character(len=1), intent(in) :: type class(tensor), intent(in), optional :: T generic, public :: add => iadd, dadd, zadd, tadd private subroutine iadd(C, val, weight_) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C integer, intent(in) :: val real(kind=8), intent(in), optional :: weight_ private subroutine dadd(C, val, weight_) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C real(kind=8), intent(in) :: val real(kind=8), intent(in), optional :: weight_ private subroutine zadd(C, val, weight_) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C complex(kind=8), intent(in) :: val real(kind=8), intent(in), optional :: weight_ private subroutine tadd(C, val, weight_) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C class(tensor), intent(inout) :: val real(kind=8), intent(in), optional :: weight_ procedure, public :: clean private subroutine clean(C) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C procedure, public :: dave private function dave(C, comm, root) result(res) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C integer, intent(in), optional :: comm integer, intent(in), optional :: root Return Value real(kind=8) procedure, public :: zave private function zave(C, comm, root) result(res) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C integer, intent(in), optional :: comm integer, intent(in), optional :: root Return Value complex(kind=8) procedure, public :: tave private function tave(C, comm, root) result(res) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C integer, intent(in), optional :: comm integer, intent(in), optional :: root Return Value type(tensor) procedure, public :: get_weight private function get_weight(C, comm, root) result(res) Arguments Type Intent Optional Attributes Name class( cumulator ), intent(inout) :: C integer, intent(in), optional :: comm integer, intent(in), optional :: root Return Value real(kind=8)","tags":"","loc":"type/cumulator.html"},{"title":"tn_tensor – TNSG ","text":"type, public, extends(tensor) :: tn_tensor Inherits type~~tn_tensor~~InheritsGraph type~tn_tensor tn_tensor tensor tensor type~tn_tensor->tensor type~group group type~tn_tensor->type~group grp type~lattice lattice type~group->type~lattice lat type~site site type~lattice->type~site sites type~dictionary dictionary type~lattice->type~dictionary info type~unidic unidic type~lattice->type~unidic name_dic type~site->tensor tensor, tensor_save, tensor_bac type~site->type~dictionary info type~bond bond type~site->type~bond bonds type~dictionary->tensor ten_val type~node_head node_head type~unidic->type~node_head hash_ary type~stack stack type~unidic->type~stack avail_stack type~node~2 node type~node_head->type~node~2 first type~bond->tensor env type~node node type~stack->type~node last type~node->type~node previous type~node~2->type~node~2 next var pantypetn_tensorInheritsGraph = svgPanZoom('#typetn_tensorInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures get_info draw empty absorb absorb_with_env absorb_just_env take absorb_all belong take_except absorb_except invert_bond get_lattice_link Type-Bound Procedures procedure, public :: get_info private subroutine get_info(T) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T procedure, public :: draw private subroutine draw(T, tnname, label_bond, fixed, check_tag) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T character(len=*), intent(in) :: tnname logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag procedure, public :: empty private subroutine empty(T) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T procedure, public :: absorb private subroutine absorb(T, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T integer, intent(in) :: pos (2) procedure, public :: absorb_with_env private subroutine absorb_with_env(T, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T integer, intent(in) :: pos (2) procedure, public :: absorb_just_env private subroutine absorb_just_env(T, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T integer, intent(in) :: pos (2) procedure, public :: take private subroutine take(T, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T integer, intent(in) :: pos (2) generic, public :: absorb_all => absorb_all0, absorb_all1 private subroutine absorb_all0(T, abp_) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T type( path ), intent(in), optional :: abp_ private subroutine absorb_all1(T1, T2, abp_) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T1 class( tn_tensor ), intent(inout) :: T2 type( path ), intent(in), optional :: abp_ procedure, public :: belong private subroutine belong(T, L) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T class( lattice ), intent(in), target :: L generic, public :: take_except => take_except_pos, take_except_name, take_except_path, take_except_group private subroutine take_except_pos(T, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T integer, intent(in) :: pos (2) private subroutine take_except_name(T, name) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T character(len=*), intent(in) :: name private subroutine take_except_path(T, pat) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T type( path ), intent(in) :: pat private subroutine take_except_group(T, grp) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T type( group ), intent(in) :: grp generic, public :: absorb_except => absorb0_except_pos, absorb0_except_name, absorb1_except_pos private subroutine absorb0_except_pos(T, pos, abp_) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T integer, intent(in) :: pos (2) type( path ), intent(in), optional :: abp_ private subroutine absorb0_except_name(T, name, abp) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T character(len=*), intent(in) :: name type( path ), intent(in), optional :: abp private subroutine absorb1_except_pos(T, T2, pos, abp_) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T class( tn_tensor ), intent(inout) :: T2 integer, intent(in) :: pos (2) type( path ), intent(in), optional :: abp_ procedure, public :: invert_bond private subroutine invert_bond(T) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T procedure, public :: get_lattice_link private subroutine get_lattice_link(T, L) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(in), target :: T type( lattice ), intent(inout), pointer :: L","tags":"","loc":"type/tn_tensor.html"},{"title":"nest_lattice – TNSG ","text":"type, public, extends( lattice ) :: nest_lattice Inherits type~~nest_lattice~~InheritsGraph type~nest_lattice nest_lattice tensor tensor type~nest_lattice->tensor ten_res, ten_bak type~lattice lattice type~nest_lattice->type~lattice lat_pre type~nest_lattice->type~lattice type~path path type~nest_lattice->type~path cluster type~site site type~lattice->type~site sites type~dictionary dictionary type~lattice->type~dictionary info type~unidic unidic type~lattice->type~unidic name_dic type~path->type~lattice lat type~site->tensor tensor, tensor_save, tensor_bac type~site->type~dictionary info type~bond bond type~site->type~bond bonds type~dictionary->tensor ten_val type~node_head node_head type~unidic->type~node_head hash_ary type~stack stack type~unidic->type~stack avail_stack type~node~2 node type~node_head->type~node~2 first type~bond->tensor env type~node node type~stack->type~node last type~node->type~node previous type~node~2->type~node~2 next var pantypenest_latticeInheritsGraph = svgPanZoom('#typenest_latticeInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables lat_pre Type-Bound Procedures initialize clean mirror_con copy_line copy_line_ten copy_line_link set_bond_as draw_l draw_tn draw add delete move move_row move_column rename back_up restore get_tensor get_tensor_link get_env_link get_env_bond set_env_bond update_tensor set_tensor point_info set_bond get_bond get_bonds get_bond_no remove_bond invert_bond get_nb_num get_max_nb_num absorb get_size get_range get_name get_pos set_name ind_name check_boundary get_contag_pos get_contag_name get_contag set_contag cut_bonds max_cut_bonds get_empty_tag check_exist check_exist_bond bonds_num check_empty check_unempty write read generate_ten generate_env absorb_env absorb_env_bond absorb_env_site tensor_absorb_env spit_env spit_env_bond assignment(=) transpose_lat insert_info tget_info_whole aget_info_whole lget_info_whole iget_info_whole zget_info_whole dget_info_whole tget_info_pos aget_info_pos lget_info_pos iget_info_pos zget_info_pos dget_info_pos tget_info_name aget_info_name lget_info_name iget_info_name zget_info_name dget_info_name get_info tset_info_whole aset_info_whole lset_info_whole iset_info_whole zset_info_whole dset_info_whole tset_info_pos aset_info_pos lset_info_pos iset_info_pos zset_info_pos dset_info_pos tset_info_name aset_info_name lset_info_name iset_info_name zset_info_name dset_info_name set_info initialize_nest generate set_cluster set_tensor_nest get_outer_pos calc_except re_calc restore_nest check_exist_nest in_clt clt_pos Components Type Visibility Attributes Name Initial class( lattice ), public, pointer :: lat_pre Type-Bound Procedures procedure, public :: initialize private subroutine initialize(L, my_name, L1, L2, max_nb_num) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: my_name integer, intent(in) :: L1 integer, intent(in) :: L2 integer, intent(in) :: max_nb_num procedure, public :: clean private subroutine clean(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L procedure, public :: mirror_con private subroutine mirror_con(L, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline procedure, public :: copy_line private subroutine copy_line(L, line, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: line type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline procedure, public :: copy_line_ten private subroutine copy_line_ten(L, line, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: line type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline procedure, public :: copy_line_link private subroutine copy_line_link(L, line, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: line type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline generic, public :: set_bond_as => set_bond_as_pure, set_bond_as_cluster, set_bond_as_path private subroutine set_bond_as_pure(L, L_old) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old private subroutine set_bond_as_cluster(L, L_old, clusters) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old type( lattice ), intent(in), target :: clusters (:,:) private subroutine set_bond_as_path(L, L_old, clusters) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old type( path ), intent(in), target :: clusters (:,:) procedure, public :: draw_l private subroutine draw_l(L, filename, label_bond, fixed, check_tag, stop_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in), optional :: filename logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag logical, intent(in), optional :: stop_tag procedure, public :: draw_tn private subroutine draw_tn(L, filename, tnname, includes, path, label_bond_, fixed_, check_tag_, stop_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: filename character(len=*), intent(in) :: tnname logical, intent(in) :: includes (:) integer, intent(in) :: path (:) logical, intent(in), optional :: label_bond_ logical, intent(in), optional :: fixed_ logical, intent(in), optional :: check_tag_ logical, intent(in), optional :: stop_tag_ generic, public :: draw => draw_l , draw_tn private subroutine draw_l(L, filename, label_bond, fixed, check_tag, stop_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in), optional :: filename logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag logical, intent(in), optional :: stop_tag private subroutine draw_tn(L, filename, tnname, includes, path, label_bond_, fixed_, check_tag_, stop_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: filename character(len=*), intent(in) :: tnname logical, intent(in) :: includes (:) integer, intent(in) :: path (:) logical, intent(in), optional :: label_bond_ logical, intent(in), optional :: fixed_ logical, intent(in), optional :: check_tag_ logical, intent(in), optional :: stop_tag_ generic, public :: add => add_from_ten, add_from_lat_pos private subroutine add_from_ten(L, pos, my_name, my_tensor, save_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: my_name type(tensor), intent(in), optional :: my_tensor logical, intent(in), optional :: save_tag private subroutine add_from_lat_pos(L, pos, lat, pos2, save_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) type( lattice ), intent(in) :: lat integer, intent(in) :: pos2 (2) logical, intent(in), optional :: save_tag generic, public :: delete => delete_pos, delete_name private subroutine delete_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) private subroutine delete_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name generic, public :: move => move_pos, move_name private subroutine move_pos(L, pos, new_pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: new_pos (2) private subroutine move_name(L, name, new_pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name integer, intent(in) :: new_pos (2) procedure, public :: move_row private subroutine move_row(L, row, new_row) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: row integer, intent(in) :: new_row procedure, public :: move_column private subroutine move_column(L, column, new_column) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: column integer, intent(in) :: new_column generic, public :: rename => rename_pos, rename_name private subroutine rename_pos(L, pos, new_name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: new_name private subroutine rename_name(L, old_name, new_name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: old_name character(len=*), intent(in) :: new_name generic, public :: back_up => back_up_pos, back_up_name private subroutine back_up_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) private subroutine back_up_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name generic, public :: restore => restore_pos, restore_name private subroutine restore_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) private subroutine restore_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name generic, public :: get_tensor => get_tensor_pos, get_tensor_name private function get_tensor_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value type(tensor) private function get_tensor_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value type(tensor) generic, public :: get_tensor_link => get_tensor_link_pos, get_tensor_link_name private subroutine get_tensor_link_pos(L, pos, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) type(tensor), intent(out), pointer :: tlink private subroutine get_tensor_link_name(L, name, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in), optional :: name type(tensor), intent(out), pointer :: tlink generic, public :: get_env_link => get_env_link_pos, get_env_link_name private subroutine get_env_link_pos(L, pos, no, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in), target :: L integer, intent(in) :: pos (2) integer, intent(in) :: no type(tensor), intent(out), pointer :: tlink private subroutine get_env_link_name(L, name, no, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in), target :: L character(len=*), intent(in), optional :: name integer, intent(in) :: no type(tensor), intent(out), pointer :: tlink generic, public :: get_env_bond => get_env_bond_pos private function get_env_bond_pos(L, pos1, pos2) result(res) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in), target :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) Return Value type(tensor) generic, public :: set_env_bond => set_env_bond_pos private subroutine set_env_bond_pos(L, pos1, pos2, env) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) type(tensor), intent(in) :: env generic, public :: update_tensor => update_tensor_pos, update_tensor_name private subroutine update_tensor_pos(L, pos, new_tensor) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) class(tensor), intent(in) :: new_tensor private subroutine update_tensor_name(L, name, new_tensor) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name class(tensor), intent(in) :: new_tensor generic, public :: set_tensor => set_tensor_pos, set_tensor_name private subroutine set_tensor_pos(L, pos, my_tensor, save_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) type(tensor), intent(in), target :: my_tensor logical, intent(in), optional :: save_tag_ private subroutine set_tensor_name(L, name, my_tensor, save_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name type(tensor), intent(in), target :: my_tensor logical, intent(in), optional :: save_tag_ generic, public :: point_info => point_info_pos, point_info_name, point_info_lat private subroutine point_info_pos(L, pos, dic) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) type( dictionary ), intent(inout), pointer :: dic private subroutine point_info_name(L, name, dic) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name type( dictionary ), intent(inout), pointer :: dic private subroutine point_info_lat(L, dic) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L type( dictionary ), intent(inout), pointer :: dic generic, public :: set_bond => set_bond_pos, set_bond_name private subroutine set_bond_pos(L, pos, pos2, dir_, dir2_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: pos2 (2) character(len=*), intent(in), optional :: dir_ character(len=*), intent(in), optional :: dir2_ private subroutine set_bond_name(L, name, name2, dir_, dir2_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: name2 character(len=*), intent(in), optional :: dir_ character(len=*), intent(in), optional :: dir2_ generic, public :: get_bond => get_bond_pos, get_bond_name private subroutine get_bond_pos(L, pos, no, ind, nb_pos, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(out) :: no character(len=max_char_length), intent(out) :: ind integer, intent(in) :: nb_pos (2) integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind private subroutine get_bond_name(L, name, no, ind, nb_name, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name integer, intent(out) :: no character(len=max_char_length), intent(out) :: ind character(len=*), intent(in) :: nb_name integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind generic, public :: get_bonds => get_bonds_pos, get_bonds_name private subroutine get_bonds_pos(L, pos, no, ind, nb_pos, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(out), allocatable :: no (:) character(len=max_char_length), intent(out), allocatable :: ind (:) integer, intent(in) :: nb_pos (2) integer, intent(out), allocatable :: nb_no (:) character(len=max_char_length), intent(out), allocatable :: nb_ind (:) private subroutine get_bonds_name(L, name, no, ind, nb_name, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name integer, intent(out), allocatable :: no (:) character(len=max_char_length), intent(out), allocatable :: ind (:) character(len=*), intent(in) :: nb_name integer, intent(out), allocatable :: nb_no (:) character(len=max_char_length), intent(out), allocatable :: nb_ind (:) generic, public :: get_bond_no => get_bond_no_pos, get_bond_no_name private subroutine get_bond_no_pos(L, pos, no, ind, nb_pos, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(in) :: no character(len=max_char_length), intent(out) :: ind integer, intent(out) :: nb_pos (2) integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind private subroutine get_bond_no_name(L, name, no, ind, nb_name, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name integer, intent(in) :: no character(len=max_char_length), intent(out) :: ind character(len=max_char_length), intent(out) :: nb_name integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind generic, public :: remove_bond => remove_bond_pos, remove_bond_name private subroutine remove_bond_pos(L, pos, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: pos2 (2) private subroutine remove_bond_name(L, name, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: name2 generic, public :: invert_bond => invert_bond_pos, invert_bond_name private subroutine invert_bond_pos(L, pos, temp) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) class(tensor), intent(inout) :: temp private subroutine invert_bond_name(L, name, temp) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name class(tensor), intent(inout) :: temp generic, public :: get_nb_num => get_nb_num_pos, get_nb_num_name private function get_nb_num_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value integer private function get_nb_num_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value integer procedure, public :: get_max_nb_num private function get_max_nb_num(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L Return Value integer procedure, public :: absorb private subroutine absorb(L, pos, nb_pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: nb_pos (2) procedure, public :: get_size private subroutine get_size(L, L1, L2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(out) :: L1 integer, intent(out) :: L2 procedure, public :: get_range private subroutine get_range(L, left, right, top, bottom) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(out) :: left integer, intent(out) :: right integer, intent(out) :: top integer, intent(out) :: bottom generic, public :: get_name => get_name_whole, get_name_site private function get_name_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L Return Value character(len=max_char_length) private function get_name_site(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value character(len=max_char_length) procedure, public :: get_pos private function get_pos(L, name) result(pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value integer\n  (2) generic, public :: set_name => set_name_lat private subroutine set_name_lat(L, my_name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: my_name procedure, public :: ind_name private function ind_name(L, pos, no) result(ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(in) :: no Return Value character(len=max_char_length) procedure, public :: check_boundary private subroutine check_boundary(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) procedure, public :: get_contag_pos private function get_contag_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value logical procedure, public :: get_contag_name private function get_contag_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value logical generic, public :: get_contag => get_contag_pos , get_contag_name private function get_contag_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value logical private function get_contag_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value logical generic, public :: set_contag => set_contag_pos, set_contag_name private subroutine set_contag_pos(L, pos, status) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) logical, intent(in) :: status private subroutine set_contag_name(L, name, status) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name logical, intent(in) :: status procedure, public :: cut_bonds private function cut_bonds(L, i, range) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: i integer, intent(in), optional :: range Return Value integer procedure, public :: max_cut_bonds private function max_cut_bonds(L, range) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in), optional :: range Return Value integer procedure, public :: get_empty_tag private function get_empty_tag(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L Return Value logical generic, public :: check_exist => check_exist_pos, check_exist_name private function check_exist_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value logical private function check_exist_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value logical generic, public :: check_exist_bond => check_exist_bond_pos, check_exist_bond_name private function check_exist_bond_pos(L, pos1, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) Return Value logical private function check_exist_bond_name(L, name1, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 Return Value logical generic, public :: bonds_num => bonds_num_pos, bonds_num_name private function bonds_num_pos(L, pos1, pos2) result(res) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) Return Value integer private function bonds_num_name(L, name1, name2) result(res) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 Return Value integer generic, public :: check_empty => check_empty_whole, check_empty_site_pos, check_empty_site_name private subroutine check_empty_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L private subroutine check_empty_site_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) private subroutine check_empty_site_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name generic, public :: check_unempty => check_unempty_whole, check_unempty_site_pos, check_unempty_site_name private subroutine check_unempty_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L private subroutine check_unempty_site_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) private subroutine check_unempty_site_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name procedure, public :: write private subroutine write(L, funit) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: funit procedure, public :: read private subroutine read(L, funit) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: funit procedure, public :: generate_ten private subroutine generate_ten(L, D, datatype, type_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: D character(len=*), intent(in) :: datatype character(len=*), intent(in), optional :: type_ procedure, public :: generate_env private subroutine generate_env(L, type_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), optional :: type_ generic, public :: absorb_env => absorb_env_whole private subroutine absorb_env_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L generic, public :: absorb_env_bond => absorb_env_pos_bond, absorb_env_name_bond private subroutine absorb_env_pos_bond(L, pos1, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) private subroutine absorb_env_name_bond(L, name1, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 generic, public :: absorb_env_site => absorb_env_pos_site private subroutine absorb_env_pos_site(L, pos, T) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) type(tensor), intent(inout) :: T generic, public :: tensor_absorb_env => tensor_absorb_env_pos private subroutine tensor_absorb_env_pos(L, pos1, pos2, T) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) type(tensor), intent(inout) :: T generic, public :: spit_env => spit_env_whole private subroutine spit_env_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L generic, public :: spit_env_bond => spit_env_pos_bond, spit_env_name_bond private subroutine spit_env_pos_bond(L, pos1, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) private subroutine spit_env_name_bond(L, name1, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 generic, public :: assignment(=) => copy_lat private subroutine copy_lat(L, L_old) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old procedure, public :: transpose_lat private function transpose_lat(L_old) result(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L_old Return Value type( lattice ) generic, public :: insert_info => dinsert_info_whole, dinsert_info_pos, dinsert_info_name, zinsert_info_whole, zinsert_info_pos, zinsert_info_name, iinsert_info_whole, iinsert_info_pos, iinsert_info_name, linsert_info_whole, linsert_info_pos, linsert_info_name, ainsert_info_whole, ainsert_info_pos, ainsert_info_name, tinsert_info_whole, tinsert_info_pos, tinsert_info_name private subroutine dinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine zinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine iinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine linsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine linsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine linsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine ainsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine ainsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine ainsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine tinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: tget_info_whole private subroutine tget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: aget_info_whole private subroutine aget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val procedure, public :: lget_info_whole private subroutine lget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(inout) :: val procedure, public :: iget_info_whole private subroutine iget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(inout) :: val procedure, public :: zget_info_whole private subroutine zget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val procedure, public :: dget_info_whole private subroutine dget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val procedure, public :: tget_info_pos private subroutine tget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: aget_info_pos private subroutine aget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val procedure, public :: lget_info_pos private subroutine lget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(inout) :: val procedure, public :: iget_info_pos private subroutine iget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(inout) :: val procedure, public :: zget_info_pos private subroutine zget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val procedure, public :: dget_info_pos private subroutine dget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val procedure, public :: tget_info_name private subroutine tget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: aget_info_name private subroutine aget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val procedure, public :: lget_info_name private subroutine lget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(inout) :: val procedure, public :: iget_info_name private subroutine iget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(inout) :: val procedure, public :: zget_info_name private subroutine zget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val procedure, public :: dget_info_name private subroutine dget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val generic, public :: get_info => dget_info_whole , dget_info_pos , dget_info_name , zget_info_whole , zget_info_pos , zget_info_name , iget_info_whole , iget_info_pos , iget_info_name , lget_info_whole , lget_info_pos , lget_info_name , aget_info_whole , aget_info_pos , aget_info_name , tget_info_whole , tget_info_pos , tget_info_name private subroutine dget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val private subroutine dget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val private subroutine dget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val private subroutine zget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val private subroutine zget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val private subroutine zget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val private subroutine iget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(inout) :: val private subroutine iget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(inout) :: val private subroutine iget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(inout) :: val private subroutine lget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(inout) :: val private subroutine lget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(inout) :: val private subroutine lget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(inout) :: val private subroutine aget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val private subroutine aget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val private subroutine aget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val private subroutine tget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val private subroutine tget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val private subroutine tget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: tset_info_whole private subroutine tset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: aset_info_whole private subroutine aset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=*), intent(in) :: val procedure, public :: lset_info_whole private subroutine lset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(in) :: val procedure, public :: iset_info_whole private subroutine iset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(in) :: val procedure, public :: zset_info_whole private subroutine zset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val procedure, public :: dset_info_whole private subroutine dset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val procedure, public :: tset_info_pos private subroutine tset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: aset_info_pos private subroutine aset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val procedure, public :: lset_info_pos private subroutine lset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(in) :: val procedure, public :: iset_info_pos private subroutine iset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(in) :: val procedure, public :: zset_info_pos private subroutine zset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val procedure, public :: dset_info_pos private subroutine dset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val procedure, public :: tset_info_name private subroutine tset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: aset_info_name private subroutine aset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val procedure, public :: lset_info_name private subroutine lset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(in) :: val procedure, public :: iset_info_name private subroutine iset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(in) :: val procedure, public :: zset_info_name private subroutine zset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val procedure, public :: dset_info_name private subroutine dset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val generic, public :: set_info => dset_info_whole , dset_info_pos , dset_info_name , zset_info_whole , zset_info_pos , zset_info_name , iset_info_whole , iset_info_pos , iset_info_name , lset_info_whole , lset_info_pos , lset_info_name , aset_info_whole , aset_info_pos , aset_info_name , tset_info_whole , tset_info_pos , tset_info_name private subroutine dset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine zset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine iset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine lset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine lset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine lset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine aset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=*), intent(in) :: val private subroutine aset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine aset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine tset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: initialize_nest private subroutine initialize_nest(LC, L) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC class( lattice ), intent(inout), target :: L procedure, public :: generate private subroutine generate(LC) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC procedure, public :: set_cluster private subroutine set_cluster(LC, pos_clt, pos_site) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC integer, intent(in) :: pos_clt (2) integer, intent(in) :: pos_site (2) procedure, public :: set_tensor_nest private subroutine set_tensor_nest(LC, tenname, tenp, to_calc) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC character(len=*), intent(in) :: tenname type(tensor), intent(inout) :: tenp logical, intent(in) :: to_calc procedure, public :: get_outer_pos private function get_outer_pos(LC, name) result(pos) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC character(len=*), intent(in) :: name Return Value integer\n  (2) procedure, public :: calc_except private subroutine calc_except(LC, ten, name) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC type( tn_tensor ), intent(inout) :: ten character(len=*), intent(in) :: name procedure, public :: re_calc private subroutine re_calc(LC, back_up) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC logical, intent(in) :: back_up procedure, public :: restore_nest private subroutine restore_nest(LC) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC procedure, public :: check_exist_nest private recursive function check_exist_nest(LC, name) result(res) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC character(len=*), intent(in) :: name Return Value logical procedure, public :: in_clt private function in_clt(LC, name) result(res) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC character(len=*), intent(in) :: name Return Value logical procedure, public :: clt_pos private function clt_pos(LC, name) result(res) Arguments Type Intent Optional Attributes Name class( nest_lattice ), intent(inout) :: LC character(len=*), intent(in) :: name Return Value integer\n  (2)","tags":"","loc":"type/nest_lattice.html"},{"title":"dictionary – TNSG ","text":"type, public :: dictionary Inherits type~~dictionary~~InheritsGraph type~dictionary dictionary tensor tensor type~dictionary->tensor ten_val Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~dictionary~~InheritedByGraph type~dictionary dictionary type~site site type~site->type~dictionary info type~lattice lattice type~lattice->type~dictionary info type~lattice->type~site sites type~para_list para_list type~para_list->type~dictionary dic_class type~para_list->type~dictionary type~nest_lattice nest_lattice type~nest_lattice->type~lattice lat_pre type~nest_lattice->type~lattice type~path path type~nest_lattice->type~path cluster type~path->type~lattice lat type~group group type~group->type~lattice lat type~tn_tensor tn_tensor type~tn_tensor->type~group grp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures read print get_names sub_name sub_val clean rename setvalue getvalue insert delete mli mai mdi mii ti li ai zi di ii append check_contain search Type-Bound Procedures procedure, public :: read private subroutine read(G, unit) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: G integer, intent(in) :: unit procedure, public :: print private subroutine print(D, unit, end_tag_) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D integer, intent(in), optional :: unit logical, intent(in), optional :: end_tag_ procedure, public :: get_names private function get_names(D) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D Return Value character(len=max_char_length),\n  allocatable, (:) procedure, public :: sub_name private function sub_name(D, names) result(out_list) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: names (:) Return Value type( dictionary ) procedure, public :: sub_val private function sub_val(D, value) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: value Return Value type( dictionary ) procedure, public :: clean private subroutine clean(D) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D procedure, public :: rename private subroutine rename(D, name, new_name) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(inout) :: new_name generic, public :: setvalue => isetvalue, dsetvalue, zsetvalue, asetvalue, lsetvalue, tsetvalue, misetvalue, mdsetvalue, masetvalue, mlsetvalue private subroutine isetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: val logical, intent(in), optional :: add_tag private subroutine dsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine zsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name complex(kind=8), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine asetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine lsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: val logical, intent(in), optional :: add_tag private subroutine tsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name type(tensor), intent(in) :: val logical, intent(in), optional :: add_tag private subroutine misetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: val (:) logical, intent(in), optional :: add_tag private subroutine mdsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: val (:) logical, intent(in), optional :: add_tag private subroutine masetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: val (:) logical, intent(in), optional :: add_tag private subroutine mlsetvalue(D, name, val, add_tag) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: val (:) logical, intent(in), optional :: add_tag generic, public :: getvalue => igetvalue, dgetvalue, zgetvalue, agetvalue, lgetvalue, tgetvalue, migetvalue, mdgetvalue, magetvalue, mlgetvalue private subroutine igetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name integer, intent(inout) :: val private subroutine dgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name real(kind=8), intent(inout) :: val private subroutine zgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name complex(kind=8), intent(inout) :: val private subroutine agetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name character(len=*), intent(inout) :: val private subroutine lgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name logical, intent(inout) :: val private subroutine tgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name type(tensor), intent(inout) :: val private subroutine migetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name integer, intent(inout), allocatable :: val (:) private subroutine mdgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name real(kind=8), intent(inout), allocatable :: val (:) private subroutine magetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name character(len=max_char_length), intent(inout), allocatable :: val (:) private subroutine mlgetvalue(D, name, val) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name logical, intent(inout), allocatable :: val (:) generic, public :: insert => insert_int, insert_dbl, insert_com, insert_char, insert_logi, insert_ten, insert_int_ary, insert_dbl_ary, insert_char_ary, insert_logi_ary private subroutine insert_int(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: value private subroutine insert_dbl(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: value private subroutine insert_com(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name complex(kind=8), intent(in) :: value private subroutine insert_char(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: value private subroutine insert_logi(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: value private subroutine insert_ten(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name type(tensor), intent(in) :: value private subroutine insert_int_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name integer, intent(in) :: value (:) private subroutine insert_dbl_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name real(kind=8), intent(in) :: value (:) private subroutine insert_char_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name character(len=*), intent(in) :: value (:) private subroutine insert_logi_ary(D, name, value) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name logical, intent(in) :: value (:) procedure, public :: delete private subroutine delete(D, name) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name procedure, public :: mli private function mli(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value logical,\n  allocatable, (:) procedure, public :: mai private function mai(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value character(len=max_char_length),\n  allocatable, (:) procedure, public :: mdi private function mdi(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value real(kind=8),\n  allocatable, (:) procedure, public :: mii private function mii(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value integer,\n  allocatable, (:) procedure, public :: ti private function ti(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value type(tensor) procedure, public :: li private function li(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value logical procedure, public :: ai private function ai(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value character(len=max_char_length) procedure, public :: zi private function zi(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value complex(kind=8) procedure, public :: di private function di(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value real(kind=8) procedure, public :: ii private function ii(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name Return Value integer procedure, public :: append private subroutine append(P1, P2) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: P1 type( dictionary ), intent(in) :: P2 procedure, public :: check_contain private function check_contain(D, name) result(res) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(inout) :: D character(len=*), intent(in) :: name Return Value logical procedure, public :: search private subroutine search(D, name, type, pos, existed) Arguments Type Intent Optional Attributes Name class( dictionary ), intent(in) :: D character(len=*), intent(in) :: name integer, intent(out) :: type integer, intent(out) :: pos logical, intent(out) :: existed","tags":"","loc":"type/dictionary.html"},{"title":"unidic – TNSG ","text":"type, public :: unidic Inherits type~~unidic~~InheritsGraph type~unidic unidic type~node_head node_head type~unidic->type~node_head hash_ary type~stack stack type~unidic->type~stack avail_stack type~node~2 node type~node_head->type~node~2 first type~node node type~stack->type~node last type~node->type~node previous type~node~2->type~node~2 next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~unidic~~InheritedByGraph type~unidic unidic type~lattice lattice type~lattice->type~unidic name_dic type~nest_lattice nest_lattice type~nest_lattice->type~lattice lat_pre type~nest_lattice->type~lattice type~path path type~nest_lattice->type~path cluster type~path->type~lattice lat type~group group type~group->type~lattice lat type~tn_tensor tn_tensor type~tn_tensor->type~group grp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Finalization Procedures clean_dic Type-Bound Procedures num add del val show rename clean print read assignment(=) Finalization Procedures final :: clean_dic private subroutine clean_dic(U) Arguments Type Intent Optional Attributes Name type( unidic ), intent(inout) :: U Type-Bound Procedures procedure, public :: num private function num(U) result(res) Arguments Type Intent Optional Attributes Name class( unidic ), intent(in) :: U Return Value integer procedure, public :: add private subroutine add(U, key, val) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U character(len=*), intent(in) :: key integer, intent(out) :: val procedure, public :: del private subroutine del(U, key) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U character(len=*), intent(in) :: key procedure, public :: val private function val(U, key) Arguments Type Intent Optional Attributes Name class( unidic ), intent(in) :: U character(len=*), intent(in) :: key Return Value integer procedure, public :: show private subroutine show(U) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U procedure, public :: rename private subroutine rename(U, key1, key2) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U character(len=*), intent(in) :: key1 character(len=*), intent(in) :: key2 procedure, public :: clean private subroutine clean(U) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U procedure, public :: print private subroutine print(U, f_unit) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U integer, intent(in) :: f_unit procedure, public :: read private subroutine read(U, f_unit) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U integer, intent(in) :: f_unit generic, public :: assignment(=) => copy private subroutine copy(U_out, U_in) Arguments Type Intent Optional Attributes Name class( unidic ), intent(inout) :: U_out class( unidic ), intent(in) :: U_in","tags":"","loc":"type/unidic.html"},{"title":"lattice – TNSG ","text":"type, public :: lattice Inherits type~~lattice~~InheritsGraph type~lattice lattice type~site site type~lattice->type~site sites type~dictionary dictionary type~lattice->type~dictionary info type~unidic unidic type~lattice->type~unidic name_dic type~site->type~dictionary info tensor tensor type~site->tensor tensor, tensor_save, tensor_bac type~bond bond type~site->type~bond bonds type~dictionary->tensor ten_val type~stack stack type~unidic->type~stack avail_stack type~node_head node_head type~unidic->type~node_head hash_ary type~bond->tensor env type~node node type~stack->type~node last type~node~2 node type~node_head->type~node~2 first type~node->type~node previous type~node~2->type~node~2 next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~lattice~~InheritedByGraph type~lattice lattice type~nest_lattice nest_lattice type~nest_lattice->type~lattice lat_pre type~nest_lattice->type~lattice type~path path type~nest_lattice->type~path cluster type~path->type~lattice lat type~group group type~group->type~lattice lat type~tn_tensor tn_tensor type~tn_tensor->type~group grp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures initialize clean mirror_con copy_line copy_line_ten copy_line_link set_bond_as draw_l draw_tn draw add delete move move_row move_column rename back_up restore get_tensor get_tensor_link get_env_link get_env_bond set_env_bond update_tensor set_tensor point_info set_bond get_bond get_bonds get_bond_no remove_bond invert_bond get_nb_num get_max_nb_num absorb get_size get_range get_name get_pos set_name ind_name check_boundary get_contag_pos get_contag_name get_contag set_contag cut_bonds max_cut_bonds get_empty_tag check_exist check_exist_bond bonds_num check_empty check_unempty write read generate_ten generate_env absorb_env absorb_env_bond absorb_env_site tensor_absorb_env spit_env spit_env_bond assignment(=) transpose_lat insert_info tget_info_whole aget_info_whole lget_info_whole iget_info_whole zget_info_whole dget_info_whole tget_info_pos aget_info_pos lget_info_pos iget_info_pos zget_info_pos dget_info_pos tget_info_name aget_info_name lget_info_name iget_info_name zget_info_name dget_info_name get_info tset_info_whole aset_info_whole lset_info_whole iset_info_whole zset_info_whole dset_info_whole tset_info_pos aset_info_pos lset_info_pos iset_info_pos zset_info_pos dset_info_pos tset_info_name aset_info_name lset_info_name iset_info_name zset_info_name dset_info_name set_info Type-Bound Procedures procedure, public :: initialize private subroutine initialize(L, my_name, L1, L2, max_nb_num) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: my_name integer, intent(in) :: L1 integer, intent(in) :: L2 integer, intent(in) :: max_nb_num procedure, public :: clean private subroutine clean(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L procedure, public :: mirror_con private subroutine mirror_con(L, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline procedure, public :: copy_line private subroutine copy_line(L, line, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: line type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline procedure, public :: copy_line_ten private subroutine copy_line_ten(L, line, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: line type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline procedure, public :: copy_line_link private subroutine copy_line_link(L, line, L_old, line2, nline) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: line type( lattice ), intent(in) :: L_old integer, intent(in) :: line2 integer, intent(in) :: nline generic, public :: set_bond_as => set_bond_as_pure, set_bond_as_cluster, set_bond_as_path private subroutine set_bond_as_pure(L, L_old) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old private subroutine set_bond_as_cluster(L, L_old, clusters) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old type( lattice ), intent(in), target :: clusters (:,:) private subroutine set_bond_as_path(L, L_old, clusters) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old type( path ), intent(in), target :: clusters (:,:) procedure, public :: draw_l private subroutine draw_l(L, filename, label_bond, fixed, check_tag, stop_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in), optional :: filename logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag logical, intent(in), optional :: stop_tag procedure, public :: draw_tn private subroutine draw_tn(L, filename, tnname, includes, path, label_bond_, fixed_, check_tag_, stop_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: filename character(len=*), intent(in) :: tnname logical, intent(in) :: includes (:) integer, intent(in) :: path (:) logical, intent(in), optional :: label_bond_ logical, intent(in), optional :: fixed_ logical, intent(in), optional :: check_tag_ logical, intent(in), optional :: stop_tag_ generic, public :: draw => draw_l , draw_tn private subroutine draw_l(L, filename, label_bond, fixed, check_tag, stop_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in), optional :: filename logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag logical, intent(in), optional :: stop_tag private subroutine draw_tn(L, filename, tnname, includes, path, label_bond_, fixed_, check_tag_, stop_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: filename character(len=*), intent(in) :: tnname logical, intent(in) :: includes (:) integer, intent(in) :: path (:) logical, intent(in), optional :: label_bond_ logical, intent(in), optional :: fixed_ logical, intent(in), optional :: check_tag_ logical, intent(in), optional :: stop_tag_ generic, public :: add => add_from_ten, add_from_lat_pos private subroutine add_from_ten(L, pos, my_name, my_tensor, save_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: my_name type(tensor), intent(in), optional :: my_tensor logical, intent(in), optional :: save_tag private subroutine add_from_lat_pos(L, pos, lat, pos2, save_tag) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) type( lattice ), intent(in) :: lat integer, intent(in) :: pos2 (2) logical, intent(in), optional :: save_tag generic, public :: delete => delete_pos, delete_name private subroutine delete_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) private subroutine delete_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name generic, public :: move => move_pos, move_name private subroutine move_pos(L, pos, new_pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: new_pos (2) private subroutine move_name(L, name, new_pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name integer, intent(in) :: new_pos (2) procedure, public :: move_row private subroutine move_row(L, row, new_row) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: row integer, intent(in) :: new_row procedure, public :: move_column private subroutine move_column(L, column, new_column) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: column integer, intent(in) :: new_column generic, public :: rename => rename_pos, rename_name private subroutine rename_pos(L, pos, new_name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: new_name private subroutine rename_name(L, old_name, new_name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: old_name character(len=*), intent(in) :: new_name generic, public :: back_up => back_up_pos, back_up_name private subroutine back_up_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) private subroutine back_up_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name generic, public :: restore => restore_pos, restore_name private subroutine restore_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) private subroutine restore_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name generic, public :: get_tensor => get_tensor_pos, get_tensor_name private function get_tensor_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value type(tensor) private function get_tensor_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value type(tensor) generic, public :: get_tensor_link => get_tensor_link_pos, get_tensor_link_name private subroutine get_tensor_link_pos(L, pos, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) type(tensor), intent(out), pointer :: tlink private subroutine get_tensor_link_name(L, name, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in), optional :: name type(tensor), intent(out), pointer :: tlink generic, public :: get_env_link => get_env_link_pos, get_env_link_name private subroutine get_env_link_pos(L, pos, no, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in), target :: L integer, intent(in) :: pos (2) integer, intent(in) :: no type(tensor), intent(out), pointer :: tlink private subroutine get_env_link_name(L, name, no, tlink) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in), target :: L character(len=*), intent(in), optional :: name integer, intent(in) :: no type(tensor), intent(out), pointer :: tlink generic, public :: get_env_bond => get_env_bond_pos private function get_env_bond_pos(L, pos1, pos2) result(res) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in), target :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) Return Value type(tensor) generic, public :: set_env_bond => set_env_bond_pos private subroutine set_env_bond_pos(L, pos1, pos2, env) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) type(tensor), intent(in) :: env generic, public :: update_tensor => update_tensor_pos, update_tensor_name private subroutine update_tensor_pos(L, pos, new_tensor) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) class(tensor), intent(in) :: new_tensor private subroutine update_tensor_name(L, name, new_tensor) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name class(tensor), intent(in) :: new_tensor generic, public :: set_tensor => set_tensor_pos, set_tensor_name private subroutine set_tensor_pos(L, pos, my_tensor, save_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) type(tensor), intent(in), target :: my_tensor logical, intent(in), optional :: save_tag_ private subroutine set_tensor_name(L, name, my_tensor, save_tag_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name type(tensor), intent(in), target :: my_tensor logical, intent(in), optional :: save_tag_ generic, public :: point_info => point_info_pos, point_info_name, point_info_lat private subroutine point_info_pos(L, pos, dic) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) type( dictionary ), intent(inout), pointer :: dic private subroutine point_info_name(L, name, dic) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name type( dictionary ), intent(inout), pointer :: dic private subroutine point_info_lat(L, dic) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L type( dictionary ), intent(inout), pointer :: dic generic, public :: set_bond => set_bond_pos, set_bond_name private subroutine set_bond_pos(L, pos, pos2, dir_, dir2_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: pos2 (2) character(len=*), intent(in), optional :: dir_ character(len=*), intent(in), optional :: dir2_ private subroutine set_bond_name(L, name, name2, dir_, dir2_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: name2 character(len=*), intent(in), optional :: dir_ character(len=*), intent(in), optional :: dir2_ generic, public :: get_bond => get_bond_pos, get_bond_name private subroutine get_bond_pos(L, pos, no, ind, nb_pos, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(out) :: no character(len=max_char_length), intent(out) :: ind integer, intent(in) :: nb_pos (2) integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind private subroutine get_bond_name(L, name, no, ind, nb_name, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name integer, intent(out) :: no character(len=max_char_length), intent(out) :: ind character(len=*), intent(in) :: nb_name integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind generic, public :: get_bonds => get_bonds_pos, get_bonds_name private subroutine get_bonds_pos(L, pos, no, ind, nb_pos, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(out), allocatable :: no (:) character(len=max_char_length), intent(out), allocatable :: ind (:) integer, intent(in) :: nb_pos (2) integer, intent(out), allocatable :: nb_no (:) character(len=max_char_length), intent(out), allocatable :: nb_ind (:) private subroutine get_bonds_name(L, name, no, ind, nb_name, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name integer, intent(out), allocatable :: no (:) character(len=max_char_length), intent(out), allocatable :: ind (:) character(len=*), intent(in) :: nb_name integer, intent(out), allocatable :: nb_no (:) character(len=max_char_length), intent(out), allocatable :: nb_ind (:) generic, public :: get_bond_no => get_bond_no_pos, get_bond_no_name private subroutine get_bond_no_pos(L, pos, no, ind, nb_pos, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(in) :: no character(len=max_char_length), intent(out) :: ind integer, intent(out) :: nb_pos (2) integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind private subroutine get_bond_no_name(L, name, no, ind, nb_name, nb_no, nb_ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name integer, intent(in) :: no character(len=max_char_length), intent(out) :: ind character(len=max_char_length), intent(out) :: nb_name integer, intent(out) :: nb_no character(len=max_char_length), intent(out) :: nb_ind generic, public :: remove_bond => remove_bond_pos, remove_bond_name private subroutine remove_bond_pos(L, pos, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: pos2 (2) private subroutine remove_bond_name(L, name, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: name2 generic, public :: invert_bond => invert_bond_pos, invert_bond_name private subroutine invert_bond_pos(L, pos, temp) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) class(tensor), intent(inout) :: temp private subroutine invert_bond_name(L, name, temp) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name class(tensor), intent(inout) :: temp generic, public :: get_nb_num => get_nb_num_pos, get_nb_num_name private function get_nb_num_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value integer private function get_nb_num_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value integer procedure, public :: get_max_nb_num private function get_max_nb_num(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L Return Value integer procedure, public :: absorb private subroutine absorb(L, pos, nb_pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) integer, intent(in) :: nb_pos (2) procedure, public :: get_size private subroutine get_size(L, L1, L2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(out) :: L1 integer, intent(out) :: L2 procedure, public :: get_range private subroutine get_range(L, left, right, top, bottom) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(out) :: left integer, intent(out) :: right integer, intent(out) :: top integer, intent(out) :: bottom generic, public :: get_name => get_name_whole, get_name_site private function get_name_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L Return Value character(len=max_char_length) private function get_name_site(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value character(len=max_char_length) procedure, public :: get_pos private function get_pos(L, name) result(pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value integer\n  (2) generic, public :: set_name => set_name_lat private subroutine set_name_lat(L, my_name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: my_name procedure, public :: ind_name private function ind_name(L, pos, no) result(ind) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) integer, intent(in) :: no Return Value character(len=max_char_length) procedure, public :: check_boundary private subroutine check_boundary(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) procedure, public :: get_contag_pos private function get_contag_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value logical procedure, public :: get_contag_name private function get_contag_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value logical generic, public :: get_contag => get_contag_pos , get_contag_name private function get_contag_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value logical private function get_contag_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value logical generic, public :: set_contag => set_contag_pos, set_contag_name private subroutine set_contag_pos(L, pos, status) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) logical, intent(in) :: status private subroutine set_contag_name(L, name, status) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name logical, intent(in) :: status procedure, public :: cut_bonds private function cut_bonds(L, i, range) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: i integer, intent(in), optional :: range Return Value integer procedure, public :: max_cut_bonds private function max_cut_bonds(L, range) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in), optional :: range Return Value integer procedure, public :: get_empty_tag private function get_empty_tag(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L Return Value logical generic, public :: check_exist => check_exist_pos, check_exist_name private function check_exist_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) Return Value logical private function check_exist_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name Return Value logical generic, public :: check_exist_bond => check_exist_bond_pos, check_exist_bond_name private function check_exist_bond_pos(L, pos1, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) Return Value logical private function check_exist_bond_name(L, name1, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 Return Value logical generic, public :: bonds_num => bonds_num_pos, bonds_num_name private function bonds_num_pos(L, pos1, pos2) result(res) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) Return Value integer private function bonds_num_name(L, name1, name2) result(res) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 Return Value integer generic, public :: check_empty => check_empty_whole, check_empty_site_pos, check_empty_site_name private subroutine check_empty_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L private subroutine check_empty_site_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) private subroutine check_empty_site_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name generic, public :: check_unempty => check_unempty_whole, check_unempty_site_pos, check_unempty_site_name private subroutine check_unempty_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L private subroutine check_unempty_site_pos(L, pos) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L integer, intent(in) :: pos (2) private subroutine check_unempty_site_name(L, name) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L character(len=*), intent(in) :: name procedure, public :: write private subroutine write(L, funit) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: funit procedure, public :: read private subroutine read(L, funit) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: funit procedure, public :: generate_ten private subroutine generate_ten(L, D, datatype, type_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: D character(len=*), intent(in) :: datatype character(len=*), intent(in), optional :: type_ procedure, public :: generate_env private subroutine generate_env(L, type_) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), optional :: type_ generic, public :: absorb_env => absorb_env_whole private subroutine absorb_env_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L generic, public :: absorb_env_bond => absorb_env_pos_bond, absorb_env_name_bond private subroutine absorb_env_pos_bond(L, pos1, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) private subroutine absorb_env_name_bond(L, name1, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 generic, public :: absorb_env_site => absorb_env_pos_site private subroutine absorb_env_pos_site(L, pos, T) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos (2) type(tensor), intent(inout) :: T generic, public :: tensor_absorb_env => tensor_absorb_env_pos private subroutine tensor_absorb_env_pos(L, pos1, pos2, T) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) type(tensor), intent(inout) :: T generic, public :: spit_env => spit_env_whole private subroutine spit_env_whole(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L generic, public :: spit_env_bond => spit_env_pos_bond, spit_env_name_bond private subroutine spit_env_pos_bond(L, pos1, pos2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L integer, intent(in) :: pos1 (2) integer, intent(in) :: pos2 (2) private subroutine spit_env_name_bond(L, name1, name2) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 generic, public :: assignment(=) => copy_lat private subroutine copy_lat(L, L_old) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout) :: L type( lattice ), intent(in) :: L_old procedure, public :: transpose_lat private function transpose_lat(L_old) result(L) Arguments Type Intent Optional Attributes Name class( lattice ), intent(in) :: L_old Return Value type( lattice ) generic, public :: insert_info => dinsert_info_whole, dinsert_info_pos, dinsert_info_name, zinsert_info_whole, zinsert_info_pos, zinsert_info_name, iinsert_info_whole, iinsert_info_pos, iinsert_info_name, linsert_info_whole, linsert_info_pos, linsert_info_name, ainsert_info_whole, ainsert_info_pos, ainsert_info_name, tinsert_info_whole, tinsert_info_pos, tinsert_info_name private subroutine dinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine zinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine iinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine linsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine linsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine linsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine ainsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine ainsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine ainsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine tinsert_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tinsert_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tinsert_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: tget_info_whole private subroutine tget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: aget_info_whole private subroutine aget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val procedure, public :: lget_info_whole private subroutine lget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(inout) :: val procedure, public :: iget_info_whole private subroutine iget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(inout) :: val procedure, public :: zget_info_whole private subroutine zget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val procedure, public :: dget_info_whole private subroutine dget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val procedure, public :: tget_info_pos private subroutine tget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: aget_info_pos private subroutine aget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val procedure, public :: lget_info_pos private subroutine lget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(inout) :: val procedure, public :: iget_info_pos private subroutine iget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(inout) :: val procedure, public :: zget_info_pos private subroutine zget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val procedure, public :: dget_info_pos private subroutine dget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val procedure, public :: tget_info_name private subroutine tget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: aget_info_name private subroutine aget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val procedure, public :: lget_info_name private subroutine lget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(inout) :: val procedure, public :: iget_info_name private subroutine iget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(inout) :: val procedure, public :: zget_info_name private subroutine zget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val procedure, public :: dget_info_name private subroutine dget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val generic, public :: get_info => dget_info_whole , dget_info_pos , dget_info_name , zget_info_whole , zget_info_pos , zget_info_name , iget_info_whole , iget_info_pos , iget_info_name , lget_info_whole , lget_info_pos , lget_info_name , aget_info_whole , aget_info_pos , aget_info_name , tget_info_whole , tget_info_pos , tget_info_name private subroutine dget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val private subroutine dget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val private subroutine dget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(inout) :: val private subroutine zget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val private subroutine zget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val private subroutine zget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(inout) :: val private subroutine iget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(inout) :: val private subroutine iget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(inout) :: val private subroutine iget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(inout) :: val private subroutine lget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(inout) :: val private subroutine lget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(inout) :: val private subroutine lget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(inout) :: val private subroutine aget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val private subroutine aget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val private subroutine aget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(inout) :: val private subroutine tget_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val private subroutine tget_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val private subroutine tget_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(inout) :: val procedure, public :: tset_info_whole private subroutine tset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: aset_info_whole private subroutine aset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=*), intent(in) :: val procedure, public :: lset_info_whole private subroutine lset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(in) :: val procedure, public :: iset_info_whole private subroutine iset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(in) :: val procedure, public :: zset_info_whole private subroutine zset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val procedure, public :: dset_info_whole private subroutine dset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val procedure, public :: tset_info_pos private subroutine tset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: aset_info_pos private subroutine aset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val procedure, public :: lset_info_pos private subroutine lset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(in) :: val procedure, public :: iset_info_pos private subroutine iset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(in) :: val procedure, public :: zset_info_pos private subroutine zset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val procedure, public :: dset_info_pos private subroutine dset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val procedure, public :: tset_info_name private subroutine tset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val procedure, public :: aset_info_name private subroutine aset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val procedure, public :: lset_info_name private subroutine lset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(in) :: val procedure, public :: iset_info_name private subroutine iset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(in) :: val procedure, public :: zset_info_name private subroutine zset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val procedure, public :: dset_info_name private subroutine dset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val generic, public :: set_info => dset_info_whole , dset_info_pos , dset_info_name , zset_info_whole , zset_info_pos , zset_info_name , iset_info_whole , iset_info_pos , iset_info_name , lset_info_whole , lset_info_pos , lset_info_name , aset_info_whole , aset_info_pos , aset_info_name , tset_info_whole , tset_info_pos , tset_info_name private subroutine dset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine dset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name real(kind=8), intent(in) :: val private subroutine zset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine zset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name complex(kind=8), intent(in) :: val private subroutine iset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine iset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name integer, intent(in) :: val private subroutine lset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine lset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine lset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name logical, intent(in) :: val private subroutine aset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name character(len=*), intent(in) :: val private subroutine aset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine aset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name character(len=max_char_length), intent(in) :: val private subroutine tset_info_whole(L, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tset_info_pos(L, pos, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L integer, intent(in) :: pos (2) character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val private subroutine tset_info_name(L, name, val_name, val) Arguments Type Intent Optional Attributes Name class( lattice ), intent(inout), target :: L character(len=*), intent(in) :: name character(len=*), intent(in) :: val_name type(tensor), intent(in) :: val","tags":"","loc":"type/lattice.html"},{"title":"group – TNSG ","text":"type, public :: group Inherits type~~group~~InheritsGraph type~group group type~lattice lattice type~group->type~lattice lat type~site site type~lattice->type~site sites type~dictionary dictionary type~lattice->type~dictionary info type~unidic unidic type~lattice->type~unidic name_dic type~site->type~dictionary info tensor tensor type~site->tensor tensor, tensor_save, tensor_bac type~bond bond type~site->type~bond bonds type~dictionary->tensor ten_val type~stack stack type~unidic->type~stack avail_stack type~node_head node_head type~unidic->type~node_head hash_ary type~bond->tensor env type~node node type~stack->type~node last type~node~2 node type~node_head->type~node~2 first type~node->type~node previous type~node~2->type~node~2 next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~group~~InheritedByGraph type~group group type~tn_tensor tn_tensor type~tn_tensor->type~group grp Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures get_info get_name set_name draw empty check_can_take take check_contain belong assignment(=) get_names get_num point_lat invert_bond get_dangle_inds get_lattice_link Type-Bound Procedures procedure, public :: get_info private subroutine get_info(G) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G generic, public :: get_name => get_name_grp private function get_name_grp(G) result(my_name) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G Return Value character(len=max_char_length) generic, public :: set_name => set_name_grp private subroutine set_name_grp(G, my_name) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G character(len=*), intent(in) :: my_name generic, public :: draw => draw_grp private subroutine draw_grp(G, filename, tnname, label_bond, fixed, check_tag) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G character(len=*), intent(in) :: filename character(len=*), intent(in) :: tnname logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag generic, public :: empty => empty_grp private subroutine empty_grp(G) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G procedure, public :: check_can_take private subroutine check_can_take(G, G2) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G class( group ), intent(in) :: G2 generic, public :: take => take_pos, take_name, take_group private subroutine take_pos(G, pos) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G integer, intent(in) :: pos (2) private subroutine take_name(G, name) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G character(len=*), intent(in) :: name private subroutine take_group(G, G2) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G class( group ), intent(in) :: G2 generic, public :: check_contain => check_contain_grp_pos, check_contain_grp_name private function check_contain_grp_pos(G, pos) result(ct) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G integer, intent(in) :: pos (2) Return Value logical private function check_contain_grp_name(G, name) result(ct) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G character(len=*), intent(in) :: name Return Value logical generic, public :: belong => belong_group private subroutine belong_group(G, L) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G class( lattice ), intent(in), target :: L generic, public :: assignment(=) => copy_grp private subroutine copy_grp(G1, G2) Arguments Type Intent Optional Attributes Name class( group ), intent(inout) :: G1 type( group ), intent(in) :: G2 procedure, public :: get_names private function get_names(G) result(names) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G Return Value character(len=max_char_length),\n  allocatable, (:) generic, public :: get_num => get_num_group private function get_num_group(G) result(num) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G Return Value integer procedure, public :: point_lat private subroutine point_lat(G, L) Arguments Type Intent Optional Attributes Name class( group ), intent(in), target :: G type( lattice ), intent(inout), pointer :: L generic, public :: invert_bond => invert_bond_grp private subroutine invert_bond_grp(G, T) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G class(tensor), intent(inout) :: T procedure, public :: get_dangle_inds private function get_dangle_inds(G, pos) result(inds) Arguments Type Intent Optional Attributes Name class( group ), intent(in) :: G integer, intent(in) :: pos (2) Return Value character(len=max_char_length),\n  allocatable, (:) generic, public :: get_lattice_link => get_lattice_link_grp private subroutine get_lattice_link_grp(G, L) Arguments Type Intent Optional Attributes Name class( group ), intent(in), target :: G type( lattice ), intent(inout), pointer :: L","tags":"","loc":"type/group.html"},{"title":"path – TNSG ","text":"type, public :: path Inherits type~~path~~InheritsGraph type~path path type~lattice lattice type~path->type~lattice lat type~site site type~lattice->type~site sites type~dictionary dictionary type~lattice->type~dictionary info type~unidic unidic type~lattice->type~unidic name_dic type~site->type~dictionary info tensor tensor type~site->tensor tensor, tensor_save, tensor_bac type~bond bond type~site->type~bond bonds type~dictionary->tensor ten_val type~stack stack type~unidic->type~stack avail_stack type~node_head node_head type~unidic->type~node_head hash_ary type~bond->tensor env type~node node type~stack->type~node last type~node~2 node type~node_head->type~node~2 first type~node->type~node previous type~node~2->type~node~2 next Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~path~~InheritedByGraph type~path path type~nest_lattice nest_lattice type~nest_lattice->type~path cluster Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Type-Bound Procedures get_name set_name belong add get_next get_order get_name get_pos get_num iterate assignment(=) inverse clean generate draw get_lattice_link check_contain Type-Bound Procedures generic, public :: get_name => get_name_path private function get_name_path(P) result(my_name) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: P Return Value character(len=max_char_length) generic, public :: set_name => set_name_path private subroutine set_name_path(P, my_name) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P character(len=*), intent(in) :: my_name generic, public :: belong => belong_path private subroutine belong_path(P, L) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P class( lattice ), intent(in), target :: L generic, public :: add => add_name, add_pos private subroutine add_name(P, name) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P character(len=*), intent(in) :: name private subroutine add_pos(P, pos) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P integer, intent(in) :: pos (2) generic, public :: get_next => get_next_name, get_next_pos private subroutine get_next_name(P, this_name, next_name) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P character(len=*), intent(in) :: this_name character(len=*), intent(out) :: next_name private subroutine get_next_pos(P, this_pos, next_pos) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P integer, intent(in) :: this_pos (2) integer, intent(out) :: next_pos (2) generic, public :: get_order => get_order_name, get_order_pos private function get_order_name(P, name) result(order) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P character(len=*), intent(in) :: name Return Value integer private function get_order_pos(P, pos) result(order) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P integer, intent(in) :: pos (2) Return Value integer generic, public :: get_name => get_name_order private function get_name_order(P, order) result(name) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P integer, intent(in) :: order Return Value character(len=max_char_length) generic, public :: get_pos => get_pos_order private function get_pos_order(P, order) result(pos) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P integer, intent(in) :: order Return Value integer\n  (2) generic, public :: get_num => get_num_path private function get_num_path(P) result(num) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: P Return Value integer generic, public :: iterate => iterate_pos, iterate_name private subroutine iterate_pos(P, pos, first_tag) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P integer, intent(out) :: pos (2) logical, intent(in) :: first_tag private subroutine iterate_name(P, name, first_tag) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P character(len=max_char_length), intent(out) :: name logical, intent(in) :: first_tag generic, public :: assignment(=) => copy_path private subroutine copy_path(P1, P2) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P1 type( path ), intent(in) :: P2 generic, public :: inverse => inverse_path private function inverse_path(P2) result(P1) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P2 Return Value type( path ) generic, public :: clean => clean_path private subroutine clean_path(P) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P generic, public :: generate => generate_path private subroutine generate_path(P, dir, avoid) Arguments Type Intent Optional Attributes Name class( path ), intent(inout) :: P character(len=*), intent(in) :: dir type( group ), intent(in), optional :: avoid generic, public :: draw => draw_path private subroutine draw_path(P, filename, label_bond, fixed, check_tag) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: P character(len=*), intent(in) :: filename logical, intent(in), optional :: label_bond logical, intent(in), optional :: fixed logical, intent(in), optional :: check_tag generic, public :: get_lattice_link => get_lattice_link_path private subroutine get_lattice_link_path(P, L) Arguments Type Intent Optional Attributes Name class( path ), intent(in), target :: P type( lattice ), intent(inout), pointer :: L generic, public :: check_contain => check_contain_path_pos, check_contain_path_name private function check_contain_path_pos(P, pos) result(ct) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: P integer, intent(in) :: pos (2) Return Value logical private function check_contain_path_name(P, name) result(ct) Arguments Type Intent Optional Attributes Name class( path ), intent(in) :: P character(len=*), intent(in) :: name Return Value logical","tags":"","loc":"type/path.html"},{"title":"ZDOTU1 – TNSG","text":"function ZDOTU1(N, ZX, INCX, ZY, INCY) Arguments Type Intent Optional Attributes Name integer :: N complex(kind=8) :: ZX ((N-1)*INCX+1) integer :: INCX complex(kind=8) :: ZY ((N-1)*INCY+1) integer :: INCY Return Value complex(kind=8) Calls proc~~zdotu1~~CallsGraph proc~zdotu1 ZDOTU1 zdotu zdotu proc~zdotu1->zdotu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/zdotu1.html"},{"title":"timer_get – TNSG","text":"public function timer_get(name) result(time) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value real(kind=8) Calls proc~~timer_get~~CallsGraph proc~timer_get timer_get get_time get_time proc~timer_get->get_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timer_get.html"},{"title":"timer_start – TNSG","text":"public subroutine timer_start(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Calls proc~~timer_start~~CallsGraph proc~timer_start timer_start get_time get_time proc~timer_start->get_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timer_start.html"},{"title":"timer_end – TNSG","text":"public subroutine timer_end(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Calls proc~~timer_end~~CallsGraph proc~timer_end timer_end get_time get_time proc~timer_end->get_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timer_end.html"},{"title":"timer_print – TNSG","text":"public subroutine timer_print() Arguments None Calls proc~~timer_print~~CallsGraph proc~timer_print timer_print interface~str str proc~timer_print->interface~str writemess writemess proc~timer_print->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timer_print.html"},{"title":"timer_refresh – TNSG","text":"public interface timer_refresh Contents Module Procedures timer_refresh_all timer_refresh_name Module Procedures private subroutine timer_refresh_all() Arguments None private subroutine timer_refresh_name(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name","tags":"","loc":"interface/timer_refresh.html"},{"title":"error_test_tag – TNSG","text":"public subroutine error_test_tag(tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tag Contents None","tags":"","loc":"proc/error_test_tag.html"},{"title":"wc_error_stop_mess2 – TNSG","text":"public subroutine wc_error_stop_mess2(error_pos, error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_pos character(len=*), intent(in) :: error_mess Calls proc~~wc_error_stop_mess2~~CallsGraph proc~wc_error_stop_mess2 wc_error_stop_mess2 writemess writemess proc~wc_error_stop_mess2->writemess proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess2->proc~wc_outpicture proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wc_error_stop_mess2~~CalledByGraph proc~wc_error_stop_mess2 wc_error_stop_mess2 interface~wc_error_stop wc_error_stop interface~wc_error_stop->proc~wc_error_stop_mess2 proc~percent percent proc~percent->interface~wc_error_stop proc~lat_contract_type lat_contract_type proc~lat_contract_type->interface~wc_error_stop proc~percent_end percent_end proc~percent_end->interface~wc_error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wc_error_stop_mess2.html"},{"title":"wc_error_stop_mess1 – TNSG","text":"public subroutine wc_error_stop_mess1(error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_mess Calls proc~~wc_error_stop_mess1~~CallsGraph proc~wc_error_stop_mess1 wc_error_stop_mess1 writemess writemess proc~wc_error_stop_mess1->writemess proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess1->proc~wc_outpicture proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wc_error_stop_mess1~~CalledByGraph proc~wc_error_stop_mess1 wc_error_stop_mess1 interface~wc_error_stop wc_error_stop interface~wc_error_stop->proc~wc_error_stop_mess1 proc~percent percent proc~percent->interface~wc_error_stop proc~lat_contract_type lat_contract_type proc~lat_contract_type->interface~wc_error_stop proc~percent_end percent_end proc~percent_end->interface~wc_error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wc_error_stop_mess1.html"},{"title":"wc_error_stop_nomess – TNSG","text":"public subroutine wc_error_stop_nomess() Arguments None Calls proc~~wc_error_stop_nomess~~CallsGraph proc~wc_error_stop_nomess wc_error_stop_nomess proc~wc_outpicture wc_outpicture proc~wc_error_stop_nomess->proc~wc_outpicture writemess writemess proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wc_error_stop_nomess~~CalledByGraph proc~wc_error_stop_nomess wc_error_stop_nomess interface~wc_error_stop wc_error_stop interface~wc_error_stop->proc~wc_error_stop_nomess proc~percent percent proc~percent->interface~wc_error_stop proc~lat_contract_type lat_contract_type proc~lat_contract_type->interface~wc_error_stop proc~percent_end percent_end proc~percent_end->interface~wc_error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wc_error_stop_nomess.html"},{"title":"wc_outpicture – TNSG","text":"public subroutine wc_outpicture() Arguments None Calls proc~~wc_outpicture~~CallsGraph proc~wc_outpicture wc_outpicture writemess writemess proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~wc_outpicture~~CalledByGraph proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess2 wc_error_stop_mess2 proc~wc_error_stop_mess2->proc~wc_outpicture proc~wc_error_stop_mess1 wc_error_stop_mess1 proc~wc_error_stop_mess1->proc~wc_outpicture proc~wc_error_stop_nomess wc_error_stop_nomess proc~wc_error_stop_nomess->proc~wc_outpicture interface~wc_error_stop wc_error_stop interface~wc_error_stop->proc~wc_error_stop_mess2 interface~wc_error_stop->proc~wc_error_stop_mess1 interface~wc_error_stop->proc~wc_error_stop_nomess proc~percent percent proc~percent->interface~wc_error_stop proc~lat_contract_type lat_contract_type proc~lat_contract_type->interface~wc_error_stop proc~percent_end percent_end proc~percent_end->interface~wc_error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wc_outpicture.html"},{"title":"wc_error_stop – TNSG","text":"public interface wc_error_stop Calls interface~~wc_error_stop~~CallsGraph interface~wc_error_stop wc_error_stop proc~wc_error_stop_mess2 wc_error_stop_mess2 interface~wc_error_stop->proc~wc_error_stop_mess2 proc~wc_error_stop_mess1 wc_error_stop_mess1 interface~wc_error_stop->proc~wc_error_stop_mess1 proc~wc_error_stop_nomess wc_error_stop_nomess interface~wc_error_stop->proc~wc_error_stop_nomess writemess writemess proc~wc_error_stop_mess2->writemess proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess2->proc~wc_outpicture proc~wc_error_stop_mess1->writemess proc~wc_error_stop_mess1->proc~wc_outpicture proc~wc_error_stop_nomess->proc~wc_outpicture proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~wc_error_stop~~CalledByGraph interface~wc_error_stop wc_error_stop proc~percent percent proc~percent->interface~wc_error_stop proc~lat_contract_type lat_contract_type proc~lat_contract_type->interface~wc_error_stop proc~percent_end percent_end proc~percent_end->interface~wc_error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures wc_error_stop_mess2 wc_error_stop_mess1 wc_error_stop_nomess Module Procedures public subroutine wc_error_stop_mess2 (error_pos, error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_pos character(len=*), intent(in) :: error_mess public subroutine wc_error_stop_mess1 (error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_mess public subroutine wc_error_stop_nomess () Arguments None","tags":"","loc":"interface/wc_error_stop.html"},{"title":"after_dot – TNSG","text":"public function after_dot(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/after_dot.html"},{"title":"before_dot – TNSG","text":"public function before_dot(str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/before_dot.html"},{"title":"str_before – TNSG","text":"public function str_before(str, ch) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in) :: ch Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_before.html"},{"title":"str_after – TNSG","text":"public function str_after(str, ch) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in) :: ch Return Value character(len=:),\n  allocatable Contents None","tags":"","loc":"proc/str_after.html"},{"title":"str – TNSG","text":"public interface str Called by interface~~str~~CalledByGraph interface~str str proc~str_date_time str_date_time proc~str_date_time->interface~str proc~str_date_time_ str_date_time_ proc~str_date_time_->interface~str proc~timer_print timer_print proc~timer_print->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures int2str int_ary2str flt2str flt_ary2str dbl2str dbl_ary2str com2str com_ary2str dcom2str dcom_ary2str logi2str logi_ary2str str_ary2str Module Procedures private function int2str(inte) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inte Return Value character(len=:),\n  allocatable private function int_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function flt2str(num, digit) result(str) Arguments Type Intent Optional Attributes Name real(kind=4), intent(in) :: num integer, intent(in), optional :: digit Return Value character(len=:),\n  allocatable private function flt_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name real(kind=4), intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function dbl2str(num, digit_) result(str2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: num integer, intent(in), optional :: digit_ Return Value character(len=:),\n  allocatable private function dbl_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function com2str(num, digit) result(str) Arguments Type Intent Optional Attributes Name complex, intent(in) :: num integer, intent(in), optional :: digit Return Value character(len=:),\n  allocatable private function com_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name complex(kind=4), intent(in) :: nums (:) character(len=*), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function dcom2str(num, digit) result(str) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: num integer, intent(in), optional :: digit Return Value character(len=:),\n  allocatable private function dcom_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: nums (:) character(len=*), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function logi2str(num) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: num Return Value character(len=:),\n  allocatable private function logi_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name logical, intent(in) :: nums (:) character(len=*), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function str_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/str.html"},{"title":"operator(//) – TNSG","text":"public interface operator(//) Contents Module Procedures concat Module Procedures private function concat(st1, st2) result(str) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: st1 class(*), intent(in) :: st2 Return Value character(len=:),\n  allocatable","tags":"","loc":"interface/operator(SLASHSLASH).html"},{"title":"dbl – TNSG","text":"public function dbl(T) result(res) Arguments Type Intent Optional Attributes Name class(tensor), intent(in) :: T Return Value real(kind=8) Contents None","tags":"","loc":"proc/dbl.html"},{"title":"randten_sign – TNSG","text":"public function randten_sign(ten, th1, th2, rand_grad, n1, n2, tot) result(rand_ten) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: ten real(kind=8), intent(in) :: th1 real(kind=8), intent(in) :: th2 type( randomer ), intent(inout) :: rand_grad integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: tot Return Value type(tensor) Contents None","tags":"","loc":"proc/randten_sign.html"},{"title":"test_same_tensor – TNSG","text":"public function test_same_tensor(T1, T2) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in), target :: T1 type(tensor), intent(in), target :: T2 Return Value logical Called by proc~~test_same_tensor~~CalledByGraph proc~test_same_tensor test_same_tensor proc~wc_reduce_tensor wc_reduce_Tensor proc~wc_reduce_tensor->proc~test_same_tensor proc~wc_allreduce_tensor wc_allreduce_Tensor proc~wc_allreduce_tensor->proc~test_same_tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_same_tensor.html"},{"title":"test_not_empty – TNSG","text":"public function test_not_empty(T, mpi_comm) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: T integer, intent(in) :: mpi_comm Return Value integer Calls proc~~test_not_empty~~CallsGraph proc~test_not_empty test_not_empty mpi_allreduce mpi_allreduce proc~test_not_empty->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_not_empty~~CalledByGraph proc~test_not_empty test_not_empty proc~wc_reduce_tensor wc_reduce_Tensor proc~wc_reduce_tensor->proc~test_not_empty proc~wc_allreduce_tensor wc_allreduce_Tensor proc~wc_allreduce_tensor->proc~test_not_empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_not_empty.html"},{"title":"test_same_type – TNSG","text":"public function test_same_type(T, mpi_comm) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: T integer, intent(in) :: mpi_comm Return Value integer Calls proc~~test_same_type~~CallsGraph proc~test_same_type test_same_type mpi_bcast mpi_bcast proc~test_same_type->mpi_bcast mpi_allreduce mpi_allreduce proc~test_same_type->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_same_type~~CalledByGraph proc~test_same_type test_same_type proc~wc_reduce_tensor wc_reduce_Tensor proc~wc_reduce_tensor->proc~test_same_type proc~wc_allreduce_tensor wc_allreduce_Tensor proc~wc_allreduce_tensor->proc~test_same_type Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_same_type.html"},{"title":"test_same_length – TNSG","text":"public function test_same_length(T, mpi_comm) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: T integer, intent(in) :: mpi_comm Return Value integer Calls proc~~test_same_length~~CallsGraph proc~test_same_length test_same_length mpi_bcast mpi_bcast proc~test_same_length->mpi_bcast mpi_allreduce mpi_allreduce proc~test_same_length->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_same_length~~CalledByGraph proc~test_same_length test_same_length proc~wc_reduce_tensor wc_reduce_Tensor proc~wc_reduce_tensor->proc~test_same_length proc~wc_allreduce_tensor wc_allreduce_Tensor proc~wc_allreduce_tensor->proc~test_same_length Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_same_length.html"},{"title":"kill_D1_ind – TNSG","text":"public subroutine kill_D1_ind(T) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T Contents None","tags":"","loc":"proc/kill_d1_ind.html"},{"title":"permute_as – TNSG","text":"public subroutine permute_as(T, P) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T type(tensor), intent(in) :: P Contents None","tags":"","loc":"proc/permute_as.html"},{"title":"print_data – TNSG","text":"public subroutine print_data(T, unit, fmt) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T integer, intent(in) :: unit logical, intent(in) :: fmt Contents None","tags":"","loc":"proc/print_data.html"},{"title":"HOSVD – TNSG","text":"public subroutine HOSVD(T, uni, env, cen, names, Dc) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T type(tensor), intent(inout) :: uni (:) type(tensor), intent(inout) :: env (:) type(tensor), intent(inout) :: cen character(len=*), intent(in) :: names (:) integer, intent(in), optional :: Dc Calls proc~~hosvd~~CallsGraph proc~hosvd HOSVD eye eye proc~hosvd->eye contract contract proc~hosvd->contract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hosvd.html"},{"title":"cre_ann_number – TNSG","text":"public subroutine cre_ann_number(A, A_dg, N, N2, D) Arguments Type Intent Optional Attributes Name type(Tensor), intent(out) :: A type(Tensor), intent(out) :: A_dg type(Tensor), intent(out) :: N type(Tensor), intent(out) :: N2 integer, intent(in) :: D Contents None","tags":"","loc":"proc/cre_ann_number.html"},{"title":"spin_matrix – TNSG","text":"public subroutine spin_matrix(sx, sy, sz, s) Arguments Type Intent Optional Attributes Name type(Tensor), intent(inout) :: sx type(Tensor), intent(inout) :: sy type(Tensor), intent(inout) :: sz real(kind=8), intent(in) :: s Contents None","tags":"","loc":"proc/spin_matrix.html"},{"title":"spin_matrix2 – TNSG","text":"public subroutine spin_matrix2(sx, sy, sz, sp, sm, s) Arguments Type Intent Optional Attributes Name type(Tensor), intent(inout) :: sx type(Tensor), intent(inout) :: sy type(Tensor), intent(inout) :: sz type(Tensor), intent(inout) :: sp type(Tensor), intent(inout) :: sm real(kind=8), intent(in) :: s Contents None","tags":"","loc":"proc/spin_matrix2.html"},{"title":"set_Dc – TNSG","text":"public subroutine set_Dc(myten, Dc, randomscal) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout), pointer :: myten integer, intent(in) :: Dc real(kind=8), intent(in) :: randomscal Contents None","tags":"","loc":"proc/set_dc.html"},{"title":"direct_sum – TNSG","text":"public subroutine direct_sum(ten1, ten2, ten3, freeze) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: ten1 type(tensor), intent(inout) :: ten2 type(tensor), intent(inout) :: ten3 character(len=*), intent(in) :: freeze (:) Calls proc~~direct_sum~~CallsGraph proc~direct_sum direct_sum proc~ind2pos ind2pos proc~direct_sum->proc~ind2pos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/direct_sum.html"},{"title":"ind2pos – TNSG","text":"public subroutine ind2pos(ind, dims, pos) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ind integer, intent(in) :: dims (:) integer, intent(inout) :: pos (:) Called by proc~~ind2pos~~CalledByGraph proc~ind2pos ind2pos proc~direct_sum direct_sum proc~direct_sum->proc~ind2pos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ind2pos.html"},{"title":"wc_allreduce_Tensor – TNSG","text":"public subroutine wc_allreduce_Tensor(inTensor, outTensor, op, MPIcommon, ierr) Arguments Type Intent Optional Attributes Name type(Tensor), intent(in), target :: inTensor type(Tensor), intent(inout), target :: outTensor integer, intent(in) :: op integer, intent(in), optional :: MPIcommon integer, intent(inout) :: ierr Calls proc~~wc_allreduce_tensor~~CallsGraph proc~wc_allreduce_tensor wc_allreduce_Tensor writemess writemess proc~wc_allreduce_tensor->writemess mpi_allreduce mpi_allreduce proc~wc_allreduce_tensor->mpi_allreduce proc~test_same_length test_same_length proc~wc_allreduce_tensor->proc~test_same_length proc~test_not_empty test_not_empty proc~wc_allreduce_tensor->proc~test_not_empty mpi_comm_rank mpi_comm_rank proc~wc_allreduce_tensor->mpi_comm_rank error_stop error_stop proc~wc_allreduce_tensor->error_stop mpi_comm_size mpi_comm_size proc~wc_allreduce_tensor->mpi_comm_size proc~test_same_type test_same_type proc~wc_allreduce_tensor->proc~test_same_type proc~test_same_tensor test_same_tensor proc~wc_allreduce_tensor->proc~test_same_tensor proc~test_same_length->mpi_allreduce mpi_bcast mpi_bcast proc~test_same_length->mpi_bcast proc~test_not_empty->mpi_allreduce proc~test_same_type->mpi_allreduce proc~test_same_type->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wc_allreduce_tensor.html"},{"title":"wc_reduce_Tensor – TNSG","text":"public subroutine wc_reduce_Tensor(inTensor, outTensor, op, root, MPIcommon, ierr) Arguments Type Intent Optional Attributes Name type(Tensor), intent(in), target :: inTensor type(Tensor), intent(inout), target :: outTensor integer, intent(in) :: op integer, intent(in), optional :: root integer, intent(in), optional :: MPIcommon integer, intent(inout) :: ierr Calls proc~~wc_reduce_tensor~~CallsGraph proc~wc_reduce_tensor wc_reduce_Tensor writemess writemess proc~wc_reduce_tensor->writemess proc~test_same_length test_same_length proc~wc_reduce_tensor->proc~test_same_length proc~test_not_empty test_not_empty proc~wc_reduce_tensor->proc~test_not_empty mpi_comm_rank mpi_comm_rank proc~wc_reduce_tensor->mpi_comm_rank error_stop error_stop proc~wc_reduce_tensor->error_stop mpi_comm_size mpi_comm_size proc~wc_reduce_tensor->mpi_comm_size proc~test_same_type test_same_type proc~wc_reduce_tensor->proc~test_same_type proc~test_same_tensor test_same_tensor proc~wc_reduce_tensor->proc~test_same_tensor mpi_reduce mpi_reduce proc~wc_reduce_tensor->mpi_reduce mpi_bcast mpi_bcast proc~test_same_length->mpi_bcast mpi_allreduce mpi_allreduce proc~test_same_length->mpi_allreduce proc~test_not_empty->mpi_allreduce proc~test_same_type->mpi_bcast proc~test_same_type->mpi_allreduce Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/wc_reduce_tensor.html"},{"title":"enable_ecp_handler – TNSG","text":"public subroutine enable_ecp_handler() Arguments None Contents None","tags":"","loc":"proc/enable_ecp_handler.html"},{"title":"try – TNSG","text":"public subroutine try() Arguments None Contents None","tags":"","loc":"proc/try.html"},{"title":"end_try – TNSG","text":"public subroutine end_try() Arguments None Contents None","tags":"","loc":"proc/end_try.html"},{"title":"throw – TNSG","text":"public subroutine throw(exception) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exception Contents None","tags":"","loc":"proc/throw.html"},{"title":"catch – TNSG","text":"public interface catch Contents Module Procedures catch_arg catch_noarg Module Procedures private function catch_arg(exception) result(exist) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exception Return Value logical private function catch_noarg() result(exist) Arguments None Return Value logical","tags":"","loc":"interface/catch.html"},{"title":"str_date_time – TNSG","text":"public function str_date_time() result(res) Arguments None Return Value character(len=:),\n  allocatable Calls proc~~str_date_time~~CallsGraph proc~str_date_time str_date_time interface~str str proc~str_date_time->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/str_date_time.html"},{"title":"str_date_time_ – TNSG","text":"public function str_date_time_() result(res) Arguments None Return Value character(len=:),\n  allocatable Calls proc~~str_date_time_~~CallsGraph proc~str_date_time_ str_date_time_ interface~str str proc~str_date_time_->interface~str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/str_date_time_.html"},{"title":"tn_draw_on – TNSG","text":"public subroutine tn_draw_on() Arguments None Contents None","tags":"","loc":"proc/tn_draw_on.html"},{"title":"tn_draw_off – TNSG","text":"public subroutine tn_draw_off() Arguments None Contents None","tags":"","loc":"proc/tn_draw_off.html"},{"title":"absorb_rt – TNSG","text":"public subroutine absorb_rt(Tout, Tin, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: Tout class( tn_tensor ), intent(inout) :: Tin integer, intent(in) :: pos (2) Calls proc~~absorb_rt~~CallsGraph proc~absorb_rt absorb_rt proc~lat_absorb_tensor lat_absorb_tensor proc~absorb_rt->proc~lat_absorb_tensor contract contract proc~lat_absorb_tensor->contract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/absorb_rt.html"},{"title":"assignment(=) – TNSG","text":"public interface assignment(=) Contents Module Procedures assignmentDTN assignmentZTN assignmentTTN assignmentTNTN Module Procedures private subroutine assignmentDTN(T1, T2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 private subroutine assignmentZTN(T1, T2) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 private subroutine assignmentTTN(T1, T2) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 private subroutine assignmentTNTN(T1, T2) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2","tags":"","loc":"interface/assignment(=).html"},{"title":"operator(*) – TNSG","text":"public interface operator(*) Contents Module Procedures scale_tn Module Procedures private function scale_tn(T, mul) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(in) :: T class(*), intent(in) :: mul Return Value type( tn_tensor )","tags":"","loc":"interface/operator(*).html"},{"title":"operator(/) – TNSG","text":"public interface operator(/) Contents Module Procedures divide_tn Module Procedures private function divide_tn(T, mul) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(in) :: T class(*), intent(in) :: mul Return Value type( tn_tensor )","tags":"","loc":"interface/operator(SLASH).html"},{"title":"operator(.con.) – TNSG","text":"public interface operator(.con.) Contents Module Procedures conjugate_tn Module Procedures private function conjugate_tn(T) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(in) :: T Return Value type( tn_tensor )","tags":"","loc":"interface/operator(.con.).html"},{"title":"absorb_all_rt – TNSG","text":"public interface absorb_all_rt Contents Module Procedures absorb_all0_rt absorb_all1_rt Module Procedures private function absorb_all0_rt(T, abp) result(Res) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T type( path ), intent(in), optional :: abp Return Value type( tn_tensor ) private function absorb_all1_rt(T1, T2, abp) result(Res) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T1 class( tn_tensor ), intent(inout) :: T2 type( path ), intent(in), optional :: abp Return Value type( tn_tensor )","tags":"","loc":"interface/absorb_all_rt.html"},{"title":"TNcontract – TNSG","text":"public interface TNcontract Contents Module Procedures contract_TNTN Module Procedures private function contract_TNTN(T1, T2) result(Res) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(inout) :: T1 type( tn_tensor ), intent(inout) :: T2 Return Value type( tn_tensor )","tags":"","loc":"interface/tncontract.html"},{"title":"enable_tracer – TNSG","text":"public subroutine enable_tracer() Arguments None Called by proc~~enable_tracer~~CalledByGraph proc~enable_tracer enable_tracer proc~trace_test trace_test proc~trace_test->proc~enable_tracer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/enable_tracer.html"},{"title":"print_tracer – TNSG","text":"public subroutine print_tracer() Arguments None Called by proc~~print_tracer~~CalledByGraph proc~print_tracer print_tracer proc~trace_test trace_test proc~trace_test->proc~print_tracer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_tracer.html"},{"title":"print_tracer_end – TNSG","text":"public subroutine print_tracer_end() Arguments None Contents None","tags":"","loc":"proc/print_tracer_end.html"},{"title":"trace_realtime – TNSG","text":"public subroutine trace_realtime(filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Contents None","tags":"","loc":"proc/trace_realtime.html"},{"title":"print_trace – TNSG","text":"public subroutine print_trace() Arguments None Contents None","tags":"","loc":"proc/print_trace.html"},{"title":"trace_test – TNSG","text":"public subroutine trace_test() Arguments None Calls proc~~trace_test~~CallsGraph proc~trace_test trace_test proc~print_tracer print_tracer proc~trace_test->proc~print_tracer interface~trace trace proc~trace_test->interface~trace proc~enable_tracer enable_tracer proc~trace_test->proc~enable_tracer Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/trace_test.html"},{"title":"trace – TNSG","text":"public interface trace Called by interface~~trace~~CalledByGraph interface~trace trace proc~trace_test trace_test proc~trace_test->interface~trace Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures add_trace end_trace Module Procedures private subroutine add_trace(info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: info private subroutine end_trace() Arguments None","tags":"","loc":"interface/trace.html"},{"title":"percent – TNSG","text":"public subroutine percent(words_in, perc_in, step_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words_in real(kind=8), intent(in) :: perc_in real(kind=8), intent(in), optional :: step_ Calls proc~~percent~~CallsGraph proc~percent percent interface~wc_error_stop wc_error_stop proc~percent->interface~wc_error_stop proc~wc_error_stop_mess2 wc_error_stop_mess2 interface~wc_error_stop->proc~wc_error_stop_mess2 proc~wc_error_stop_mess1 wc_error_stop_mess1 interface~wc_error_stop->proc~wc_error_stop_mess1 proc~wc_error_stop_nomess wc_error_stop_nomess interface~wc_error_stop->proc~wc_error_stop_nomess writemess writemess proc~wc_error_stop_mess2->writemess proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess2->proc~wc_outpicture proc~wc_error_stop_mess1->writemess proc~wc_error_stop_mess1->proc~wc_outpicture proc~wc_error_stop_nomess->proc~wc_outpicture proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/percent.html"},{"title":"percent_end – TNSG","text":"public subroutine percent_end(words_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words_in Calls proc~~percent_end~~CallsGraph proc~percent_end percent_end interface~wc_error_stop wc_error_stop proc~percent_end->interface~wc_error_stop proc~wc_error_stop_mess2 wc_error_stop_mess2 interface~wc_error_stop->proc~wc_error_stop_mess2 proc~wc_error_stop_mess1 wc_error_stop_mess1 interface~wc_error_stop->proc~wc_error_stop_mess1 proc~wc_error_stop_nomess wc_error_stop_nomess interface~wc_error_stop->proc~wc_error_stop_nomess writemess writemess proc~wc_error_stop_mess2->writemess proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess2->proc~wc_outpicture proc~wc_error_stop_mess1->writemess proc~wc_error_stop_mess1->proc~wc_outpicture proc~wc_error_stop_nomess->proc~wc_outpicture proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/percent_end.html"},{"title":"lat_absorb_tensor – TNSG","text":"public subroutine lat_absorb_tensor(fn_tensor, ori_tensor, G, pos) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout), target :: fn_tensor type(tensor), intent(inout), target :: ori_tensor type( group ), intent(inout) :: G integer, intent(in) :: pos (2) Calls proc~~lat_absorb_tensor~~CallsGraph proc~lat_absorb_tensor lat_absorb_tensor contract contract proc~lat_absorb_tensor->contract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~lat_absorb_tensor~~CalledByGraph proc~lat_absorb_tensor lat_absorb_tensor proc~absorb_rt absorb_rt proc~absorb_rt->proc~lat_absorb_tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lat_absorb_tensor.html"},{"title":"lat_absorb_env – TNSG","text":"public subroutine lat_absorb_env(fn_tensor, ori_tensor, G, pos) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout), target :: fn_tensor type(tensor), intent(inout), target :: ori_tensor type( group ), intent(inout) :: G integer, intent(in) :: pos (2) Calls proc~~lat_absorb_env~~CallsGraph proc~lat_absorb_env lat_absorb_env contract contract proc~lat_absorb_env->contract Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lat_absorb_env.html"},{"title":"lat_contract_type – TNSG","text":"public subroutine lat_contract_type(Tout, T1, T2, G1, G2) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: Tout type(tensor), intent(inout) :: T1 type(tensor), intent(inout) :: T2 type( group ), intent(inout) :: G1 type( group ), intent(inout) :: G2 Calls proc~~lat_contract_type~~CallsGraph proc~lat_contract_type lat_contract_type interface~wc_error_stop wc_error_stop proc~lat_contract_type->interface~wc_error_stop contract contract proc~lat_contract_type->contract proc~wc_error_stop_mess2 wc_error_stop_mess2 interface~wc_error_stop->proc~wc_error_stop_mess2 proc~wc_error_stop_mess1 wc_error_stop_mess1 interface~wc_error_stop->proc~wc_error_stop_mess1 proc~wc_error_stop_nomess wc_error_stop_nomess interface~wc_error_stop->proc~wc_error_stop_nomess writemess writemess proc~wc_error_stop_mess2->writemess proc~wc_outpicture wc_outpicture proc~wc_error_stop_mess2->proc~wc_outpicture proc~wc_error_stop_mess1->writemess proc~wc_error_stop_mess1->proc~wc_outpicture proc~wc_error_stop_nomess->proc~wc_outpicture proc~wc_outpicture->writemess Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/lat_contract_type.html"},{"title":"timer – TNSG","text":"Uses type_unidic string error module~~timer~~UsesGraph module~timer timer module~error error module~timer->module~error module~string string module~timer->module~string module~type_unidic type_unidic module~timer->module~type_unidic tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error module~type_unidic->module~error module~type_unidic->module~string module~mod_stack mod_stack module~type_unidic->module~mod_stack module~mod_stack->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces timer_refresh Functions timer_get Subroutines timer_start timer_end timer_print Interfaces public interface timer_refresh private subroutine timer_refresh_all() Arguments None private subroutine timer_refresh_name(name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Functions public function timer_get (name) result(time) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name Return Value real(kind=8) Subroutines public subroutine timer_start (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name public subroutine timer_end (name) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name public subroutine timer_print () Arguments None","tags":"","loc":"module/timer.html"},{"title":"statistics – TNSG","text":"Uses string error tools module~~statistics~~UsesGraph module~statistics statistics tools tools module~statistics->tools module~error error module~statistics->module~error module~string string module~statistics->module~string module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types statis Derived Types type, public :: statis Type-Bound Procedures generic, public :: add => add_sig, add_ary generic, public :: get_perc => get_perc_sig, get_perc_ary generic, public :: get_ave_val => get_ave_val_sig, get_ave_val_ary procedure, public :: clean procedure, public :: show procedure, public :: show2 procedure, public :: sort_key procedure, public :: sort_val","tags":"","loc":"module/statistics.html"},{"title":"mod_rand – TNSG","text":"Uses error module~~mod_rand~~UsesGraph module~mod_rand mod_rand module~error error module~mod_rand->module~error tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_rand~~UsedByGraph module~mod_rand mod_rand module~tnsp_ext tnsp_ext module~tnsp_ext->module~mod_rand module~mod_cumu mod_cumu module~mod_cumu->module~tnsp_ext Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types randomer Derived Types type, public :: randomer Type-Bound Procedures procedure, public :: check_uninited procedure, public :: clean generic, public :: initialize => initialize1, initialize2 procedure, public :: randreal procedure, public :: randInteger procedure, public :: get_seed procedure, public :: get_subseed","tags":"","loc":"module/mod_rand.html"},{"title":"parameter_list – TNSG","text":"Uses string error mod_dictionary module~~parameter_list~~UsesGraph module~parameter_list parameter_list module~mod_dictionary mod_dictionary module~parameter_list->module~mod_dictionary module~error error module~parameter_list->module~error module~string string module~parameter_list->module~string module~mod_dictionary->module~error module~mod_dictionary->module~string tensor_type tensor_type module~mod_dictionary->tensor_type tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types para_list Derived Types type, public, extends( dictionary ) :: para_list Type-Bound Procedures procedure, public :: get_names procedure, public :: sub_name procedure, public :: sub_val generic, public :: setvalue => isetvalue, dsetvalue, zsetvalue, asetvalue, lsetvalue, tsetvalue, misetvalue, mdsetvalue, masetvalue, mlsetvalue generic, public :: getvalue => igetvalue, dgetvalue, zgetvalue, agetvalue, lgetvalue, tgetvalue, migetvalue, mdgetvalue, magetvalue, mlgetvalue generic, public :: insert => insert_int, insert_dbl, insert_com, insert_char, insert_logi, insert_ten, insert_int_ary, insert_dbl_ary, insert_char_ary, insert_logi_ary procedure, public :: mli procedure, public :: mai procedure, public :: mdi procedure, public :: mii procedure, public :: ti procedure, public :: li procedure, public :: ai procedure, public :: zi procedure, public :: di procedure, public :: ii procedure, public :: append procedure, public :: check_contain procedure, public :: search procedure, public :: read procedure, public :: print procedure, public :: subpara_name procedure, public :: subpara_class procedure, public :: clean procedure, public :: rename procedure, public :: setclass generic, public :: pinsert => pinsert_int, pinsert_real, pinsert_com, pinsert_char, pinsert_logi, pinsert_int_ary, pinsert_real_ary, pinsert_char_ary, pinsert_logi_ary procedure, public :: delete procedure, public :: append_para","tags":"","loc":"module/parameter_list.html"},{"title":"error – TNSG","text":"Uses tools mod_mpi_info module~~error~~UsesGraph module~error error tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~error~~UsedByGraph module~error error module~tnsp_ext tnsp_ext module~tnsp_ext->module~error module~mod_rand mod_rand module~tnsp_ext->module~mod_rand module~string string module~tnsp_ext->module~string module~timer timer module~timer->module~error module~type_unidic type_unidic module~timer->module~type_unidic module~timer->module~string module~mod_stack mod_stack module~mod_stack->module~error module~type_unidic->module~error module~type_unidic->module~mod_stack module~type_unidic->module~string module~mod_dictionary mod_dictionary module~mod_dictionary->module~error module~mod_dictionary->module~string module~mod_rand->module~error module~tn_tensor_type tn_tensor_type module~tn_tensor_type->module~error module~tensor_network tensor_network module~tn_tensor_type->module~tensor_network module~mod_cumu mod_cumu module~mod_cumu->module~error module~mod_cumu->module~tnsp_ext module~mod_percent mod_percent module~mod_percent->module~error module~statistics statistics module~statistics->module~error module~statistics->module~string module~tensor_network->module~error module~tensor_network->module~type_unidic module~tensor_network->module~mod_dictionary module~tensor_network->module~string module~parameter_list parameter_list module~parameter_list->module~error module~parameter_list->module~mod_dictionary module~parameter_list->module~string module~string->module~error module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~error module~tensor_network_nesting->module~tn_tensor_type module~tensor_network_nesting->module~tensor_network module~tensor_network_nesting->module~string module~mod_date_time mod_date_time module~mod_date_time->module~string var panmoduleerrorUsedByGraph = svgPanZoom('#moduleerrorUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test_tag Interfaces wc_error_stop Subroutines error_test_tag wc_error_stop_mess2 wc_error_stop_mess1 wc_error_stop_nomess wc_outpicture Variables Type Visibility Attributes Name Initial logical, public :: test_tag = .false. Interfaces public interface wc_error_stop public subroutine wc_error_stop_mess2 (error_pos, error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_pos character(len=*), intent(in) :: error_mess public subroutine wc_error_stop_mess1 (error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_mess public subroutine wc_error_stop_nomess () Arguments None Subroutines public subroutine error_test_tag (tag) Arguments Type Intent Optional Attributes Name logical, intent(in) :: tag public subroutine wc_error_stop_mess2 (error_pos, error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_pos character(len=*), intent(in) :: error_mess public subroutine wc_error_stop_mess1 (error_mess) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: error_mess public subroutine wc_error_stop_nomess () Arguments None public subroutine wc_outpicture () Arguments None","tags":"","loc":"module/error.html"},{"title":"mod_stack – TNSG","text":"Uses error module~~mod_stack~~UsesGraph module~mod_stack mod_stack module~error error module~mod_stack->module~error tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_stack~~UsedByGraph module~mod_stack mod_stack module~type_unidic type_unidic module~type_unidic->module~mod_stack module~timer timer module~timer->module~type_unidic module~tensor_network tensor_network module~tensor_network->module~type_unidic module~tn_tensor_type tn_tensor_type module~tn_tensor_type->module~tensor_network module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~tensor_network module~tensor_network_nesting->module~tn_tensor_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types stack Derived Types type, public :: stack Type-Bound Procedures procedure, public :: push procedure, public :: pop procedure, public :: top procedure, public :: num procedure, public :: clean procedure, public :: read procedure, public :: write procedure, public :: real_length procedure, public :: consistent procedure, public :: items procedure, public :: copy generic, public :: assignment(=) => copy procedure, public :: compare generic, public :: operator(==) => compare","tags":"","loc":"module/mod_stack.html"},{"title":"string – TNSG","text":"Uses error module~~string~~UsesGraph module~string string module~error error module~string->module~error tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~string~~UsedByGraph module~string string module~tnsp_ext tnsp_ext module~tnsp_ext->module~string module~timer timer module~timer->module~string module~type_unidic type_unidic module~timer->module~type_unidic module~mod_dictionary mod_dictionary module~mod_dictionary->module~string module~type_unidic->module~string module~statistics statistics module~statistics->module~string module~tensor_network tensor_network module~tensor_network->module~string module~tensor_network->module~mod_dictionary module~tensor_network->module~type_unidic module~parameter_list parameter_list module~parameter_list->module~string module~parameter_list->module~mod_dictionary module~mod_date_time mod_date_time module~mod_date_time->module~string module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~string module~tensor_network_nesting->module~tensor_network module~tn_tensor_type tn_tensor_type module~tensor_network_nesting->module~tn_tensor_type module~mod_cumu mod_cumu module~mod_cumu->module~tnsp_ext module~tn_tensor_type->module~tensor_network Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables max_char_length Interfaces str operator(//) Functions after_dot before_dot str_before str_after Variables Type Visibility Attributes Name Initial integer, public, parameter :: max_char_length = 500 Interfaces public interface str private function int2str(inte) result(str) Arguments Type Intent Optional Attributes Name integer, intent(in) :: inte Return Value character(len=:),\n  allocatable private function int_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function flt2str(num, digit) result(str) Arguments Type Intent Optional Attributes Name real(kind=4), intent(in) :: num integer, intent(in), optional :: digit Return Value character(len=:),\n  allocatable private function flt_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name real(kind=4), intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function dbl2str(num, digit_) result(str2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: num integer, intent(in), optional :: digit_ Return Value character(len=:),\n  allocatable private function dbl_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function com2str(num, digit) result(str) Arguments Type Intent Optional Attributes Name complex, intent(in) :: num integer, intent(in), optional :: digit Return Value character(len=:),\n  allocatable private function com_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name complex(kind=4), intent(in) :: nums (:) character(len=*), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function dcom2str(num, digit) result(str) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: num integer, intent(in), optional :: digit Return Value character(len=:),\n  allocatable private function dcom_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(in) :: nums (:) character(len=*), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function logi2str(num) result(str) Arguments Type Intent Optional Attributes Name logical, intent(in) :: num Return Value character(len=:),\n  allocatable private function logi_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name logical, intent(in) :: nums (:) character(len=*), intent(in), optional :: split Return Value character(len=:),\n  allocatable private function str_ary2str(nums, split) result(str2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nums (:) character(len=1), intent(in), optional :: split Return Value character(len=:),\n  allocatable public interface operator(//) private function concat(st1, st2) result(str) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: st1 class(*), intent(in) :: st2 Return Value character(len=:),\n  allocatable Functions public function after_dot (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public function before_dot (str) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=:),\n  allocatable public function str_before (str, ch) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in) :: ch Return Value character(len=:),\n  allocatable public function str_after (str, ch) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=1), intent(in) :: ch Return Value character(len=:),\n  allocatable","tags":"","loc":"module/string.html"},{"title":"tnsp_ext – TNSG","text":"! mpi Uses tensor_type tools string error mpi mod_rand module~~tnsp_ext~~UsesGraph module~tnsp_ext tnsp_ext mpi mpi module~tnsp_ext->mpi module~mod_rand mod_rand module~tnsp_ext->module~mod_rand module~error error module~tnsp_ext->module~error tensor_type tensor_type module~tnsp_ext->tensor_type tools tools module~tnsp_ext->tools module~string string module~tnsp_ext->module~string module~mod_rand->module~error module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~tnsp_ext~~UsedByGraph module~tnsp_ext tnsp_ext module~mod_cumu mod_cumu module~mod_cumu->module~tnsp_ext Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types tnary Functions dbl randten_sign test_same_tensor test_not_empty test_same_type test_same_length Subroutines kill_D1_ind permute_as print_data HOSVD cre_ann_number spin_matrix spin_matrix2 set_Dc direct_sum ind2pos wc_allreduce_Tensor wc_reduce_Tensor Derived Types type, public :: tnary Components Type Visibility Attributes Name Initial type(Tensor), public :: tn type(Tensor), public, allocatable :: tns (:,:) Functions public function dbl (T) result(res) Arguments Type Intent Optional Attributes Name class(tensor), intent(in) :: T Return Value real(kind=8) public function randten_sign (ten, th1, th2, rand_grad, n1, n2, tot) result(rand_ten) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: ten real(kind=8), intent(in) :: th1 real(kind=8), intent(in) :: th2 type( randomer ), intent(inout) :: rand_grad integer, intent(inout) :: n1 integer, intent(inout) :: n2 integer, intent(inout) :: tot Return Value type(tensor) public function test_same_tensor (T1, T2) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in), target :: T1 type(tensor), intent(in), target :: T2 Return Value logical public function test_not_empty (T, mpi_comm) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: T integer, intent(in) :: mpi_comm Return Value integer public function test_same_type (T, mpi_comm) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: T integer, intent(in) :: mpi_comm Return Value integer public function test_same_length (T, mpi_comm) result(res) Arguments Type Intent Optional Attributes Name type(tensor), intent(in) :: T integer, intent(in) :: mpi_comm Return Value integer Subroutines public subroutine kill_D1_ind (T) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T public subroutine permute_as (T, P) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T type(tensor), intent(in) :: P public subroutine print_data (T, unit, fmt) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T integer, intent(in) :: unit logical, intent(in) :: fmt public subroutine HOSVD (T, uni, env, cen, names, Dc) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T type(tensor), intent(inout) :: uni (:) type(tensor), intent(inout) :: env (:) type(tensor), intent(inout) :: cen character(len=*), intent(in) :: names (:) integer, intent(in), optional :: Dc public subroutine cre_ann_number (A, A_dg, N, N2, D) Arguments Type Intent Optional Attributes Name type(Tensor), intent(out) :: A type(Tensor), intent(out) :: A_dg type(Tensor), intent(out) :: N type(Tensor), intent(out) :: N2 integer, intent(in) :: D public subroutine spin_matrix (sx, sy, sz, s) Arguments Type Intent Optional Attributes Name type(Tensor), intent(inout) :: sx type(Tensor), intent(inout) :: sy type(Tensor), intent(inout) :: sz real(kind=8), intent(in) :: s public subroutine spin_matrix2 (sx, sy, sz, sp, sm, s) Arguments Type Intent Optional Attributes Name type(Tensor), intent(inout) :: sx type(Tensor), intent(inout) :: sy type(Tensor), intent(inout) :: sz type(Tensor), intent(inout) :: sp type(Tensor), intent(inout) :: sm real(kind=8), intent(in) :: s public subroutine set_Dc (myten, Dc, randomscal) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout), pointer :: myten integer, intent(in) :: Dc real(kind=8), intent(in) :: randomscal public subroutine direct_sum (ten1, ten2, ten3, freeze) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: ten1 type(tensor), intent(inout) :: ten2 type(tensor), intent(inout) :: ten3 character(len=*), intent(in) :: freeze (:) public subroutine ind2pos (ind, dims, pos) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ind integer, intent(in) :: dims (:) integer, intent(inout) :: pos (:) public subroutine wc_allreduce_Tensor (inTensor, outTensor, op, MPIcommon, ierr) Arguments Type Intent Optional Attributes Name type(Tensor), intent(in), target :: inTensor type(Tensor), intent(inout), target :: outTensor integer, intent(in) :: op integer, intent(in), optional :: MPIcommon integer, intent(inout) :: ierr public subroutine wc_reduce_Tensor (inTensor, outTensor, op, root, MPIcommon, ierr) Arguments Type Intent Optional Attributes Name type(Tensor), intent(in), target :: inTensor type(Tensor), intent(inout), target :: outTensor integer, intent(in) :: op integer, intent(in), optional :: root integer, intent(in), optional :: MPIcommon integer, intent(inout) :: ierr","tags":"","loc":"module/tnsp_ext.html"},{"title":"mod_mpi_info – TNSG","text":"Used by module~~mod_mpi_info~~UsedByGraph module~mod_mpi_info mod_mpi_info module~mod_percent mod_percent module~mod_percent->module~mod_mpi_info module~error error module~mod_percent->module~error module~error->module~mod_mpi_info module~tnsp_ext tnsp_ext module~tnsp_ext->module~error module~mod_rand mod_rand module~tnsp_ext->module~mod_rand module~string string module~tnsp_ext->module~string module~timer timer module~timer->module~error module~type_unidic type_unidic module~timer->module~type_unidic module~timer->module~string module~mod_stack mod_stack module~mod_stack->module~error module~type_unidic->module~error module~type_unidic->module~mod_stack module~type_unidic->module~string module~mod_dictionary mod_dictionary module~mod_dictionary->module~error module~mod_dictionary->module~string module~mod_rand->module~error module~tn_tensor_type tn_tensor_type module~tn_tensor_type->module~error module~tensor_network tensor_network module~tn_tensor_type->module~tensor_network module~mod_cumu mod_cumu module~mod_cumu->module~error module~mod_cumu->module~tnsp_ext module~statistics statistics module~statistics->module~error module~statistics->module~string module~tensor_network->module~error module~tensor_network->module~type_unidic module~tensor_network->module~mod_dictionary module~tensor_network->module~string module~parameter_list parameter_list module~parameter_list->module~error module~parameter_list->module~mod_dictionary module~parameter_list->module~string module~string->module~error module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~error module~tensor_network_nesting->module~tn_tensor_type module~tensor_network_nesting->module~tensor_network module~tensor_network_nesting->module~string module~mod_date_time mod_date_time module~mod_date_time->module~string var panmodulemod_mpi_infoUsedByGraph = svgPanZoom('#modulemod_mpi_infoUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables nproc my_rank Variables Type Visibility Attributes Name Initial integer, public :: nproc = 1 integer, public :: my_rank = 0","tags":"","loc":"module/mod_mpi_info.html"},{"title":"ecp_handler – TNSG","text":"Contents Interfaces catch Subroutines enable_ecp_handler try end_try throw Interfaces public interface catch private function catch_arg(exception) result(exist) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exception Return Value logical private function catch_noarg() result(exist) Arguments None Return Value logical Subroutines public subroutine enable_ecp_handler () Arguments None public subroutine try () Arguments None public subroutine end_try () Arguments None public subroutine throw (exception) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exception","tags":"","loc":"module/ecp_handler.html"},{"title":"mod_cumu – TNSG","text":"Uses tensor_type tnsp_ext error module~~mod_cumu~~UsesGraph module~mod_cumu mod_cumu module~tnsp_ext tnsp_ext module~mod_cumu->module~tnsp_ext module~error error module~mod_cumu->module~error tensor_type tensor_type module~mod_cumu->tensor_type module~tnsp_ext->module~error module~tnsp_ext->tensor_type mpi mpi module~tnsp_ext->mpi module~mod_rand mod_rand module~tnsp_ext->module~mod_rand tools tools module~tnsp_ext->tools module~string string module~tnsp_ext->module~string module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~mod_rand->module~error module~string->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types cumulator Derived Types type, public :: cumulator Type-Bound Procedures procedure, public :: init generic, public :: add => iadd, dadd, zadd, tadd procedure, public :: clean procedure, public :: dave procedure, public :: zave procedure, public :: tave procedure, public :: get_weight","tags":"","loc":"module/mod_cumu.html"},{"title":"mod_date_time – TNSG","text":"Uses string module~~mod_date_time~~UsesGraph module~mod_date_time mod_date_time module~string string module~mod_date_time->module~string module~error error module~string->module~error tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions str_date_time str_date_time_ Functions public function str_date_time () result(res) Arguments None Return Value character(len=:),\n  allocatable public function str_date_time_ () result(res) Arguments None Return Value character(len=:),\n  allocatable","tags":"","loc":"module/mod_date_time.html"},{"title":"tn_tensor_type – TNSG","text":"Uses error tools tensor_network tensor_type module~~tn_tensor_type~~UsesGraph module~tn_tensor_type tn_tensor_type tools tools module~tn_tensor_type->tools module~error error module~tn_tensor_type->module~error tensor_type tensor_type module~tn_tensor_type->tensor_type module~tensor_network tensor_network module~tn_tensor_type->module~tensor_network module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~tensor_network->tools module~tensor_network->module~error module~tensor_network->tensor_type module~mod_dictionary mod_dictionary module~tensor_network->module~mod_dictionary module~type_unidic type_unidic module~tensor_network->module~type_unidic module~string string module~tensor_network->module~string module~mod_dictionary->module~error module~mod_dictionary->tensor_type module~mod_dictionary->module~string module~type_unidic->module~error module~type_unidic->module~string module~mod_stack mod_stack module~type_unidic->module~mod_stack module~string->module~error module~mod_stack->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~tn_tensor_type~~UsedByGraph module~tn_tensor_type tn_tensor_type module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~tn_tensor_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces assignment(=) operator(*) operator(/) operator(.con.) absorb_all_rt TNcontract Derived Types tn_tensor Subroutines tn_draw_on tn_draw_off absorb_rt Interfaces public interface assignment(=) private subroutine assignmentDTN(T1, T2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 private subroutine assignmentZTN(T1, T2) Arguments Type Intent Optional Attributes Name complex(kind=8), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 private subroutine assignmentTTN(T1, T2) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 private subroutine assignmentTNTN(T1, T2) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(inout) :: T1 type( tn_tensor ), intent(in) :: T2 public interface operator(*) private function scale_tn(T, mul) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(in) :: T class(*), intent(in) :: mul Return Value type( tn_tensor ) public interface operator(/) private function divide_tn(T, mul) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(in) :: T class(*), intent(in) :: mul Return Value type( tn_tensor ) public interface operator(.con.) private function conjugate_tn(T) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(in) :: T Return Value type( tn_tensor ) public interface absorb_all_rt private function absorb_all0_rt(T, abp) result(Res) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T type( path ), intent(in), optional :: abp Return Value type( tn_tensor ) private function absorb_all1_rt(T1, T2, abp) result(Res) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: T1 class( tn_tensor ), intent(inout) :: T2 type( path ), intent(in), optional :: abp Return Value type( tn_tensor ) public interface TNcontract private function contract_TNTN(T1, T2) result(Res) Arguments Type Intent Optional Attributes Name type( tn_tensor ), intent(inout) :: T1 type( tn_tensor ), intent(inout) :: T2 Return Value type( tn_tensor ) Derived Types type, public, extends(tensor) :: tn_tensor Type-Bound Procedures procedure, public :: get_info procedure, public :: draw procedure, public :: empty procedure, public :: absorb procedure, public :: absorb_with_env procedure, public :: absorb_just_env procedure, public :: take generic, public :: absorb_all => absorb_all0, absorb_all1 procedure, public :: belong generic, public :: take_except => take_except_pos, take_except_name, take_except_path, take_except_group generic, public :: absorb_except => absorb0_except_pos, absorb0_except_name, absorb1_except_pos procedure, public :: invert_bond procedure, public :: get_lattice_link Subroutines public subroutine tn_draw_on () Arguments None public subroutine tn_draw_off () Arguments None public subroutine absorb_rt (Tout, Tin, pos) Arguments Type Intent Optional Attributes Name class( tn_tensor ), intent(inout) :: Tout class( tn_tensor ), intent(inout) :: Tin integer, intent(in) :: pos (2)","tags":"","loc":"module/tn_tensor_type.html"},{"title":"tracer – TNSG","text":"Contents Interfaces trace Subroutines enable_tracer print_tracer print_tracer_end trace_realtime print_trace trace_test Interfaces public interface trace private subroutine add_trace(info) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: info private subroutine end_trace() Arguments None Subroutines public subroutine enable_tracer () Arguments None public subroutine print_tracer () Arguments None public subroutine print_tracer_end () Arguments None public subroutine trace_realtime (filename) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename public subroutine print_trace () Arguments None public subroutine trace_test () Arguments None","tags":"","loc":"module/tracer.html"},{"title":"tensor_network_nesting – TNSG","text":"Uses tensor_network tensor_type error tools string tn_tensor_type module~~tensor_network_nesting~~UsesGraph module~tensor_network_nesting tensor_network_nesting module~tn_tensor_type tn_tensor_type module~tensor_network_nesting->module~tn_tensor_type module~error error module~tensor_network_nesting->module~error tensor_type tensor_type module~tensor_network_nesting->tensor_type tools tools module~tensor_network_nesting->tools module~tensor_network tensor_network module~tensor_network_nesting->module~tensor_network module~string string module~tensor_network_nesting->module~string module~tn_tensor_type->module~error module~tn_tensor_type->tensor_type module~tn_tensor_type->tools module~tn_tensor_type->module~tensor_network module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~tensor_network->module~error module~tensor_network->tensor_type module~tensor_network->tools module~tensor_network->module~string module~mod_dictionary mod_dictionary module~tensor_network->module~mod_dictionary module~type_unidic type_unidic module~tensor_network->module~type_unidic module~string->module~error module~mod_dictionary->module~error module~mod_dictionary->tensor_type module~mod_dictionary->module~string module~type_unidic->module~error module~type_unidic->module~string module~mod_stack mod_stack module~type_unidic->module~mod_stack module~mod_stack->module~error var panmoduletensor_network_nestingUsesGraph = svgPanZoom('#moduletensor_network_nestingUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables test_lattice_clt Derived Types nest_lattice Variables Type Visibility Attributes Name Initial integer, public :: test_lattice_clt = 0 Derived Types type, public, extends( lattice ) :: nest_lattice Components Type Visibility Attributes Name Initial class( lattice ), public, pointer :: lat_pre Type-Bound Procedures procedure, public :: initialize procedure, public :: clean procedure, public :: mirror_con procedure, public :: copy_line procedure, public :: copy_line_ten procedure, public :: copy_line_link generic, public :: set_bond_as => set_bond_as_pure, set_bond_as_cluster, set_bond_as_path procedure, public :: draw_l procedure, public :: draw_tn generic, public :: draw => draw_l, draw_tn generic, public :: add => add_from_ten, add_from_lat_pos generic, public :: delete => delete_pos, delete_name generic, public :: move => move_pos, move_name procedure, public :: move_row procedure, public :: move_column generic, public :: rename => rename_pos, rename_name generic, public :: back_up => back_up_pos, back_up_name generic, public :: restore => restore_pos, restore_name generic, public :: get_tensor => get_tensor_pos, get_tensor_name generic, public :: get_tensor_link => get_tensor_link_pos, get_tensor_link_name generic, public :: get_env_link => get_env_link_pos, get_env_link_name generic, public :: get_env_bond => get_env_bond_pos generic, public :: set_env_bond => set_env_bond_pos generic, public :: update_tensor => update_tensor_pos, update_tensor_name generic, public :: set_tensor => set_tensor_pos, set_tensor_name generic, public :: point_info => point_info_pos, point_info_name, point_info_lat generic, public :: set_bond => set_bond_pos, set_bond_name generic, public :: get_bond => get_bond_pos, get_bond_name generic, public :: get_bonds => get_bonds_pos, get_bonds_name generic, public :: get_bond_no => get_bond_no_pos, get_bond_no_name generic, public :: remove_bond => remove_bond_pos, remove_bond_name generic, public :: invert_bond => invert_bond_pos, invert_bond_name generic, public :: get_nb_num => get_nb_num_pos, get_nb_num_name procedure, public :: get_max_nb_num procedure, public :: absorb procedure, public :: get_size procedure, public :: get_range generic, public :: get_name => get_name_whole, get_name_site procedure, public :: get_pos generic, public :: set_name => set_name_lat procedure, public :: ind_name procedure, public :: check_boundary procedure, public :: get_contag_pos procedure, public :: get_contag_name generic, public :: get_contag => get_contag_pos, get_contag_name generic, public :: set_contag => set_contag_pos, set_contag_name procedure, public :: cut_bonds procedure, public :: max_cut_bonds procedure, public :: get_empty_tag generic, public :: check_exist => check_exist_pos, check_exist_name generic, public :: check_exist_bond => check_exist_bond_pos, check_exist_bond_name generic, public :: bonds_num => bonds_num_pos, bonds_num_name generic, public :: check_empty => check_empty_whole, check_empty_site_pos, check_empty_site_name generic, public :: check_unempty => check_unempty_whole, check_unempty_site_pos, check_unempty_site_name procedure, public :: write procedure, public :: read procedure, public :: generate_ten procedure, public :: generate_env generic, public :: absorb_env => absorb_env_whole generic, public :: absorb_env_bond => absorb_env_pos_bond, absorb_env_name_bond generic, public :: absorb_env_site => absorb_env_pos_site generic, public :: tensor_absorb_env => tensor_absorb_env_pos generic, public :: spit_env => spit_env_whole generic, public :: spit_env_bond => spit_env_pos_bond, spit_env_name_bond generic, public :: assignment(=) => copy_lat procedure, public :: transpose_lat generic, public :: insert_info => dinsert_info_whole, dinsert_info_pos, dinsert_info_name, zinsert_info_whole, zinsert_info_pos, zinsert_info_name, iinsert_info_whole, iinsert_info_pos, iinsert_info_name, linsert_info_whole, linsert_info_pos, linsert_info_name, ainsert_info_whole, ainsert_info_pos, ainsert_info_name, tinsert_info_whole, tinsert_info_pos, tinsert_info_name procedure, public :: tget_info_whole procedure, public :: aget_info_whole procedure, public :: lget_info_whole procedure, public :: iget_info_whole procedure, public :: zget_info_whole procedure, public :: dget_info_whole procedure, public :: tget_info_pos procedure, public :: aget_info_pos procedure, public :: lget_info_pos procedure, public :: iget_info_pos procedure, public :: zget_info_pos procedure, public :: dget_info_pos procedure, public :: tget_info_name procedure, public :: aget_info_name procedure, public :: lget_info_name procedure, public :: iget_info_name procedure, public :: zget_info_name procedure, public :: dget_info_name generic, public :: get_info => dget_info_whole, dget_info_pos, dget_info_name, zget_info_whole, zget_info_pos, zget_info_name, iget_info_whole, iget_info_pos, iget_info_name, lget_info_whole, lget_info_pos, lget_info_name, aget_info_whole, aget_info_pos, aget_info_name, tget_info_whole, tget_info_pos, tget_info_name procedure, public :: tset_info_whole procedure, public :: aset_info_whole procedure, public :: lset_info_whole procedure, public :: iset_info_whole procedure, public :: zset_info_whole procedure, public :: dset_info_whole procedure, public :: tset_info_pos procedure, public :: aset_info_pos procedure, public :: lset_info_pos procedure, public :: iset_info_pos procedure, public :: zset_info_pos procedure, public :: dset_info_pos procedure, public :: tset_info_name procedure, public :: aset_info_name procedure, public :: lset_info_name procedure, public :: iset_info_name procedure, public :: zset_info_name procedure, public :: dset_info_name generic, public :: set_info => dset_info_whole, dset_info_pos, dset_info_name, zset_info_whole, zset_info_pos, zset_info_name, iset_info_whole, iset_info_pos, iset_info_name, lset_info_whole, lset_info_pos, lset_info_name, aset_info_whole, aset_info_pos, aset_info_name, tset_info_whole, tset_info_pos, tset_info_name procedure, public :: initialize_nest procedure, public :: generate procedure, public :: set_cluster procedure, public :: set_tensor_nest procedure, public :: get_outer_pos procedure, public :: calc_except procedure, public :: re_calc procedure, public :: restore_nest procedure, public :: check_exist_nest procedure, public :: in_clt procedure, public :: clt_pos","tags":"","loc":"module/tensor_network_nesting.html"},{"title":"mod_dictionary – TNSG","text":"Uses error string tensor_type module~~mod_dictionary~~UsesGraph module~mod_dictionary mod_dictionary module~error error module~mod_dictionary->module~error tensor_type tensor_type module~mod_dictionary->tensor_type module~string string module~mod_dictionary->module~string tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~mod_dictionary~~UsedByGraph module~mod_dictionary mod_dictionary module~parameter_list parameter_list module~parameter_list->module~mod_dictionary module~tensor_network tensor_network module~tensor_network->module~mod_dictionary module~tn_tensor_type tn_tensor_type module~tn_tensor_type->module~tensor_network module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~tensor_network module~tensor_network_nesting->module~tn_tensor_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types dictionary Derived Types type, public :: dictionary Type-Bound Procedures procedure, public :: read procedure, public :: print procedure, public :: get_names procedure, public :: sub_name procedure, public :: sub_val procedure, public :: clean procedure, public :: rename generic, public :: setvalue => isetvalue, dsetvalue, zsetvalue, asetvalue, lsetvalue, tsetvalue, misetvalue, mdsetvalue, masetvalue, mlsetvalue generic, public :: getvalue => igetvalue, dgetvalue, zgetvalue, agetvalue, lgetvalue, tgetvalue, migetvalue, mdgetvalue, magetvalue, mlgetvalue generic, public :: insert => insert_int, insert_dbl, insert_com, insert_char, insert_logi, insert_ten, insert_int_ary, insert_dbl_ary, insert_char_ary, insert_logi_ary procedure, public :: delete procedure, public :: mli procedure, public :: mai procedure, public :: mdi procedure, public :: mii procedure, public :: ti procedure, public :: li procedure, public :: ai procedure, public :: zi procedure, public :: di procedure, public :: ii procedure, public :: append procedure, public :: check_contain procedure, public :: search","tags":"","loc":"module/mod_dictionary.html"},{"title":"mod_percent – TNSG","text":"Uses mod_mpi_info error module~~mod_percent~~UsesGraph module~mod_percent mod_percent module~error error module~mod_percent->module~error module~mod_mpi_info mod_mpi_info module~mod_percent->module~mod_mpi_info module~error->module~mod_mpi_info tools tools module~error->tools Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines percent percent_end Subroutines public subroutine percent (words_in, perc_in, step_) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words_in real(kind=8), intent(in) :: perc_in real(kind=8), intent(in), optional :: step_ public subroutine percent_end (words_in) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: words_in","tags":"","loc":"module/mod_percent.html"},{"title":"type_unidic – TNSG","text":"Uses error string mod_stack module~~type_unidic~~UsesGraph module~type_unidic type_unidic module~mod_stack mod_stack module~type_unidic->module~mod_stack module~error error module~type_unidic->module~error module~string string module~type_unidic->module~string module~mod_stack->module~error tools tools module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~type_unidic~~UsedByGraph module~type_unidic type_unidic module~timer timer module~timer->module~type_unidic module~tensor_network tensor_network module~tensor_network->module~type_unidic module~tn_tensor_type tn_tensor_type module~tn_tensor_type->module~tensor_network module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~tensor_network module~tensor_network_nesting->module~tn_tensor_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types unidic Derived Types type, public :: unidic Finalizations Procedures final :: clean_dic Type-Bound Procedures procedure, public :: num procedure, public :: add procedure, public :: del procedure, public :: val procedure, public :: show procedure, public :: rename procedure, public :: clean procedure, public :: print procedure, public :: read generic, public :: assignment(=) => copy","tags":"","loc":"module/type_unidic.html"},{"title":"tensor_network – TNSG","text":"!!!!!!!!!!!!!!!!!!!!!!! info !!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!! Dynamic lattice !!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!! Output Info !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!! Used in tn_tensor !!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!! Group !!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!path!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses tensor_type error tools string type_unidic mod_dictionary module~~tensor_network~~UsesGraph module~tensor_network tensor_network module~mod_dictionary mod_dictionary module~tensor_network->module~mod_dictionary module~type_unidic type_unidic module~tensor_network->module~type_unidic module~error error module~tensor_network->module~error tensor_type tensor_type module~tensor_network->tensor_type tools tools module~tensor_network->tools module~string string module~tensor_network->module~string module~mod_dictionary->module~error module~mod_dictionary->tensor_type module~mod_dictionary->module~string module~type_unidic->module~error module~type_unidic->module~string module~mod_stack mod_stack module~type_unidic->module~mod_stack module~error->tools module~mod_mpi_info mod_mpi_info module~error->module~mod_mpi_info module~string->module~error module~mod_stack->module~error Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~tensor_network~~UsedByGraph module~tensor_network tensor_network module~tn_tensor_type tn_tensor_type module~tn_tensor_type->module~tensor_network module~tensor_network_nesting tensor_network_nesting module~tensor_network_nesting->module~tensor_network module~tensor_network_nesting->module~tn_tensor_type Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types lattice group path Subroutines lat_absorb_tensor lat_absorb_env lat_contract_type Derived Types type, public :: lattice Type-Bound Procedures procedure, public :: initialize procedure, public :: clean procedure, public :: mirror_con procedure, public :: copy_line procedure, public :: copy_line_ten procedure, public :: copy_line_link generic, public :: set_bond_as => set_bond_as_pure, set_bond_as_cluster, set_bond_as_path procedure, public :: draw_l procedure, public :: draw_tn generic, public :: draw => draw_l, draw_tn generic, public :: add => add_from_ten, add_from_lat_pos generic, public :: delete => delete_pos, delete_name generic, public :: move => move_pos, move_name procedure, public :: move_row procedure, public :: move_column generic, public :: rename => rename_pos, rename_name generic, public :: back_up => back_up_pos, back_up_name generic, public :: restore => restore_pos, restore_name generic, public :: get_tensor => get_tensor_pos, get_tensor_name generic, public :: get_tensor_link => get_tensor_link_pos, get_tensor_link_name generic, public :: get_env_link => get_env_link_pos, get_env_link_name generic, public :: get_env_bond => get_env_bond_pos generic, public :: set_env_bond => set_env_bond_pos generic, public :: update_tensor => update_tensor_pos, update_tensor_name generic, public :: set_tensor => set_tensor_pos, set_tensor_name generic, public :: point_info => point_info_pos, point_info_name, point_info_lat generic, public :: set_bond => set_bond_pos, set_bond_name generic, public :: get_bond => get_bond_pos, get_bond_name generic, public :: get_bonds => get_bonds_pos, get_bonds_name generic, public :: get_bond_no => get_bond_no_pos, get_bond_no_name generic, public :: remove_bond => remove_bond_pos, remove_bond_name generic, public :: invert_bond => invert_bond_pos, invert_bond_name generic, public :: get_nb_num => get_nb_num_pos, get_nb_num_name procedure, public :: get_max_nb_num procedure, public :: absorb procedure, public :: get_size procedure, public :: get_range generic, public :: get_name => get_name_whole, get_name_site procedure, public :: get_pos generic, public :: set_name => set_name_lat procedure, public :: ind_name procedure, public :: check_boundary procedure, public :: get_contag_pos procedure, public :: get_contag_name generic, public :: get_contag => get_contag_pos, get_contag_name generic, public :: set_contag => set_contag_pos, set_contag_name procedure, public :: cut_bonds procedure, public :: max_cut_bonds procedure, public :: get_empty_tag generic, public :: check_exist => check_exist_pos, check_exist_name generic, public :: check_exist_bond => check_exist_bond_pos, check_exist_bond_name generic, public :: bonds_num => bonds_num_pos, bonds_num_name generic, public :: check_empty => check_empty_whole, check_empty_site_pos, check_empty_site_name generic, public :: check_unempty => check_unempty_whole, check_unempty_site_pos, check_unempty_site_name procedure, public :: write procedure, public :: read procedure, public :: generate_ten procedure, public :: generate_env generic, public :: absorb_env => absorb_env_whole generic, public :: absorb_env_bond => absorb_env_pos_bond, absorb_env_name_bond generic, public :: absorb_env_site => absorb_env_pos_site generic, public :: tensor_absorb_env => tensor_absorb_env_pos generic, public :: spit_env => spit_env_whole generic, public :: spit_env_bond => spit_env_pos_bond, spit_env_name_bond generic, public :: assignment(=) => copy_lat procedure, public :: transpose_lat generic, public :: insert_info => dinsert_info_whole, dinsert_info_pos, dinsert_info_name, zinsert_info_whole, zinsert_info_pos, zinsert_info_name, iinsert_info_whole, iinsert_info_pos, iinsert_info_name, linsert_info_whole, linsert_info_pos, linsert_info_name, ainsert_info_whole, ainsert_info_pos, ainsert_info_name, tinsert_info_whole, tinsert_info_pos, tinsert_info_name procedure, public :: tget_info_whole procedure, public :: aget_info_whole procedure, public :: lget_info_whole procedure, public :: iget_info_whole procedure, public :: zget_info_whole procedure, public :: dget_info_whole procedure, public :: tget_info_pos procedure, public :: aget_info_pos procedure, public :: lget_info_pos procedure, public :: iget_info_pos procedure, public :: zget_info_pos procedure, public :: dget_info_pos procedure, public :: tget_info_name procedure, public :: aget_info_name procedure, public :: lget_info_name procedure, public :: iget_info_name procedure, public :: zget_info_name procedure, public :: dget_info_name generic, public :: get_info => dget_info_whole, dget_info_pos, dget_info_name, zget_info_whole, zget_info_pos, zget_info_name, iget_info_whole, iget_info_pos, iget_info_name, lget_info_whole, lget_info_pos, lget_info_name, aget_info_whole, aget_info_pos, aget_info_name, tget_info_whole, tget_info_pos, tget_info_name procedure, public :: tset_info_whole procedure, public :: aset_info_whole procedure, public :: lset_info_whole procedure, public :: iset_info_whole procedure, public :: zset_info_whole procedure, public :: dset_info_whole procedure, public :: tset_info_pos procedure, public :: aset_info_pos procedure, public :: lset_info_pos procedure, public :: iset_info_pos procedure, public :: zset_info_pos procedure, public :: dset_info_pos procedure, public :: tset_info_name procedure, public :: aset_info_name procedure, public :: lset_info_name procedure, public :: iset_info_name procedure, public :: zset_info_name procedure, public :: dset_info_name generic, public :: set_info => dset_info_whole, dset_info_pos, dset_info_name, zset_info_whole, zset_info_pos, zset_info_name, iset_info_whole, iset_info_pos, iset_info_name, lset_info_whole, lset_info_pos, lset_info_name, aset_info_whole, aset_info_pos, aset_info_name, tset_info_whole, tset_info_pos, tset_info_name type, public :: group Type-Bound Procedures procedure, public :: get_info generic, public :: get_name => get_name_grp generic, public :: set_name => set_name_grp generic, public :: draw => draw_grp generic, public :: empty => empty_grp procedure, public :: check_can_take generic, public :: take => take_pos, take_name, take_group generic, public :: check_contain => check_contain_grp_pos, check_contain_grp_name generic, public :: belong => belong_group generic, public :: assignment(=) => copy_grp procedure, public :: get_names generic, public :: get_num => get_num_group procedure, public :: point_lat generic, public :: invert_bond => invert_bond_grp procedure, public :: get_dangle_inds generic, public :: get_lattice_link => get_lattice_link_grp type, public :: path Type-Bound Procedures generic, public :: get_name => get_name_path generic, public :: set_name => set_name_path generic, public :: belong => belong_path generic, public :: add => add_name, add_pos generic, public :: get_next => get_next_name, get_next_pos generic, public :: get_order => get_order_name, get_order_pos generic, public :: get_name => get_name_order generic, public :: get_pos => get_pos_order generic, public :: get_num => get_num_path generic, public :: iterate => iterate_pos, iterate_name generic, public :: assignment(=) => copy_path generic, public :: inverse => inverse_path generic, public :: clean => clean_path generic, public :: generate => generate_path generic, public :: draw => draw_path generic, public :: get_lattice_link => get_lattice_link_path generic, public :: check_contain => check_contain_path_pos, check_contain_path_name Subroutines public subroutine lat_absorb_tensor (fn_tensor, ori_tensor, G, pos) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout), target :: fn_tensor type(tensor), intent(inout), target :: ori_tensor type( group ), intent(inout) :: G integer, intent(in) :: pos (2) public subroutine lat_absorb_env (fn_tensor, ori_tensor, G, pos) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout), target :: fn_tensor type(tensor), intent(inout), target :: ori_tensor type( group ), intent(inout) :: G integer, intent(in) :: pos (2) public subroutine lat_contract_type (Tout, T1, T2, G1, G2) Arguments Type Intent Optional Attributes Name type(tensor), intent(inout) :: Tout type(tensor), intent(inout) :: T1 type(tensor), intent(inout) :: T2 type( group ), intent(inout) :: G1 type( group ), intent(inout) :: G2","tags":"","loc":"module/tensor_network.html"}]}